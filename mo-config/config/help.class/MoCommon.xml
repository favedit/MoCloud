<?xml version="1.0" encoding="UTF-8"?>
<Configuration>
   <Macroes>
      <Macro name="DEFAULT_DIR_PERMISION" value="0755"/>
      <Macro name="FFileString" value="FFileString32"/>
      <Macro name="FFileString" value="FFileString16"/>
      <Macro name="FFileString" value="FFileString8"/>
      <Macro name="FProperties" value="FProperties32"/>
      <Macro name="FProperties" value="FProperties8"/>
      <Macro name="FProperties" value="FProperties16"/>
      <Macro name="FString" value="FString8"/>
      <Macro name="FString" value="FString32"/>
      <Macro name="FString" value="FString16"/>
      <Macro name="FStrings" value="FString16s"/>
      <Macro name="FStrings" value="FString32s"/>
      <Macro name="FStrings" value="FString8s"/>
      <Macro name="HEX_HEX_DELIMER" value="' '"/>
      <Macro name="HEX_TEX_DELIMER" value="'-'"/>
      <Macro name="INVALID_SOCKET" value="-1"/>
      <Macro name="IntToString" value="IntToString8"/>
      <Macro name="IntToString" value="IntToString32"/>
      <Macro name="IntToString" value="IntToString16"/>
      <Macro name="MAX_UINT32_DIGIT_COUNT" value="10"/>
      <Macro name="MO_ABSTRACT(method)" value="virtual method"/>
      <Macro name="MO_ALIGNED_ALLOC(S, T)" value="valloc(S)"/>
      <Macro name="MO_ALIGNED_ALLOC(S, T)" value="_aligned_malloc(S, T)"/>
      <Macro name="MO_ALIGNED_FREE(P)" value="free(P)"/>
      <Macro name="MO_ALIGNED_FREE(P)" value="_aligned_free(P)"/>
      <Macro name="MO_ALLOC" value="MO_TYPE_ALLOC"/>
      <Macro name="MO_ARG_HOME" value="&quot;-home&quot;"/>
      <Macro name="MO_ASSERT(r)" value=""/>
      <Macro name="MO_ASSERT(r)" value="if(!(r)){MO_THROW(&quot;Result is invalid.&quot;);}"/>
      <Macro name="MO_ASSERT_BETWEEN(r, s, e)" value=""/>
      <Macro name="MO_ASSERT_BETWEEN(r, s, e)" value="if((r &lt; s) || (r &gt; e)){MO_THROW(&quot;Between is invalid.&quot;);}"/>
      <Macro name="MO_ASSERT_ERRNO(r)" value="if(0 != (r)){MO_THROW(&quot;Error is invalid.&quot;);}"/>
      <Macro name="MO_ASSERT_ERRNO(r)" value=""/>
      <Macro name="MO_ASSERT_POINTER(r)" value="if(NULL == r){MO_THROW(&quot;Pointer is invalid.&quot;);}"/>
      <Macro name="MO_ASSERT_POINTER(r)" value=""/>
      <Macro name="MO_ASSERT_RANGE(r, s, e)" value="if((r &lt; s) || (r &gt;= e)){MO_THROW(&quot;Range is invalid.&quot;);}"/>
      <Macro name="MO_ASSERT_RANGE(r, s, e)" value=""/>
      <Macro name="MO_BACKTRACE_MAXCOUNT" value="64"/>
      <Macro name="MO_BACKTRACE_MAXCOUNT" value="64"/>
      <Macro name="MO_BCD_TFIXARRAY(CT, T)" value="template &lt;TInt size&gt; class MO_CM_DECLARE CT : public TFixArray&lt;T, size&gt;{ public:    CT(){    }    CT(const T* pValues, TInt length){       this-&gt;Append(pValues, length);    }    CT(const MPtrC&lt;T&gt;&amp; ptr){       this-&gt;Append(ptr);    } public:    void operator=(const MPtrC&lt;T&gt;&amp; ptr){       this-&gt;Assign(ptr);    } };"/>
      <Macro name="MO_BCD_TFIXSTRING16(C, P)" value="class MO_CM_DECLARE C : public P{ public:    C(){    }    C(const C&amp; value) : P(value){    }    C(TChar16C* pValue, TInt length=-1) : P(pValue, length){    }    C(const MString16PtrC&amp; value) : P(value){    } public:    void operator=(TChar16C* pValue){       this-&gt;Assign(pValue);    }    void operator=(const C&amp; value){       this-&gt;Assign(value.MemoryC(), value.Length());    }    void operator=(const MString16PtrC&amp; value){       this-&gt;Assign(value.MemoryC(), value.Length());    } };"/>
      <Macro name="MO_BCD_TFIXSTRING32(C, P)" value="class MO_CM_DECLARE C : public P{ public:    C(){    }    C(const C&amp; value) : P(value){    }    C(TChar32C* pValue, TInt length=-1) : P(pValue, length){    }    C(const MString32PtrC&amp; value) : P(value){    } public:    void operator=(TChar32C* pValue){       this-&gt;Assign(pValue);    }    void operator=(const C&amp; value){       this-&gt;Assign(value.MemoryC(), value.Length());    }    void operator=(const MString32PtrC&amp; value){       this-&gt;Assign(value.MemoryC(), value.Length());    } };"/>
      <Macro name="MO_BCD_TFIXSTRING8(C, P)" value="class MO_CM_DECLARE C : public P{ public:    C(){    }    C(const C&amp; value) : P(value){    }    C(TChar8C* pValue, TInt length=-1) : P(pValue, length){    }    C(const MString8PtrC&amp; value) : P(value){    } public:    void operator=(TChar8C* pValue){       this-&gt;Assign(pValue);    }    void operator=(const C&amp; value){       this-&gt;Assign(value.MemoryC(), value.Length());    }    void operator=(const MString8PtrC&amp; value){       this-&gt;Assign(value.MemoryC(), value.Length());    } };"/>
      <Macro name="MO_BOOL_FALSE_CHAR" value="'N'"/>
      <Macro name="MO_BOOL_FALSE_STR" value="&quot;N&quot;"/>
      <Macro name="MO_BOOL_TRUE_CHAR" value="'Y'"/>
      <Macro name="MO_BOOL_TRUE_STR" value="&quot;Y&quot;"/>
      <Macro name="MO_CALLBACK(method)" value="extern &quot;C&quot; method"/>
      <Macro name="MO_CAST_CONST(value, type)" value="const_cast&lt;type&gt;(value)"/>
      <Macro name="MO_CAST_DYNAMIC(value, type)" value="dynamic_cast&lt;type&gt;(value)"/>
      <Macro name="MO_CAST_REINTERPRET(value, type)" value="reinterpret_cast&lt;type&gt;(value)"/>
      <Macro name="MO_CAST_STATIC(value, type)" value="static_cast&lt;type&gt;(value)"/>
      <Macro name="MO_CDECL" value=""/>
      <Macro name="MO_CDECL" value="__cdecl"/>
      <Macro name="MO_CHECK(r)" value="if(EFalse == r){MO_THROW(&quot;Result is false.&quot;);}"/>
      <Macro name="MO_CHECK(r)" value=""/>
      <Macro name="MO_CLASS_HEAP(C)" value="protected:    C(){throw EError_Unsupport;}    ~C(){throw EError_Unsupport;}    PPtr operator new(TUint size){throw EError_Unsupport;}    TAny operator delete(PPtr pMemory){throw EError_Unsupport;}"/>
      <Macro name="MO_CLASS_HEAP(C)" value=""/>
      <Macro name="MO_CLASS_STATCK(C)" value=""/>
      <Macro name="MO_CLASS_STATCK(C)" value="protected:    PPtr operator new(TUint size){throw EError_Unsupport;}    TAny operator delete(PPtr pMemory){throw EError_Unsupport;}"/>
      <Macro name="MO_CLEAR(P)" value="P=NULL"/>
      <Macro name="MO_CM_DECLARE" value="MO_EXPORT"/>
      <Macro name="MO_CM_DECLARE" value="MO_IMPORT"/>
      <Macro name="MO_COMPARRAY_THRESHOLD" value="16"/>
      <Macro name="MO_COMPLIST_THRESHOLD" value="8"/>
      <Macro name="MO_COMPSET_THRESHOLD" value="8"/>
      <Macro name="MO_COMPVEC_THRESHOLD" value="16"/>
      <Macro name="MO_CPS_ASCII" value="&quot;ASCII&quot;"/>
      <Macro name="MO_CPS_GB2312" value="&quot;GB2312&quot;"/>
      <Macro name="MO_CPS_UCS4" value="&quot;UCS-4&quot;"/>
      <Macro name="MO_CPS_UNICODE" value="&quot;UNICODE&quot;"/>
      <Macro name="MO_CPS_UTF8" value="&quot;UTF-8&quot;"/>
      <Macro name="MO_CP_ACP" value="0"/>
      <Macro name="MO_CREATE(T, ...)" value="new T(__VA_ARGS__)"/>
      <Macro name="MO_CREATE(T, ...)" value="new T(__VA_ARGS__)"/>
      <Macro name="MO_CRT_BSTR_TO_STRING(V)" value="_com_util::ConvertBSTRToString(V)"/>
      <Macro name="MO_CRT_STRING_TO_BSTR(V)" value="_com_util::ConvertStringToBSTR(V)"/>
      <Macro name="MO_CUSTOM_ALLOC(A, T)" value="(T*)A-&gt;Alloc(#T, sizeof(T), __FILE__, __LINE__)"/>
      <Macro name="MO_CUSTOM_ALLOC(A, T)" value="(T*)A::Alloc(sizeof(T))"/>
      <Macro name="MO_CUSTOM_CREATE(A, T, ...)" value="new (A-&gt;Alloc(#T, sizeof(T), __FILE__, __LINE__))T(__VA_ARGS__)"/>
      <Macro name="MO_CUSTOM_CREATE(A, T, ...)" value="new T(__VA_ARGS__)"/>
      <Macro name="MO_DATETIME_MAXLENGTH" value="64"/>
      <Macro name="MO_DATE_MAXLENGTH" value="32"/>
      <Macro name="MO_DEBUG(M, ...)" value="RLogger::Debug(MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_DEBUG(M, ...)" value=""/>
      <Macro name="MO_DEBUG_BEGIN(M)" value=""/>
      <Macro name="MO_DEBUG_BEGIN(M)" value="RLogger::Error(MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, &quot;----- %s - begin ------------------------------&quot;, #M)"/>
      <Macro name="MO_DEBUG_END(M)" value="RLogger::Error(MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, &quot;----- %s - end --------------------------------&quot;, #M)"/>
      <Macro name="MO_DEBUG_END(M)" value=""/>
      <Macro name="MO_DEFAULT(type)" value="(type)NULL"/>
      <Macro name="MO_DEF_NODE_NAME" value="&quot;Node&quot;"/>
      <Macro name="MO_DEF_ROOT_NAME" value="&quot;Configuration&quot;"/>
      <Macro name="MO_DELETE(P)" value="if(P){delete P;P=NULL;}"/>
      <Macro name="MO_DUMP_INDENT" value="&quot;   &quot;"/>
      <Macro name="MO_DUMP_MAXLENGTH" value="1024*32"/>
      <Macro name="MO_DUMP_SHARED_FMT" value="&quot;%-24s | %15s | &quot;"/>
      <Macro name="MO_DUMP_SHARED_LA" value="&quot;=======================================================================================&quot;"/>
      <Macro name="MO_DUMP_SHARED_LA2" value="&quot;---------------------------------------------------------------------------------------&quot;"/>
      <Macro name="MO_DUMP_SHARED_LB" value="&quot;-------------------------|-----------------|-------------------------------------------&quot;"/>
      <Macro name="MO_DUMP_SHARED_LC" value="&quot;.........................|.................|...........................................&quot;"/>
      <Macro name="MO_EPOLL_PROCESS_COUNT" value="1024"/>
      <Macro name="MO_EPOLL_PROCESS_INTERVAL" value="10"/>
      <Macro name="MO_EPOLL_QUERY_COUNT" value="1024"/>
      <Macro name="MO_EPOLL_QUERY_INTERVAL" value="10000"/>
      <Macro name="MO_EPOLL_SEND_BUFFER" value="8192"/>
      <Macro name="MO_EPOLL_SEND_COUNT" value="1024"/>
      <Macro name="MO_EPOLL_SEND_INTERVAL" value="10"/>
      <Macro name="MO_ERROR(M, ...)" value="RLogger::Error(MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_ERROR_BEGIN" value="ERROR_PROCESS:{"/>
      <Macro name="MO_ERROR_END" value="}"/>
      <Macro name="MO_ERROR_GOTO()" value="goto ERROR_PROCESS"/>
      <Macro name="MO_ERROR_MAXLENGTH" value="1024*4"/>
      <Macro name="MO_EVENT(method)" value="virtual method"/>
      <Macro name="MO_EXIT(code)" value="exit(code)"/>
      <Macro name="MO_EXPORT" value=""/>
      <Macro name="MO_EXPORT" value="__declspec(dllexport)"/>
      <Macro name="MO_EXTERN" value="extern"/>
      <Macro name="MO_EXTERN_C" value="extern &quot;C&quot;"/>
      <Macro name="MO_FACE_RELEASE(P)" value="if(P){P-&gt;Release();P=NULL;}"/>
      <Macro name="MO_FASTCALL" value=""/>
      <Macro name="MO_FASTCALL" value="__fastcall"/>
      <Macro name="MO_FATAL(M, ...)" value="RLogger::Fatal(MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, M, ##__VA_ARGS__);MO_THROW(&quot;Fatal&quot;)"/>
      <Macro name="MO_FILE_BUFFER" value="16384"/>
      <Macro name="MO_FLOAT_MAXLENGTH" value="128"/>
      <Macro name="MO_FMT_HEX" value="&quot;X&quot;"/>
      <Macro name="MO_FMT_HEX" value="&quot;lX&quot;"/>
      <Macro name="MO_FMT_HEX_FULL" value="&quot;08X&quot;"/>
      <Macro name="MO_FMT_HEX_FULL" value="&quot;016lX&quot;"/>
      <Macro name="MO_FMT_INT" value="&quot;d&quot;"/>
      <Macro name="MO_FMT_INT" value="&quot;ld&quot;"/>
      <Macro name="MO_FREE(P)" value="free(P)"/>
      <Macro name="MO_FS_CODE_LENGTH" value="64"/>
      <Macro name="MO_FS_COMMAND_LENGTH" value="1024*2"/>
      <Macro name="MO_FS_DATETIME_LENGTH" value="40"/>
      <Macro name="MO_FS_DUMP_LENGTH" value="1024*8"/>
      <Macro name="MO_FS_FILENAME_LENGTH" value="256"/>
      <Macro name="MO_FS_LABEL_LENGTH" value="256"/>
      <Macro name="MO_FS_LOGGER_LENGTH" value="1024*8"/>
      <Macro name="MO_FS_NAME_LENGTH" value="128"/>
      <Macro name="MO_FS_NOTE_LENGTH" value="1024*4"/>
      <Macro name="MO_FS_NUMBER_LENGTH" value="40"/>
      <Macro name="MO_FS_PATH_LENGTH" value="2048"/>
      <Macro name="MO_FS_SPRINT_LENGTH" value="1024*32"/>
      <Macro name="MO_FS_SQL_LENGTH" value="1024*16"/>
      <Macro name="MO_FS_TEXT_LENGTH" value="1024"/>
      <Macro name="MO_FS_TIMETICK_LENGTH" value="40"/>
      <Macro name="MO_FS_TRACK_LENGTH" value="1024*32"/>
      <Macro name="MO_IMPORT" value=""/>
      <Macro name="MO_IMPORT" value="__declspec(dllimport)"/>
      <Macro name="MO_INFO(M, ...)" value="RLogger::Info (MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_INHERITS(M)" value=""/>
      <Macro name="MO_INHERITS(M)" value="using M"/>
      <Macro name="MO_INHERIT_CONSTRUCT(M, P)" value="M : P {};"/>
      <Macro name="MO_INHERIT_METHOD(M, P)" value="M { P; };"/>
      <Macro name="MO_INHERIT_METHOD_RETURN(M, P, R)" value="M { P; return R; };"/>
      <Macro name="MO_INT_MAXLENGTH" value="32"/>
      <Macro name="MO_IN_RANGE(a,b,c)" value="(((a) &gt; (b)) ? ((a) &lt; (c) ? (a) : (c)) : (b))"/>
      <Macro name="MO_LIB_MEMCPY(D, S, V, L)" value="memcpy_s(D, S, V, L);"/>
      <Macro name="MO_LIB_MEMCPY(D, S, V, L)" value="memcpy(D, V, L);"/>
      <Macro name="MO_LIB_SLEEP(L)" value="usleep(L * 1000);"/>
      <Macro name="MO_LIB_SLEEP(L)" value="::Sleep(L);"/>
      <Macro name="MO_LIB_SPRINTF(D, S, F, ...)" value="sprintf(D, F, __VA_ARGS__)"/>
      <Macro name="MO_LIB_SPRINTF(D, S, F, ...)" value="sprintf_s(D, S, F, __VA_ARGS__)"/>
      <Macro name="MO_LIB_STRCPY(D, S, V)" value="strcpy_s(D, S, V);"/>
      <Macro name="MO_LIB_STRCPY(D, S, V)" value="strcpy(D, V);"/>
      <Macro name="MO_LIB_STRICMP(S, T)" value="_stricmp(S, T);"/>
      <Macro name="MO_LIB_STRICMP(S, T)" value="strcasecmp(S, T);"/>
      <Macro name="MO_LIB_STRNCPY(D, S, V, L)" value="strncpy_s(D, S, V, L);"/>
      <Macro name="MO_LIB_STRNCPY(D, S, V, L)" value="strncpy_s(D, V, L);"/>
      <Macro name="MO_LINE_MAXLENGTH" value="32"/>
      <Macro name="MO_LOGGER_BEGIN" value="if(true){"/>
      <Macro name="MO_LOGGER_END" value="}"/>
      <Macro name="MO_LOGGER_MAXCODE" value="1024"/>
      <Macro name="MO_LOGGER_NET" value="1"/>
      <Macro name="MO_LOGGER_PAD_LENGTH" value="86"/>
      <Macro name="MO_LOGGER_SYSTEM" value="0"/>
      <Macro name="MO_MAX(a,b)" value="(((a) &gt; (b)) ? (a) : (b))"/>
      <Macro name="MO_MAX_LINE" value="512"/>
      <Macro name="MO_MEMORY_ALLOC(T)" value="(T*)RMemoryAllocator::Alloc(#T, sizeof(T), __FILE__, __LINE__)"/>
      <Macro name="MO_MEMORY_ALLOC(T)" value="(T*)malloc(sizeof(T))"/>
      <Macro name="MO_MEMORY_BLOCK" value="8192"/>
      <Macro name="MO_MEMORY_CAPACITY" value="32"/>
      <Macro name="MO_MEMORY_FORMATLENGTH" value="40"/>
      <Macro name="MO_MEMORY_NEW(T, ...)" value="new (RMemoryAllocator::Alloc(#T, sizeof(T), __FILE__, __LINE__))T(__VA_ARGS__)"/>
      <Macro name="MO_MEMORY_NEW(T, ...)" value="new T(__VA_ARGS__)"/>
      <Macro name="MO_MEM_ALLOC(S)" value="malloc(S)"/>
      <Macro name="MO_MEM_CREATE(T, ...)" value="new T(__VA_ARGS__)"/>
      <Macro name="MO_MEM_DELETE(P)" value="if(P){delete P;P=NULL;}"/>
      <Macro name="MO_MEM_DELETE_ARRAY(P)" value="if(P){delete[] P;P=NULL;}"/>
      <Macro name="MO_MEM_FREE(P)" value="if(P){free(P);P=NULL;}"/>
      <Macro name="MO_METHOD_UNSUPPORT(M)" value="M{throw EError_Unsupport;}"/>
      <Macro name="MO_METHOD_UNSUPPORT(M)" value=""/>
      <Macro name="MO_METHOD_UNSUPPORT_DELETE" value="TAny operator delete(PPtr pMemory){throw EError_Unsupport;};"/>
      <Macro name="MO_METHOD_UNSUPPORT_DELETE" value=""/>
      <Macro name="MO_METHOD_UNSUPPORT_NEW" value="PPtr operator new(TUint size){throw EError_Unsupport;};"/>
      <Macro name="MO_METHOD_UNSUPPORT_NEW" value=""/>
      <Macro name="MO_MIN(a,b)" value="(((a) &lt; (b)) ? (a) : (b))"/>
      <Macro name="MO_MONITOR_INTERVAL" value="1000000"/>
      <Macro name="MO_MYSQL_FILEDS" value="256"/>
      <Macro name="MO_MYSQL_PORT" value="3306"/>
      <Macro name="MO_MYSQL_ROW_BUFFER" value="16384"/>
      <Macro name="MO_NAKED" value=""/>
      <Macro name="MO_NAKED" value="__declspec(naked)"/>
      <Macro name="MO_NAMESPACE" value="MO"/>
      <Macro name="MO_NAMESPACE_BEGIN" value="namespace MO_NAMESPACE{"/>
      <Macro name="MO_NAMESPACE_END" value="}"/>
      <Macro name="MO_NAMESPACE_USING" value="using namespace MO_NAMESPACE;"/>
      <Macro name="MO_NET_BLOCK_SIZE" value="1024*16"/>
      <Macro name="MO_NET_DEBUG(M, ...)" value=""/>
      <Macro name="MO_NET_DEBUG(M, ...)" value="RLogger::Debug(MO_LOGGER_NET, this, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_NET_ERROR(M, ...)" value="RLogger::Error(MO_LOGGER_NET, this, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_NET_HOST_LENGTH" value="80"/>
      <Macro name="MO_NET_INFO(M, ...)" value="RLogger::Info (MO_LOGGER_NET, this, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_NET_PROCESS_COUNT" value="2"/>
      <Macro name="MO_NET_SOCKET_COUNT" value="65536"/>
      <Macro name="MO_NET_TRACK(M, ...)" value="RLogger::Info (MO_LOGGER_NET, this, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_NET_WARN(M, ...)" value="RLogger::Warn (MO_LOGGER_NET, this, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_NODE_EACH(I, X)" value="TXmlNodeIteratorC I = X-&gt;NodeIteratorC();while(I.next())"/>
      <Macro name="MO_NOVTABLE" value="__declspec(novtable)"/>
      <Macro name="MO_NOVTABLE" value=""/>
      <Macro name="MO_NVL(a,b)" value="(NULL==(a)?(a):(b))"/>
      <Macro name="MO_OBJECT_CAPACITY" value="16"/>
      <Macro name="MO_OVERRIDE(method)" value="method"/>
      <Macro name="MO_PERROR(M)" value="RLogger::Error(MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, &quot;Call method '&quot;#M&quot;' error.(%d=%s) =&gt; %s(%d)&quot;, errno, strerror(errno), __FILE__, __LINE__)"/>
      <Macro name="MO_PERROR(M)" value="{TChar8 __mo_perror[8192];strerror_s(__mo_perror,8192,errno);RLogger::Error(MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, &quot;Call method '&quot;#M&quot;' error.(%d=%s) =&gt; %s(%d)&quot;, errno, __mo_perror, __FILE__, __LINE__);}"/>
      <Macro name="MO_PEXIT()" value="exit(errno)"/>
      <Macro name="MO_PFATAL(M)" value="RLogger::Error(MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, &quot;Call method '&quot;#M&quot;' error.(%d=%s) =&gt; %s(%d)&quot;, errno, strerror(errno), __FILE__, __LINE__);exit(errno)"/>
      <Macro name="MO_PFATAL(M)" value="{TChar8 __mo_perror[8192];strerror_s(__mo_perror,8192,errno);RLogger::Error(MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, &quot;Call method '&quot;#M&quot;' error.(%d=%s) =&gt; %s(%d)&quot;, errno, __mo_perror, __FILE__, __LINE__);exit(errno);}"/>
      <Macro name="MO_PI" value="3.14159265358979323846"/>
      <Macro name="MO_PIPE_RESERVE_LENGTH" value="16"/>
      <Macro name="MO_POLL_SIZE" value="16384;"/>
      <Macro name="MO_PROCESS_ALLOC(T, ...)" value="(T*)RProcessMemory::Alloc(#T, sizeof(T), __FILE__, __LINE__)"/>
      <Macro name="MO_PROCESS_CREATE(T, ...)" value="new (RProcessMemory::Alloc(#T, sizeof(T), __FILE__, __LINE__))T(__VA_ARGS__)"/>
      <Macro name="MO_PROCESS_DELETE(P)" value="P-&gt;Dispose();RProcessMemory::Free(P)"/>
      <Macro name="MO_PROCESS_FREE(P)" value="RProcessMemory::Free(P)"/>
      <Macro name="MO_PTR_CREATE(T, ...)" value="new T(__VA_ARGS__)"/>
      <Macro name="MO_PTR_DELETE(P)" value="if(P){delete P;P=NULL;}"/>
      <Macro name="MO_PTR_RELEASE(P)" value="if(P){P-&gt;Release();P=NULL;}"/>
      <Macro name="MO_PTY_NAME" value="&quot;name&quot;"/>
      <Macro name="MO_RS_FAILED(r)" value="(((HRESULT)(r)) &lt; 0)"/>
      <Macro name="MO_RS_SUCCEEDED(r)" value="(((HRESULT)(r)) &gt;= 0)"/>
      <Macro name="MO_SHARE_ALLOC(T, ...)" value="(T*)RShareMemory::Alloc(#T, sizeof(T), __FILE__, __LINE__)"/>
      <Macro name="MO_SHARE_CREATE(S, T, ...)" value="new(S-&gt;MemoryC())T(__VA_ARGS__)"/>
      <Macro name="MO_SHARE_DELETE(P)" value="P-&gt;Dispose();RShareMemory::Free(P)"/>
      <Macro name="MO_SHARE_FREE(P)" value="RShareMemory::Free(P)"/>
      <Macro name="MO_SHARE_MEMORY_ACCESS" value="0666"/>
      <Macro name="MO_SHARE_MEMORY_FLAG" value="&quot;MOSM&quot;"/>
      <Macro name="MO_SORT_SWAP(tmp, a, b)" value="do { (tmp) = (a); (a) = (b); (b) = (tmp); } while(0)"/>
      <Macro name="MO_STATIC_DEBUG(M, ...)" value=""/>
      <Macro name="MO_STATIC_DEBUG(M, ...)" value="RLogger::Debug(MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_STATIC_DEBUG_BEGIN(M)" value=""/>
      <Macro name="MO_STATIC_DEBUG_BEGIN(M)" value="RLogger::Error(MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, &quot;----- %s - begin ------------------------------&quot;, #M)"/>
      <Macro name="MO_STATIC_DEBUG_END(M)" value="RLogger::Error(MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, &quot;----- %s - end --------------------------------&quot;, #M)"/>
      <Macro name="MO_STATIC_DEBUG_END(M)" value=""/>
      <Macro name="MO_STATIC_ERROR(M, ...)" value="RLogger::Error(MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_STATIC_FATAL(M, ...)" value="RLogger::Fatal(MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__);MO_THROW(&quot;Fatal&quot;)"/>
      <Macro name="MO_STATIC_FATAL(M, ...)" value="RLogger::Fatal(MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__);MO_THROW(&quot;Fatal&quot;)"/>
      <Macro name="MO_STATIC_INFO(M, ...)" value="RLogger::Info (MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_STATIC_NET_DEBUG(M, ...)" value=""/>
      <Macro name="MO_STATIC_NET_DEBUG(M, ...)" value="RLogger::Debug(MO_LOGGER_NET, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_STATIC_NET_ERROR(M, ...)" value="RLogger::Error(MO_LOGGER_NET, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_STATIC_NET_INFO(M, ...)" value="RLogger::Info (MO_LOGGER_NET, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_STATIC_NET_TRACK(M, ...)" value="RLogger::Info (MO_LOGGER_NET, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_STATIC_NET_WARN(M, ...)" value="RLogger::Warn (MO_LOGGER_NET, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_STATIC_PERROR(M)" value="RLogger::Error(MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, &quot;Call method '&quot;#M&quot;' error.(%d=%s) =&gt; %s(%d)&quot;, errno, strerror(errno), __FILE__, __LINE__)"/>
      <Macro name="MO_STATIC_PERROR(M)" value="{TChar8 __mo_perror[8192];strerror_s(__mo_perror,8192,errno);RLogger::Error(MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, &quot;Call method '&quot;#M&quot;' error.(%d=%s) =&gt; %s(%d)&quot;, errno, __mo_perror, __FILE__, __LINE__);}"/>
      <Macro name="MO_STATIC_PFATAL(M)" value="{TChar8 __mo_perror[8192];strerror_s(__mo_perror,8192,errno);RLogger::Error(MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, &quot;Call method '&quot;#M&quot;' error.(%d=%s) =&gt; %s(%d)&quot;, errno, __mo_perror, __FILE__, __LINE__);exit(errno);}"/>
      <Macro name="MO_STATIC_PFATAL(M)" value="RLogger::Error(MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, &quot;Call method '&quot;#M&quot;' error.(%d=%s) =&gt; %s(%d)&quot;, errno, strerror(errno), __FILE__, __LINE__);exit(errno)"/>
      <Macro name="MO_STATIC_TRACK(M, ...)" value="RLogger::Info (MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_STATIC_WARN(M, ...)" value="RLogger::Warn (MO_LOGGER_SYSTEM, NULL, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_STDCALL" value=""/>
      <Macro name="MO_STDCALL" value="__stdcall"/>
      <Macro name="MO_SYNCHRONIZED_BEGIN(L)" value="L-&gt;Enter();"/>
      <Macro name="MO_SYNCHRONIZED_END(L)" value="L-&gt;Leave();"/>
      <Macro name="MO_TAG_PROPERTY" value="&quot;Property&quot;"/>
      <Macro name="MO_THREAD_ALLOC(T, ...)" value="(T*)RThreadMemory::Alloc(#T, sizeof(T), __FILE__, __LINE__)"/>
      <Macro name="MO_THREAD_CREATE(T, ...)" value="new (RThreadMemory::Alloc(#T, sizeof(T), __FILE__, __LINE__))T(__VA_ARGS__)"/>
      <Macro name="MO_THREAD_DELETE(P)" value="P-&gt;Dispose();RThreadMemory::Free(P)"/>
      <Macro name="MO_THREAD_FREE(P)" value="RThreadMemory::Free(P)"/>
      <Macro name="MO_THROW(s)" value="printf(&quot;%s\n--&gt; %s\n--&gt; %s(%d)\n&quot;, s, __PRETTY_FUNCTION__, __FILE__, __LINE__);__asm__ __volatile__ (&quot;int $3&quot;);exit(0)"/>
      <Macro name="MO_THROW(s)" value="printf(&quot;%s\n--&gt; %s\n--&gt; %s(%d)\n&quot;, s, __PRETTY_FUNCTION__, __FILE__, __LINE__);__asm{int 3};exit(0)"/>
      <Macro name="MO_TIMESPAN_MAXLENGTH" value="64"/>
      <Macro name="MO_TIME_MAXLENGTH" value="32"/>
      <Macro name="MO_TRACK(M, ...)" value="RLogger::Info (MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MO_TRAP(M)" value="{TTrapper t; M;}"/>
      <Macro name="MO_TRAP(M)" value="M"/>
      <Macro name="MO_TYPE_ALLOC(T)" value="(T*)RAllocator::TypeAlloc(#T, sizeof(T), __FILE__, __LINE__)"/>
      <Macro name="MO_TYPE_ALLOC(T)" value="(T*)malloc(sizeof(T))"/>
      <Macro name="MO_USING_NAMESPACE(N)" value="using namespace N;"/>
      <Macro name="MO_VIRTUAL(method)" value="virtual method = 0"/>
      <Macro name="MO_WARN(M, ...)" value="RLogger::Warn (MO_LOGGER_SYSTEM, this, __PRETTY_FUNCTION__, M, ##__VA_ARGS__)"/>
      <Macro name="MStringC" value="MString32C"/>
      <Macro name="MStringC" value="MString16C"/>
      <Macro name="MStringC" value="MString8C"/>
      <Macro name="SIGSEGV_STACK_GENERIC" value=""/>
      <Macro name="SIGSEGV_STACK_GENERIC" value=""/>
      <Macro name="SIGSEGV_STACK_IA64" value=""/>
      <Macro name="SIGSEGV_STACK_IA64" value=""/>
      <Macro name="SIGSEGV_STACK_X86" value=""/>
      <Macro name="SIGSEGV_STACK_X86" value=""/>
      <Macro name="SOCKET_ERROR" value="-1"/>
      <Macro name="TFixChar16s" value="TFixChars;"/>
      <Macro name="TFixChar8s" value="TFixChars;"/>
      <Macro name="TFixString" value="TFixString32"/>
      <Macro name="TFixString" value="TFixString16"/>
      <Macro name="TFixString" value="TFixString8"/>
      <Macro name="TFsCode" value="TFsCode16"/>
      <Macro name="TFsCode" value="TFsCode32"/>
      <Macro name="TFsCode" value="TFsCode8"/>
      <Macro name="TFsCommand" value="TFsCommand16"/>
      <Macro name="TFsCommand" value="TFsCommand32"/>
      <Macro name="TFsCommand" value="TFsCommand8"/>
      <Macro name="TFsDump" value="TFsDump16"/>
      <Macro name="TFsDump" value="TFsDump32"/>
      <Macro name="TFsDump" value="TFsDump8"/>
      <Macro name="TFsFileName" value="TFsFileName16"/>
      <Macro name="TFsFileName" value="TFsFileName8"/>
      <Macro name="TFsFileName" value="TFsFileName32"/>
      <Macro name="TFsLabel" value="TFsLabel32"/>
      <Macro name="TFsLabel" value="TFsLabel16"/>
      <Macro name="TFsLabel" value="TFsLabel8"/>
      <Macro name="TFsLogger" value="TFsLogger8"/>
      <Macro name="TFsLogger" value="TFsLogger32"/>
      <Macro name="TFsLogger" value="TFsLogger16"/>
      <Macro name="TFsName" value="TFsName8"/>
      <Macro name="TFsName" value="TFsName16"/>
      <Macro name="TFsName" value="TFsName32"/>
      <Macro name="TFsNote" value="TFsNote16"/>
      <Macro name="TFsNote" value="TFsNote8"/>
      <Macro name="TFsNote" value="TFsNote32"/>
      <Macro name="TFsNumber" value="TFsNumber8"/>
      <Macro name="TFsNumber" value="TFsNumber16"/>
      <Macro name="TFsNumber" value="TFsNumber32"/>
      <Macro name="TFsPath" value="TFsPath8"/>
      <Macro name="TFsPath" value="TFsPath16"/>
      <Macro name="TFsPath" value="TFsPath32"/>
      <Macro name="TFsSql" value="TFsSql16"/>
      <Macro name="TFsSql" value="TFsSql8"/>
      <Macro name="TFsSql" value="TFsSql32"/>
      <Macro name="TFsText" value="TFsText16"/>
      <Macro name="TFsText" value="TFsText32"/>
      <Macro name="TFsText" value="TFsText8"/>
      <Macro name="TFsTimeTick" value="TFsTimeTick16"/>
      <Macro name="TFsTimeTick" value="TFsTimeTick8"/>
      <Macro name="TFsTimeTick" value="TFsTimeTick32"/>
      <Macro name="TFsTrack" value="TFsTrack16"/>
      <Macro name="TFsTrack" value="TFsTrack8"/>
      <Macro name="TFsTrack" value="TFsTrack32"/>
      <Macro name="TString" value="TString32"/>
      <Macro name="TString" value="TString8"/>
      <Macro name="TString" value="TString16"/>
      <Macro name="TStringPtr" value="TString16Ptr"/>
      <Macro name="TStringPtr" value="TString8Ptr"/>
      <Macro name="TStringPtr" value="TString32Ptr"/>
      <Macro name="TStringRefer" value="TString16Refer"/>
      <Macro name="TStringRefer" value="TString32Refer"/>
      <Macro name="TStringRefer" value="TString8Refer"/>
      <Macro name="_MOCMSYSTEMTEMP_H" value=""/>
      <Macro name="_MO_ASSERT" value=""/>
      <Macro name="_MO_LOGGER" value=""/>
      <Macro name="_MO_MEMORY" value=""/>
      <Macro name="_S(S)" value="TStringPtr(S)"/>
      <Macro name="_T(S)" value="S"/>
      <Macro name="_T(S)" value="L##S"/>
      <Macro name="__MO_CM_ARRAY_H__" value=""/>
      <Macro name="__MO_CM_ATOMSTORAGE_H__" value=""/>
      <Macro name="__MO_CM_ATOM_H__" value=""/>
      <Macro name="__MO_CM_COLLECTION_H__" value=""/>
      <Macro name="__MO_CM_DATA_H__" value=""/>
      <Macro name="__MO_CM_DEFINE_H__" value=""/>
      <Macro name="__MO_CM_DICTIONARY_H__" value=""/>
      <Macro name="__MO_CM_ENTRY_H__" value=""/>
      <Macro name="__MO_CM_FILE_H__" value=""/>
      <Macro name="__MO_CM_LANGUAGE_H__" value=""/>
      <Macro name="__MO_CM_LINKED_H__" value=""/>
      <Macro name="__MO_CM_LIST_H__" value=""/>
      <Macro name="__MO_CM_LOCK_H__" value=""/>
      <Macro name="__MO_CM_LUA_H__" value=""/>
      <Macro name="__MO_CM_MAP_H__" value=""/>
      <Macro name="__MO_CM_MEMORY_H__" value=""/>
      <Macro name="__MO_CM_MONITOR_H__" value=""/>
      <Macro name="__MO_CM_NET_EPOLL_H__" value=""/>
      <Macro name="__MO_CM_NET_H__" value=""/>
      <Macro name="__MO_CM_NET_IOCP_H__" value=""/>
      <Macro name="__MO_CM_OBJECTS_H__" value=""/>
      <Macro name="__MO_CM_PTR_H__" value=""/>
      <Macro name="__MO_CM_SET_H__" value=""/>
      <Macro name="__MO_CM_SHAREDENTRY_H__" value=""/>
      <Macro name="__MO_CM_SHAREDLIST_H__" value=""/>
      <Macro name="__MO_CM_SHAREDSET_H__" value=""/>
      <Macro name="__MO_CM_SHARED_H__" value=""/>
      <Macro name="__MO_CM_SINGLETON_H__" value=""/>
      <Macro name="__MO_CM_SORT_H__" value=""/>
      <Macro name="__MO_CM_STACK_H__" value=""/>
      <Macro name="__MO_CM_STREAM_H__" value=""/>
      <Macro name="__MO_CM_STRING16_H__" value=""/>
      <Macro name="__MO_CM_STRING32_H__" value=""/>
      <Macro name="__MO_CM_STRING8_H__" value=""/>
      <Macro name="__MO_CM_STRUCT_H__" value=""/>
      <Macro name="__MO_CM_SYSTEM_H__" value=""/>
      <Macro name="__MO_CM_TREE_H__" value=""/>
      <Macro name="__MO_CM_TYPEMEMORY_H__" value=""/>
      <Macro name="__MO_CM_TYPES_H__" value=""/>
      <Macro name="__MO_CM_VECTOR_H__" value=""/>
      <Macro name="__MO_CM_XML_H__" value=""/>
      <Macro name="__MO_COMMON_H__" value=""/>
      <Macro name="__PRETTY_FUNCTION__" value="__FUNCTION__"/>
   </Macroes>
   <Namespaces>
      <Namespace name="MO">
         <Typedefs>
            <Typedef name="CRunable" value="TInt (*CRunable)(TAny* pParameter);"/>
            <Typedef name="FArray&lt;FString*&gt;" value="FStringArray"/>
            <Typedef name="FArray&lt;FXmlNode*&gt;" value="FXmlNodeArray"/>
            <Typedef name="FArray&lt;TAny*&gt;" value="FPtrs"/>
            <Typedef name="FArray&lt;TBool&gt;" value="FBools"/>
            <Typedef name="FArray&lt;TByte&gt;" value="FBytes"/>
            <Typedef name="FArray&lt;TChar16&gt;" value="FChar16s"/>
            <Typedef name="FArray&lt;TChar8&gt;" value="FChar8s"/>
            <Typedef name="FArray&lt;TChar&gt;" value="FChars"/>
            <Typedef name="FArray&lt;TDouble&gt;" value="FDoubles"/>
            <Typedef name="FArray&lt;TFloat&gt;" value="FFloats"/>
            <Typedef name="FArray&lt;TInt16&gt;" value="FInt16s"/>
            <Typedef name="FArray&lt;TInt32&gt;" value="FInt32s"/>
            <Typedef name="FArray&lt;TInt64&gt;" value="FInt64s"/>
            <Typedef name="FArray&lt;TInt8&gt;" value="FInt8s"/>
            <Typedef name="FArray&lt;TInt&gt;" value="FInts"/>
            <Typedef name="FArray&lt;TUint16&gt;" value="FUint16s"/>
            <Typedef name="FArray&lt;TUint32&gt;" value="FUint32s"/>
            <Typedef name="FArray&lt;TUint64&gt;" value="FUint64s"/>
            <Typedef name="FArray&lt;TUint8&gt;" value="FUint8s"/>
            <Typedef name="FArray&lt;TUint&gt;" value="FUints"/>
            <Typedef name="FChar16s" value="FChars"/>
            <Typedef name="FChar8s" value="FChars"/>
            <Typedef name="FDictionary&lt;FXmlNode*&gt;" value="FXmlNodeDictionary"/>
            <Typedef name="FDictionary&lt;TAny*&gt;" value="FPtrDictionary"/>
            <Typedef name="FILE*" value="TFileHandle"/>
            <Typedef name="FList&lt;A*&gt;" value="FAtomAllocatorList"/>
            <Typedef name="FList&lt;FBlockAllocator*&gt;" value="FBlockAllocatorList"/>
            <Typedef name="FList&lt;FBlockLockAllocator*&gt;" value="FBlockLockAllocatorList"/>
            <Typedef name="FList&lt;FNetClientSocket*&gt;" value="FNetClientSocketList"/>
            <Typedef name="FList&lt;FNetServerSocket*&gt;" value="FNetServerSocketList"/>
            <Typedef name="FList&lt;FNetSocket*&gt;" value="FNetSocketList"/>
            <Typedef name="FList&lt;FShared*&gt;" value="FSharedList"/>
            <Typedef name="FList&lt;FString*&gt;" value="FStringList"/>
            <Typedef name="FList&lt;FThreadWorker*&gt;" value="FThreadWorkerList"/>
            <Typedef name="FList&lt;FXmlDocument*&gt;" value="FXmlDocumentList"/>
            <Typedef name="FList&lt;FXmlNode*&gt;" value="FXmlNodeList"/>
            <Typedef name="FList&lt;IConfig*&gt;" value="FConfigList"/>
            <Typedef name="FList&lt;IConfiguration*&gt;" value="FConfiguraList"/>
            <Typedef name="FList&lt;IConsole*&gt;" value="FManagerList"/>
            <Typedef name="FList&lt;IListener*&gt;" value="FListenerList"/>
            <Typedef name="FList&lt;IMonitor*&gt;" value="FMonitorList"/>
            <Typedef name="FList&lt;ISingleton*&gt;" value="FSingletonList"/>
            <Typedef name="FList&lt;R*&gt;" value="FReaderList"/>
            <Typedef name="FList&lt;W*&gt;" value="FWriterList"/>
            <Typedef name="FNcDictionary&lt;TAny*&gt;" value="FPtrNcDictionary"/>
            <Typedef name="FSet&lt;TInt, FShared*&gt;" value="FSharedSet"/>
            <Typedef name="FSet&lt;TInt, FThreadTrap*&gt;" value="FThreadTrapSet"/>
            <Typedef name="FSet&lt;TInt, FTrapBlock*&gt;" value="FTrapBlockSet"/>
            <Typedef name="FSet&lt;TInt, FXmlDocument*&gt;" value="FXmlDocumentSet"/>
            <Typedef name="FSet&lt;TInt, FXmlNode*&gt;" value="FXmlNodeSet"/>
            <Typedef name="FSet&lt;TInt, IConfig*&gt;" value="FConfigSet"/>
            <Typedef name="FSet&lt;TInt, IConfiguration*&gt;" value="FConfiguraSet"/>
            <Typedef name="FSet&lt;TInt, IConsole*&gt;" value="FManagerSet"/>
            <Typedef name="FSet&lt;TInt, ISingleton*&gt;" value="FSingletonSet"/>
            <Typedef name="FSet&lt;TShareKey, FSharedGroup*&gt;" value="FSharedGroupSet"/>
            <Typedef name="FSet&lt;TThreadId, FThread*&gt;" value="FThreadSet"/>
            <Typedef name="FSet&lt;TUint, FBlockAllocator*&gt;" value="FBlockAllocatorSet"/>
            <Typedef name="FSet&lt;TUint, FBlockLockAllocator*&gt;" value="FBlockLockAllocatorSet"/>
            <Typedef name="FVector&lt;FString*&gt;" value="FStringVector"/>
            <Typedef name="FVector&lt;FString16*&gt;" value="FString16Vector"/>
            <Typedef name="FVector&lt;FString16*&gt;::TIteratorC" value="TString16sIteratorC"/>
            <Typedef name="FVector&lt;FString32*&gt;" value="FString32Vector"/>
            <Typedef name="FVector&lt;FString32*&gt;::TIteratorC" value="TString32sIteratorC"/>
            <Typedef name="FVector&lt;FString8*&gt;" value="FString8Vector"/>
            <Typedef name="FVector&lt;FXmlNode*&gt;" value="FXmlNodeVector"/>
            <Typedef name="FVector&lt;TAny*&gt;" value="FPtrVector"/>
            <Typedef name="FVector&lt;TBool&gt;" value="FBoolVector"/>
            <Typedef name="FVector&lt;TByte&gt;" value="FByteVector"/>
            <Typedef name="FVector&lt;TChar16&gt;" value="FChar16Vector"/>
            <Typedef name="FVector&lt;TChar8&gt;" value="FChar8Vector"/>
            <Typedef name="FVector&lt;TChar&gt;" value="FCharVector"/>
            <Typedef name="FVector&lt;TDouble&gt;" value="FDoubleVector"/>
            <Typedef name="FVector&lt;TFloat&gt;" value="FFloatVector"/>
            <Typedef name="FVector&lt;TInt16&gt;" value="FInt16Vector"/>
            <Typedef name="FVector&lt;TInt32&gt;" value="FInt32Vector"/>
            <Typedef name="FVector&lt;TInt64&gt;" value="FInt64Vector"/>
            <Typedef name="FVector&lt;TInt8&gt;" value="FInt8Vector"/>
            <Typedef name="FVector&lt;TInt&gt;" value="FIntVector"/>
            <Typedef name="FVector&lt;TUint16&gt;" value="FUint16Vector"/>
            <Typedef name="FVector&lt;TUint32&gt;" value="FUint32Vector"/>
            <Typedef name="FVector&lt;TUint64&gt;" value="FUint64Vector"/>
            <Typedef name="FVector&lt;TUint8&gt;" value="FUint8Vector"/>
            <Typedef name="FVector&lt;TUint&gt;" value="FUintVector"/>
            <Typedef name="HINSTANCE" value="TInstance"/>
            <Typedef name="MArrayC&lt;TAny&gt;" value="MAnysC"/>
            <Typedef name="MArrayC&lt;TBool&gt;" value="MBoolsC"/>
            <Typedef name="MArrayC&lt;TByte&gt;" value="MBytesC"/>
            <Typedef name="MArrayC&lt;TChar16&gt;" value="MChar16sC"/>
            <Typedef name="MArrayC&lt;TChar8&gt;" value="MChar8sC"/>
            <Typedef name="MArrayC&lt;TDouble&gt;" value="MDoublesC"/>
            <Typedef name="MArrayC&lt;TFloat&gt;" value="MFloatsC"/>
            <Typedef name="MArrayC&lt;TInt16&gt;" value="MInt16sC"/>
            <Typedef name="MArrayC&lt;TInt32&gt;" value="MInt32sC"/>
            <Typedef name="MArrayC&lt;TInt64&gt;" value="MInt64sC"/>
            <Typedef name="MArrayC&lt;TInt&gt;" value="MIntsC"/>
            <Typedef name="MArrayC&lt;TUint16&gt;" value="MUint16sC"/>
            <Typedef name="MArrayC&lt;TUint32&gt;" value="MUint32sC"/>
            <Typedef name="MArrayC&lt;TUint64&gt;" value="MUint64sC"/>
            <Typedef name="MArrayC&lt;TUint&gt;" value="MUintsC"/>
            <Typedef name="MChar16PtrC" value="MString16PtrC"/>
            <Typedef name="MChar16sC" value="MCharsC"/>
            <Typedef name="MChar32PtrC" value="MString32PtrC"/>
            <Typedef name="MChar8PtrC" value="MString8PtrC"/>
            <Typedef name="MChar8sC" value="MCharsC"/>
            <Typedef name="MCharPtrC" value="MStringPtrC"/>
            <Typedef name="MLinkedEntryC&lt;E&gt;" value="MLinkedC"/>
            <Typedef name="MLinkedEntryC&lt;SEntry*&gt;" value="MLinkedC"/>
            <Typedef name="MPtrC&lt;TAny&gt;" value="MAnyPtrC"/>
            <Typedef name="MPtrC&lt;TBool&gt;" value="MBoolPtrC"/>
            <Typedef name="MPtrC&lt;TByte&gt;" value="MBytePtrC"/>
            <Typedef name="MPtrC&lt;TChar16&gt;" value="MChar16PtrC"/>
            <Typedef name="MPtrC&lt;TChar32&gt;" value="MChar32PtrC"/>
            <Typedef name="MPtrC&lt;TChar8&gt;" value="MChar8PtrC"/>
            <Typedef name="MPtrC&lt;TChar&gt;" value="MCharPtrC"/>
            <Typedef name="MPtrC&lt;TDouble&gt;" value="MDoublePtrC"/>
            <Typedef name="MPtrC&lt;TFloat&gt;" value="MFloatPtrC"/>
            <Typedef name="MPtrC&lt;TInt16&gt;" value="MInt16PtrC"/>
            <Typedef name="MPtrC&lt;TInt32&gt;" value="MInt32PtrC"/>
            <Typedef name="MPtrC&lt;TInt64&gt;" value="MInt64PtrC"/>
            <Typedef name="MPtrC&lt;TInt8&gt;" value="MInt8PtrC"/>
            <Typedef name="MPtrC&lt;TInt&gt;" value="MIntPtrC"/>
            <Typedef name="MPtrC&lt;TUint16&gt;" value="MUint16PtrC"/>
            <Typedef name="MPtrC&lt;TUint32&gt;" value="MUint32PtrC"/>
            <Typedef name="MPtrC&lt;TUint64&gt;" value="MUint64PtrC"/>
            <Typedef name="MPtrC&lt;TUint8&gt;" value="MUint8PtrC"/>
            <Typedef name="MPtrC&lt;TUint&gt;" value="MUintPtrC"/>
            <Typedef name="RChar16" value="RChar"/>
            <Typedef name="RChar8" value="RChar"/>
            <Typedef name="RSingleton&lt;FLoggerConsole&gt;" value="RLoggerManager"/>
            <Typedef name="RSingleton&lt;FMonitorConsole&gt;" value="RMonitorManager"/>
            <Typedef name="RSingleton&lt;FSharedConsole&gt;" value="RSharedManager"/>
            <Typedef name="RSingleton&lt;FThreadConsole&gt;" value="RThreadManager"/>
            <Typedef name="RString16" value="RString"/>
            <Typedef name="RString8" value="RString"/>
            <Typedef name="RTypeMemory&lt;TBool&gt;" value="RBoolMemory"/>
            <Typedef name="RTypeMemory&lt;TByte&gt;" value="RByteMemory"/>
            <Typedef name="RTypeMemory&lt;TChar16&gt;" value="RChar16Memory"/>
            <Typedef name="RTypeMemory&lt;TChar8&gt;" value="RChar8Memory"/>
            <Typedef name="RTypeMemory&lt;TChar&gt;" value="RCharMemory"/>
            <Typedef name="RTypeMemory&lt;TDouble&gt;" value="RDoubleMemory"/>
            <Typedef name="RTypeMemory&lt;TFloat&gt;" value="RFloatMemory"/>
            <Typedef name="RTypeMemory&lt;TInt16&gt;" value="RInt16Memory"/>
            <Typedef name="RTypeMemory&lt;TInt32&gt;" value="RInt32Memory"/>
            <Typedef name="RTypeMemory&lt;TInt64&gt;" value="RInt64Memory"/>
            <Typedef name="RTypeMemory&lt;TInt8&gt;" value="RInt8Memory"/>
            <Typedef name="RTypeMemory&lt;TInt&gt;" value="RIntMemory"/>
            <Typedef name="RTypeMemory&lt;TUint16&gt;" value="RUint16Memory"/>
            <Typedef name="RTypeMemory&lt;TUint32&gt;" value="RUint32Memory"/>
            <Typedef name="RTypeMemory&lt;TUint64&gt;" value="RUint64Memory"/>
            <Typedef name="RTypeMemory&lt;TUint8&gt;" value="RUint8Memory"/>
            <Typedef name="RTypeMemory&lt;TUint&gt;" value="RUintMemory"/>
            <Typedef name="RTypes&lt;TBool&gt;" value="RBools"/>
            <Typedef name="RTypes&lt;TByte&gt;" value="RBytes"/>
            <Typedef name="RTypes&lt;TChar16&gt;" value="RChar16s"/>
            <Typedef name="RTypes&lt;TChar8&gt;" value="RChar8s"/>
            <Typedef name="RTypes&lt;TChar&gt;" value="RChars"/>
            <Typedef name="RTypes&lt;TDouble&gt;" value="RDoubles"/>
            <Typedef name="RTypes&lt;TFloat&gt;" value="RFloats"/>
            <Typedef name="RTypes&lt;TInt16&gt;" value="RInt16s"/>
            <Typedef name="RTypes&lt;TInt32&gt;" value="RInt32s"/>
            <Typedef name="RTypes&lt;TInt64&gt;" value="RInt64s"/>
            <Typedef name="RTypes&lt;TInt8&gt;" value="RInt8s"/>
            <Typedef name="RTypes&lt;TInt&gt;" value="RInts"/>
            <Typedef name="RTypes&lt;TUbyte&gt;" value="RUbytes"/>
            <Typedef name="RTypes&lt;TUint16&gt;" value="RUint16s"/>
            <Typedef name="RTypes&lt;TUint32&gt;" value="RUint32s"/>
            <Typedef name="RTypes&lt;TUint64&gt;" value="RUint64s"/>
            <Typedef name="RTypes&lt;TUint8&gt;" value="RUint8s"/>
            <Typedef name="RTypes&lt;TUint&gt;" value="RUints"/>
            <Typedef name="SAreaTpl&lt;TDouble&gt;" value="SDoubleArea"/>
            <Typedef name="SAreaTpl&lt;TFloat&gt;" value="SFloatArea"/>
            <Typedef name="SAreaTpl&lt;TInt&gt;" value="SIntArea"/>
            <Typedef name="SAtomEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SAttributesEntry" value="SEntry"/>
            <Typedef name="SAttributesEntry" value="SEntry"/>
            <Typedef name="SAttributesEntry" value="SEntry"/>
            <Typedef name="SAttributesEntry" value="SEntry"/>
            <Typedef name="SAttributesEntry" value="SEntry"/>
            <Typedef name="SAttributesEntry" value="SEntry"/>
            <Typedef name="SDictionaryEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SDictionaryEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SDictionaryEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SDictionaryEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SDictionaryEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SDictionaryEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SDictionaryEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SDictionaryEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SDictionaryEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SDictionaryEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SListEntry&lt;FXmlNode*&gt;" value="SEntry"/>
            <Typedef name="SListEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SListEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SListEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SListEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SListEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SListEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SListEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SListEntry&lt;T&gt;" value="SEntry"/>
            <Typedef name="SMapEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SMapEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SMapEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SMapEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SMapEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SMapEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SMapEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SMatrix2x2Tpl&lt;TDouble&gt;" value="SDoubleMatrix2x2"/>
            <Typedef name="SMatrix2x2Tpl&lt;TFloat&gt;" value="SFloatMatrix2x2"/>
            <Typedef name="SMatrix2x2Tpl&lt;TInt&gt;" value="SIntMatrix2x2"/>
            <Typedef name="SMatrix3x3Tpl&lt;TDouble&gt;" value="SDoubleMatrix3x3"/>
            <Typedef name="SMatrix3x3Tpl&lt;TFloat&gt;" value="SFloatMatrix3x3"/>
            <Typedef name="SMatrix3x3Tpl&lt;TInt&gt;" value="SIntMatrix3x3"/>
            <Typedef name="SMatrix4x4Tpl&lt;TDouble&gt;" value="SDoubleMatrix4x4"/>
            <Typedef name="SMatrix4x4Tpl&lt;TFloat&gt;" value="SFloatMatrix4x4"/>
            <Typedef name="SMatrix4x4Tpl&lt;TInt&gt;" value="SIntMatrix4x4"/>
            <Typedef name="SPoint2Tpl&lt;TDouble&gt;" value="SDoublePoint2"/>
            <Typedef name="SPoint2Tpl&lt;TFloat&gt;" value="SFloatPoint2"/>
            <Typedef name="SPoint2Tpl&lt;TInt&gt;" value="SIntPoint2"/>
            <Typedef name="SPoint3Tpl&lt;TDouble&gt;" value="SDoublePoint3"/>
            <Typedef name="SPoint3Tpl&lt;TFloat&gt;" value="SFloatPoint3"/>
            <Typedef name="SPoint3Tpl&lt;TInt16&gt;" value="SInt16Point3"/>
            <Typedef name="SPoint3Tpl&lt;TInt32&gt;" value="SInt32Point3"/>
            <Typedef name="SPoint3Tpl&lt;TInt&gt;" value="SIntPoint3"/>
            <Typedef name="SPoint3Tpl&lt;TUint16&gt;" value="SUint16Point3"/>
            <Typedef name="SPoint3Tpl&lt;TUint32&gt;" value="SUint32Point3"/>
            <Typedef name="SPoint4Tpl&lt;TDouble&gt;" value="SDoublePoint4"/>
            <Typedef name="SPoint4Tpl&lt;TFloat&gt;" value="SFloatPoint4"/>
            <Typedef name="SPoint4Tpl&lt;TInt&gt;" value="SIntPoint4"/>
            <Typedef name="SQuaternionTpl&lt;TDouble&gt;" value="SDoubleQuaternion"/>
            <Typedef name="SQuaternionTpl&lt;TFloat&gt;" value="SFloatQuaternion"/>
            <Typedef name="SQuaternionTpl&lt;TInt&gt;" value="SIntQuaternion"/>
            <Typedef name="SRectTpl&lt;TDouble&gt;" value="SDoubleRect"/>
            <Typedef name="SRectTpl&lt;TFloat&gt;" value="SFloatRect"/>
            <Typedef name="SRectTpl&lt;TInt&gt;" value="SIntRect"/>
            <Typedef name="SSetEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SSetEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SSetEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SSetEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SSetEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SSetEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SSetEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SSize3Tpl&lt;TDouble&gt;" value="SDoubleSize3"/>
            <Typedef name="SSize3Tpl&lt;TFloat&gt;" value="SFloatSize3"/>
            <Typedef name="SSize3Tpl&lt;TInt&gt;" value="SIntSize3"/>
            <Typedef name="SSizeTpl&lt;TDouble&gt;" value="SDoubleSize"/>
            <Typedef name="SSizeTpl&lt;TFloat&gt;" value="SFloatSize"/>
            <Typedef name="SSizeTpl&lt;TInt&gt;" value="SIntSize"/>
            <Typedef name="STreeEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="STreeEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="STreeEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="STreeEntry&lt;N, V&gt;" value="SEntry"/>
            <Typedef name="SValue&lt;TBool&gt;" value="SBool"/>
            <Typedef name="SValue&lt;TByte&gt;" value="SByte"/>
            <Typedef name="SValue&lt;TChar16&gt;" value="SChar16"/>
            <Typedef name="SValue&lt;TChar8&gt;" value="SChar8"/>
            <Typedef name="SValue&lt;TChar&gt;" value="SChar"/>
            <Typedef name="SValue&lt;TDouble&gt;" value="SDouble"/>
            <Typedef name="SValue&lt;TFloat&gt;" value="SFloat"/>
            <Typedef name="SValue&lt;TInt16&gt;" value="SInt16"/>
            <Typedef name="SValue&lt;TInt32&gt;" value="SInt32"/>
            <Typedef name="SValue&lt;TInt64&gt;" value="SInt64"/>
            <Typedef name="SValue&lt;TInt8&gt;" value="SInt8"/>
            <Typedef name="SValue&lt;TInt&gt;" value="SInt"/>
            <Typedef name="SValue&lt;TUint16&gt;" value="SUint16"/>
            <Typedef name="SValue&lt;TUint32&gt;" value="SUint32"/>
            <Typedef name="SValue&lt;TUint64&gt;" value="SUint64"/>
            <Typedef name="SValue&lt;TUint8&gt;" value="SUint8"/>
            <Typedef name="SValue&lt;TUint&gt;" value="SUint"/>
            <Typedef name="SVector2Tpl&lt;TDouble&gt;" value="SDoubleVector2"/>
            <Typedef name="SVector2Tpl&lt;TFloat&gt;" value="SFloatVector2"/>
            <Typedef name="SVector2Tpl&lt;TInt&gt;" value="SIntVector2"/>
            <Typedef name="SVector3Tpl&lt;TDouble&gt;" value="SDoubleVector3"/>
            <Typedef name="SVector3Tpl&lt;TFloat&gt;" value="SFloatVector3"/>
            <Typedef name="SVector3Tpl&lt;TInt&gt;" value="SIntVector3"/>
            <Typedef name="TAny*" value="TThreadHandle"/>
            <Typedef name="TAny*" value="PPtr"/>
            <Typedef name="TAnyC*" value="PPtrC"/>
            <Typedef name="TArray&lt;TAny*&gt;" value="TPtrs"/>
            <Typedef name="TArray&lt;TBool&gt;" value="TBools"/>
            <Typedef name="TArray&lt;TByte&gt;" value="TBytes"/>
            <Typedef name="TArray&lt;TChar16&gt;" value="TChar16s"/>
            <Typedef name="TArray&lt;TChar8&gt;" value="TChar8s"/>
            <Typedef name="TArray&lt;TChar&gt;" value="TChars"/>
            <Typedef name="TArray&lt;TDouble&gt;" value="TDoubles"/>
            <Typedef name="TArray&lt;TFloat&gt;" value="TFloats"/>
            <Typedef name="TArray&lt;TInt16&gt;" value="TInt16s"/>
            <Typedef name="TArray&lt;TInt32&gt;" value="TInt32s"/>
            <Typedef name="TArray&lt;TInt64&gt;" value="TInt64s"/>
            <Typedef name="TArray&lt;TInt8&gt;" value="TInt8s"/>
            <Typedef name="TArray&lt;TInt&gt;" value="TInts"/>
            <Typedef name="TArray&lt;TUint16&gt;" value="TUint16s"/>
            <Typedef name="TArray&lt;TUint32&gt;" value="TUint32s"/>
            <Typedef name="TArray&lt;TUint64&gt;" value="TUint64s"/>
            <Typedef name="TArray&lt;TUint8&gt;" value="TUint8s"/>
            <Typedef name="TArray&lt;TUint&gt;" value="TUints"/>
            <Typedef name="TArrayIteratorC&lt;T&gt;" value="TIteratorC"/>
            <Typedef name="TAttributesIteratorC" value="TIteratorC"/>
            <Typedef name="TAttributesIteratorC" value="TIteratorC"/>
            <Typedef name="TByte*" value="PByte"/>
            <Typedef name="TByteC*" value="PByteC"/>
            <Typedef name="TChar*" value="PChar"/>
            <Typedef name="TChar16" value="TChar"/>
            <Typedef name="TChar16*" value="PChar16"/>
            <Typedef name="TChar16C" value="TCharC"/>
            <Typedef name="TChar16C*" value="PChar16C"/>
            <Typedef name="TChar16s" value="TChars"/>
            <Typedef name="TChar8" value="TChar"/>
            <Typedef name="TChar8*" value="PChar8"/>
            <Typedef name="TChar8C" value="TCharC"/>
            <Typedef name="TChar8C*" value="PChar8C"/>
            <Typedef name="TChar8s" value="TChars"/>
            <Typedef name="TCharC*" value="PCharC"/>
            <Typedef name="TDictionary&lt;TAny*&gt;" value="TPtrDictionary"/>
            <Typedef name="TDictionaryIterator&lt;T&gt;" value="TIterator"/>
            <Typedef name="TDictionaryIterator&lt;T&gt;" value="TIterator"/>
            <Typedef name="TDictionaryIteratorC&lt;T&gt;" value="TIteratorC"/>
            <Typedef name="TDictionaryIteratorC&lt;T&gt;" value="TIteratorC"/>
            <Typedef name="TDictionaryIteratorC&lt;T&gt;" value="TIteratorC"/>
            <Typedef name="TDictionaryIteratorC&lt;T&gt;" value="TIteratorC"/>
            <Typedef name="TDouble*" value="PDouble"/>
            <Typedef name="TDoubleC*" value="PDoubleC"/>
            <Typedef name="TEntryIteratorC&lt;E&gt;" value="TIteratorC"/>
            <Typedef name="TEntryIteratorC&lt;E&gt;" value="TIteratorC"/>
            <Typedef name="TFloat*" value="PFloat"/>
            <Typedef name="TFloatC*" value="PFloatC"/>
            <Typedef name="TInt" value="TResult"/>
            <Typedef name="TInt" value="TShareKey"/>
            <Typedef name="TInt*" value="PInt"/>
            <Typedef name="TInt16*" value="PInt16"/>
            <Typedef name="TInt16C*" value="PInt16C"/>
            <Typedef name="TInt32" value="TSocket"/>
            <Typedef name="TInt32*" value="PInt32"/>
            <Typedef name="TInt32C*" value="PInt32C"/>
            <Typedef name="TInt64" value="TTimeTick"/>
            <Typedef name="TInt64" value="TTimeSpan"/>
            <Typedef name="TInt64*" value="PInt64"/>
            <Typedef name="TInt64C*" value="PInt64C"/>
            <Typedef name="TInt8*" value="PInt8"/>
            <Typedef name="TInt8C*" value="PInt8C"/>
            <Typedef name="TIntC*" value="PIntC"/>
            <Typedef name="TListIterator&lt;T&gt;" value="TIterator"/>
            <Typedef name="TListIteratorC&lt;T&gt;" value="TIteratorC"/>
            <Typedef name="TListIteratorC&lt;T&gt;" value="TIteratorC"/>
            <Typedef name="TMapIterator&lt;N, V&gt;" value="TIterator"/>
            <Typedef name="TMapIteratorC&lt;N, V&gt;" value="TIteratorC"/>
            <Typedef name="TMapIteratorC&lt;N, V&gt;" value="TIteratorC"/>
            <Typedef name="TNcDictionary&lt;TAny*&gt;" value="TPtrNcDictionary"/>
            <Typedef name="TPtr&lt;TAny&gt;" value="TAnyPtr"/>
            <Typedef name="TPtr&lt;TBool&gt;" value="TBoolPtr"/>
            <Typedef name="TPtr&lt;TByte&gt;" value="TBytePtr"/>
            <Typedef name="TPtr&lt;TChar16&gt;" value="TChar16Ptr"/>
            <Typedef name="TPtr&lt;TChar32&gt;" value="TChar32Ptr"/>
            <Typedef name="TPtr&lt;TChar8&gt;" value="TChar8Ptr"/>
            <Typedef name="TPtr&lt;TChar&gt;" value="TCharPtr"/>
            <Typedef name="TPtr&lt;TDouble&gt;" value="TDoublePtr"/>
            <Typedef name="TPtr&lt;TFloat&gt;" value="TFloatPtr"/>
            <Typedef name="TPtr&lt;TInt16&gt;" value="TInt16Ptr"/>
            <Typedef name="TPtr&lt;TInt32&gt;" value="TInt32Ptr"/>
            <Typedef name="TPtr&lt;TInt64&gt;" value="TInt64Ptr"/>
            <Typedef name="TPtr&lt;TInt8&gt;" value="TInt8Ptr"/>
            <Typedef name="TPtr&lt;TInt&gt;" value="TIntPtr"/>
            <Typedef name="TPtr&lt;TUint16&gt;" value="TUint16Ptr"/>
            <Typedef name="TPtr&lt;TUint32&gt;" value="TUint32Ptr"/>
            <Typedef name="TPtr&lt;TUint64&gt;" value="TUint64Ptr"/>
            <Typedef name="TPtr&lt;TUint8&gt;" value="TUint8Ptr"/>
            <Typedef name="TPtr&lt;TUint&gt;" value="TUintPtr"/>
            <Typedef name="TPtrC&lt;TAny&gt;" value="TAnyPtrC"/>
            <Typedef name="TPtrC&lt;TBool&gt;" value="TBoolPtrC"/>
            <Typedef name="TPtrC&lt;TByte&gt;" value="TBytePtrC"/>
            <Typedef name="TPtrC&lt;TChar16&gt;" value="TChar16PtrC"/>
            <Typedef name="TPtrC&lt;TChar8&gt;" value="TChar8PtrC"/>
            <Typedef name="TPtrC&lt;TChar&gt;" value="TCharPtrC"/>
            <Typedef name="TPtrC&lt;TDouble&gt;" value="TDoublePtrC"/>
            <Typedef name="TPtrC&lt;TFloat&gt;" value="TFloatPtrC"/>
            <Typedef name="TPtrC&lt;TInt16&gt;" value="TInt16PtrC"/>
            <Typedef name="TPtrC&lt;TInt32&gt;" value="TInt32PtrC"/>
            <Typedef name="TPtrC&lt;TInt64&gt;" value="TInt64PtrC"/>
            <Typedef name="TPtrC&lt;TInt8&gt;" value="TInt8PtrC"/>
            <Typedef name="TPtrC&lt;TInt&gt;" value="TIntPtrC"/>
            <Typedef name="TPtrC&lt;TUint16&gt;" value="TUint16PtrC"/>
            <Typedef name="TPtrC&lt;TUint32&gt;" value="TUint32PtrC"/>
            <Typedef name="TPtrC&lt;TUint64&gt;" value="TUint64PtrC"/>
            <Typedef name="TPtrC&lt;TUint8&gt;" value="TUint8PtrC"/>
            <Typedef name="TPtrC&lt;TUint&gt;" value="TUintPtrC"/>
            <Typedef name="TSetIterator&lt;N, V&gt;" value="TIterator"/>
            <Typedef name="TSetIteratorC&lt;N, V&gt;" value="TIteratorC"/>
            <Typedef name="TSetIteratorC&lt;N, V&gt;" value="TIteratorC"/>
            <Typedef name="TSharedListIteratorC" value="TIteratorC"/>
            <Typedef name="TTreeIterator&lt;N, V&gt;" value="TIterator"/>
            <Typedef name="TTreeIteratorC&lt;N, V&gt;" value="TIteratorC"/>
            <Typedef name="TUbyte*" value="PUbyte"/>
            <Typedef name="TUbyteC*" value="PUbyteC"/>
            <Typedef name="TUchar8C" value="TUcharC"/>
            <Typedef name="TUint*" value="PUint"/>
            <Typedef name="TUint16" value="TNetPort"/>
            <Typedef name="TUint16*" value="PUint16"/>
            <Typedef name="TUint16C*" value="PUint16C"/>
            <Typedef name="TUint32" value="TSize"/>
            <Typedef name="TUint32" value="TThreadId"/>
            <Typedef name="TUint32*" value="PUint32"/>
            <Typedef name="TUint32C*" value="PUint32C"/>
            <Typedef name="TUint64" value="TDateTime"/>
            <Typedef name="TUint64" value="TDate"/>
            <Typedef name="TUint64" value="TTime"/>
            <Typedef name="TUint64" value="THashCode"/>
            <Typedef name="TUint64*" value="PUint64"/>
            <Typedef name="TUint64C*" value="PUint64C"/>
            <Typedef name="TUint8*" value="PUint8"/>
            <Typedef name="TUint8C*" value="PUint8C"/>
            <Typedef name="TUintC*" value="PUintC"/>
            <Typedef name="TVector&lt;TAny*&gt;" value="TPtrVector"/>
            <Typedef name="TVector&lt;TBool&gt;" value="TBoolVector"/>
            <Typedef name="TVector&lt;TByte&gt;" value="TByteVector"/>
            <Typedef name="TVector&lt;TChar16&gt;" value="TChar16Vector"/>
            <Typedef name="TVector&lt;TChar8&gt;" value="TChar8Vector"/>
            <Typedef name="TVector&lt;TChar&gt;" value="TCharVector"/>
            <Typedef name="TVector&lt;TDouble&gt;" value="TDoubleVector"/>
            <Typedef name="TVector&lt;TFloat&gt;" value="TFloatVector"/>
            <Typedef name="TVector&lt;TInt16&gt;" value="TInt16Vector"/>
            <Typedef name="TVector&lt;TInt32&gt;" value="TInt32Vector"/>
            <Typedef name="TVector&lt;TInt64&gt;" value="TInt64Vector"/>
            <Typedef name="TVector&lt;TInt8&gt;" value="TInt8Vector"/>
            <Typedef name="TVector&lt;TInt&gt;" value="TIntVector"/>
            <Typedef name="TVector&lt;TUint16&gt;" value="TUint16Vector"/>
            <Typedef name="TVector&lt;TUint32&gt;" value="TUint32Vector"/>
            <Typedef name="TVector&lt;TUint64&gt;" value="TUint64Vector"/>
            <Typedef name="TVector&lt;TUint8&gt;" value="TUint8Vector"/>
            <Typedef name="TVector&lt;TUint&gt;" value="TUintVector"/>
            <Typedef name="TVectorIteratorC&lt;FString8*&gt;" value="TString8sIteratorC"/>
            <Typedef name="TVectorIteratorC&lt;T&gt;" value="TIteratorC"/>
            <Typedef name="__int64" value="TInt64C"/>
            <Typedef name="__int64" value="TInt64"/>
            <Typedef name="__int64" value="TUint64C"/>
            <Typedef name="__int64" value="TUint64"/>
            <Typedef name="char" value="TByte"/>
            <Typedef name="char" value="TChar8"/>
            <Typedef name="char" value="TUbyteC"/>
            <Typedef name="char" value="TUbyte"/>
            <Typedef name="char" value="TUchar8"/>
            <Typedef name="char" value="TInt8"/>
            <Typedef name="char" value="TByteC"/>
            <Typedef name="char" value="TUchar8C"/>
            <Typedef name="char" value="TUint8"/>
            <Typedef name="char" value="TChar8C"/>
            <Typedef name="char" value="TUint8C"/>
            <Typedef name="double" value="TDouble"/>
            <Typedef name="double" value="TDoubleC"/>
            <Typedef name="float" value="TFloatC"/>
            <Typedef name="float" value="TFloat"/>
            <Typedef name="int" value="TIntC"/>
            <Typedef name="int" value="TUint32C"/>
            <Typedef name="int" value="TUint32C"/>
            <Typedef name="int" value="TUint32"/>
            <Typedef name="int" value="TUint32"/>
            <Typedef name="int" value="TBool"/>
            <Typedef name="int" value="TUintC"/>
            <Typedef name="int" value="TUintC"/>
            <Typedef name="int" value="TInt32C"/>
            <Typedef name="int" value="TUint"/>
            <Typedef name="int" value="TInt32"/>
            <Typedef name="int" value="TInt"/>
            <Typedef name="int" value="TUint"/>
            <Typedef name="int" value="TInt32C"/>
            <Typedef name="int" value="TIntC"/>
            <Typedef name="int" value="TIntC"/>
            <Typedef name="int" value="TBool"/>
            <Typedef name="int" value="TInt8C"/>
            <Typedef name="int" value="TInt"/>
            <Typedef name="int" value="TInt32"/>
            <Typedef name="int" value="TBool"/>
            <Typedef name="int" value="TUint"/>
            <Typedef name="int" value="TInt"/>
            <Typedef name="int" value="TUintC"/>
            <Typedef name="long" value="TInt64"/>
            <Typedef name="long" value="TUint64C"/>
            <Typedef name="long" value="TInt64C"/>
            <Typedef name="long" value="TUint32C"/>
            <Typedef name="long" value="TUint32"/>
            <Typedef name="long" value="TInt32C"/>
            <Typedef name="long" value="TUint64C"/>
            <Typedef name="long" value="TInt64"/>
            <Typedef name="long" value="TInt32"/>
            <Typedef name="long" value="TUint64"/>
            <Typedef name="long" value="TUint64"/>
            <Typedef name="long" value="TInt64C"/>
            <Typedef name="pthread_t" value="TThreadHandle"/>
            <Typedef name="pthread_t" value="TThreadId"/>
            <Typedef name="short" value="TUint16"/>
            <Typedef name="short" value="TUint16C"/>
            <Typedef name="short" value="TInt16C"/>
            <Typedef name="short" value="TInt16"/>
            <Typedef name="void" value="TAnyC"/>
            <Typedef name="void" value="TAny"/>
            <Typedef name="wchar_t" value="TChar16C"/>
            <Typedef name="wchar_t" value="TChar16"/>
            <Typedef name="wchar_t" value="TChar32"/>
            <Typedef name="wchar_t" value="TChar32C"/>
         </Typedefs>
         <Variables/>
         <Methods>
            <Method name="AdjustHeadTail" type="static" description="调整双向链表的头尾指针。">
               <Parameters>
                  <Parameter type="E" name="*&amp;h"/>
                  <Parameter type="E" name="*&amp;t"/>
                  <Parameter type="E" name="*p1"/>
                  <Parameter type="E" name="*p2"/>
               </Parameters>
               <Return type="void"/>
               <Source>\nstatic void AdjustHeadTail(E *&amp;h, E *&amp;t, E *p1, E *p2) {\n       if(p1 == h)\n          h = p2;\n       else if(p2 == h)\n          h = p1;\n\n       if(p1 == t)\n          t = p2;\n       else if(p2 == t)\n          t = p1;\n   }</Source>
            </Method>
            <Method name="MO_CAST_FORCE">
               <Parameters>
                  <Parameter type="S" name="V"/>
               </Parameters>
               <Return type="T"/>
               <Source>//============================================================\n// 强制转换：对象指针强制转换的模板函数\n//============================================================\n\nT MO_CAST_FORCE(S V) {\n   union{\n      T Target;\n      S Source;\n   } Convert;\n   Convert.Source = V;\n   return Convert.Target;\n}</Source>
            </Method>
            <Method name="MoInitialize" description="构造运行库。">
               <Parameters>
                  <Parameter type="TChar**" name="ppParameters"/>
                  <Parameter type="TInt" name="count"/>
               </Parameters>
               <Return type="void" description="运行库"/>
               <Source>//============================================================\n// &lt;T&gt;构造运行库。&lt;/T&gt;\n//\n// @return 运行库\n//============================================================\n\nvoid MoInitialize(TChar** ppParameters, TInt count){\n#ifdef _WINDOWS\n   CoInitialize(NULL);\n#endif\n   // 初始化唯一对象管理器\n   RSingletonManager::Create();\n   // 初始化程序\n   RApplication::Create();\n   RApplication::CatchSegmentFault();\n   RApplication::CatchInterrupt();\n   //RApplication::CatchUsr1();\n   RApplication::Instance().LinkArguments(ppParameters, count);\n   // 初始化日志管理器\n   RLoggerManager::Create();\n   // 初始化线程管理器\n   RThreadManager::Create();\n   // 初始化收集器\n   RAllocator::Create();\n   // 初始化共享对象管理器\n   RSharedManager::Create();\n   // 打开日志\n   RLogger::Link(RLoggerManager::InstancePtr());\n   MO_STATIC_DEBUG(&quot;Common framework initialize.&quot;);\n}</Source>
            </Method>
            <Method name="MoInitialize" description="初始化运行库。">
               <Return type="void"/>
               <Source>//============================================================\n// &lt;T&gt;初始化运行库。&lt;/T&gt;\n//============================================================\n\nvoid MoInitialize(){\n   MoInitialize(NULL, 0);\n}</Source>
            </Method>
            <Method name="MoRelease" description="释放运行库。">
               <Return type="void"/>
               <Source>//============================================================\n// &lt;T&gt;释放运行库。&lt;/T&gt;\n//============================================================\n\nvoid MoRelease(){\n   // 关闭日志\n   MO_STATIC_DEBUG(&quot;Common framework release.&quot;);\n   RLogger::Link(NULL);\n   // 释放共享对象管理器\n   RSharedManager::Destroy();\n   // 释放收集器\n   RAllocator::Destroy();\n   // 释放线程管理器\n   RThreadManager::Destroy();\n   // 释放日志管理器\n   RLoggerManager::Destroy();\n   // 释放程序\n   RApplication::Destroy();\n   // 释放唯一对象管理器\n   RSingletonManager::Destroy();\n#ifdef _WINDOWS\n   CoUninitialize();\n#endif\n}</Source>
            </Method>
            <Method name="SLItemSwap" type="static" description="Set排序中指针交换。">
               <Parameters>
                  <Parameter type="E" name="*&amp;h"/>
                  <Parameter type="E" name="*&amp;t"/>
                  <Parameter type="E" name="*p1"/>
                  <Parameter type="E" name="*p2"/>
               </Parameters>
               <Return type="void"/>
               <Source>\nstatic void SLItemSwap(E *&amp;h, E *&amp;t, E *p1, E *p2) {\n      E *tmp;\n      if(p1 &amp;&amp; p2 &amp;&amp; p1 != p2) {\n         if(p1-&gt;pNext != p2 &amp;&amp; p1-&gt;pPrior != p2) {\n            AdjustHeadTail(h, t, p1, p2);\n\n            MO_SORT_SWAP(tmp, p1-&gt;pNext, p2-&gt;pNext);\n            if(p1-&gt;pNext)\n               p1-&gt;pNext-&gt;pPrior = p1;\n            if(p2-&gt;pNext)\n               p2-&gt;pNext-&gt;pPrior = p2;\n\n            MO_SORT_SWAP(tmp, p1-&gt;pPrior, p2-&gt;pPrior);\n            if(p1-&gt;pPrior)\n               p1-&gt;pPrior-&gt;pNext = p1;\n            if(p2-&gt;pPrior)\n               p2-&gt;pPrior-&gt;pNext = p2;\n\n         } else if(p1-&gt;pNext == p2) {\n            AdjustHeadTail(h, t, p1, p2);\n            p1-&gt;pNext = p2-&gt;pNext;\n            if(p1-&gt;pNext)\n               p1-&gt;pNext-&gt;pPrior = p1;\n            p2-&gt;pPrior = p1-&gt;pPrior;\n            if(p2-&gt;pPrior)\n               p2-&gt;pPrior-&gt;pNext = p2;\n            p1-&gt;pPrior = p2;\n            p2-&gt;pNext = p1;\n\n         } else {\n            MO_SORT_SWAP(tmp, p1, p2);\n            SLItemSwap(h, t, p1, p2);\n         }\n      }\n   }</Source>
            </Method>
            <Method name="SetQuickSort" type="static" description="用于元素比较多的双向链表的快速排序。">
               <Parameters>
                  <Parameter type="E" name="*&amp;pHead"/>
                  <Parameter type="E" name="*&amp;pTail"/>
                  <Parameter type="*&amp;pTail,IComparer&lt;T&gt;*" name="pComparer"/>
               </Parameters>
               <Return type="void"/>
               <Source>\nstatic void SetQuickSort(E *&amp;pHead, E *&amp;pTail,IComparer&lt;T&gt;* pComparer){\n      if(pHead != pTail) {\n         //T tmp;\n         T data = pHead-&gt;code;\n         E *last = pHead;\n         E *tmp;\n\n         for(E *p = pHead-&gt;pNext; p != pTail-&gt;pNext; p = p-&gt;pNext) {\n            if(pComparer-&gt;Compare(p-&gt;code, data) &lt; 0) {\n               last = last-&gt;pNext;\n               SLItemSwap(pHead, pTail, last, p);\n               MO_SORT_SWAP(tmp, last, p);\n            }\n         }\n\n         tmp = pHead;\n         SLItemSwap(pHead, pTail, tmp, last);\n         last = tmp;\n\n         if(last != pHead){\n            last = last-&gt;pPrior;\n            SetQuickSort(pHead, last, pComparer);\n         }\n         if(tmp != pTail){\n            tmp = tmp-&gt;pNext;\n            SetQuickSort(tmp, pTail, pComparer);\n         }\n      }\n   }</Source>
            </Method>
            <Method name="SyncElementFromNode" description="同步配置节点到元素节点内。">
               <Parameters>
                  <Parameter type="FXmlDocument*" name="pDocument"/>
                  <Parameter type="MSXML2::IXMLDOMDocument3Ptr" name="piDocument" description="文档对象"/>
                  <Parameter type="MSXML2::IXMLDOMNodePtr" name="piNode" description="元素节点"/>
                  <Parameter type="FXmlNode*" name="pNode" description="配置节点"/>
                  <Parameter type="TInt" name="level" description="节点层次"/>
               </Parameters>
               <Return type="void"/>
               <Source>//============================================================\n// &lt;T&gt;同步配置节点到元素节点内。&lt;/T&gt;\n//\n// @param piDocument 文档对象\n// @param piNode 元素节点\n// @param pNode 配置节点\n// @param level 节点层次\n//============================================================\n\nvoid SyncElementFromNode(FXmlDocument* pDocument, MSXML2::IXMLDOMDocument3Ptr piDocument, MSXML2::IXMLDOMNodePtr piNode, FXmlNode* pNode, TInt level){\n   // 设置文本内容\n   if(!pNode-&gt;HasNode()){\n      if(!pNode-&gt;HasText()){\n         piNode-&gt;put_text(_bstr_t(pNode-&gt;Text()));\n      }\n   }\n   // 判断是否存在属性\n   if(pNode-&gt;HasAttribute()){\n      FAttributes* pAttributes = pNode-&gt;Attributes();\n      TAttributesIteratorC iterator = pAttributes-&gt;IteratorC();\n      while(iterator.Next()){\n         MSXML2::IXMLDOMAttributePtr piAttribute = piDocument-&gt;createAttribute(_bstr_t(iterator.Name()));\n         piAttribute-&gt;put_value(_variant_t(iterator.Value()));\n         piNode-&gt;attributes-&gt;setNamedItem(piAttribute);\n      }\n   }\n   // 判断是否存在子节点\n   if(pNode-&gt;HasNode()){\n      FXmlNodes* pNodes = pNode-&gt;Nodes();\n      TInt count = pNodes-&gt;Count();\n      // 获取所有子节点\n      for(TInt n=0; n&lt;count; n++){\n         FXmlNode* pChild = pNodes-&gt;Get(n);\n         switch(pChild-&gt;NodeType()){\n            case EXmlNodeType_Element:{\n                  // 新建换行符\n                  //TString space(&quot;\n&quot;);\n                  //space.AppendRepeat(_indent, level);\n                  //piNode-&gt;appendChild(piDocument-&gt;createTextNode(space.MemoryC()));\n                  // 新建节点内容\n                  MSXML2::IXMLDOMElementPtr piChild = piDocument-&gt;createElement(_bstr_t(pChild-&gt;Name()));\n                  SyncElementFromNode(pDocument, piDocument, piChild, pChild, level+1);\n                  piNode-&gt;appendChild(piChild);\n               }\n               break;\n            case EXmlNodeType_Text:{\n               }\n               break;\n            case EXmlNodeType_Data:{\n               }\n               break;\n            case EXmlNodeType_Comment:{\n                  //piChild = piDocument-&gt;createNode(NODE_COMMENT, _bstr_t(pChild-&gt;Name().MemoryC()), _bstr_t());\n                  //SyncElementFromNode(piDocument, piChild, pChild);\n                  //piNode-&gt;appendChild(piChild);\n               }\n               break;\n         }\n      }\n      // 新建换行符\n      //TString afterSpace(&quot;\n&quot;);\n      //afterSpace.AppendRepeat(_indent, level-1);\n      //piNode-&gt;appendChild(piDocument-&gt;createTextNode(afterSpace.MemoryC()));\n   }\n}</Source>
            </Method>
            <Method name="SyncElementFromNode">
               <Parameters>
                  <Parameter type="FXmlDocument*" name="pDocument"/>
                  <Parameter type="FXmlNode*" name="pNode"/>
                  <Parameter type="xmlDocPtr" name="xdocPtr"/>
                  <Parameter type="xmlNodePtr" name="xnodePtr"/>
               </Parameters>
               <Return type="void"/>
               <Source>\nvoid SyncElementFromNode(FXmlDocument* pDocument, FXmlNode* pNode, xmlDocPtr xdocPtr, xmlNodePtr xnodePtr){\n   // 设置文本内容\n   if(!pNode-&gt;HasNode()){\n      if(pNode-&gt;HasText()){\n         xmlNodeSetContent(xnodePtr, BAD_CAST(pNode-&gt;Text()));\n      }\n   }\n   // 判断是否存在属性\n   if(pNode-&gt;HasAttribute()){\n      // 获取所有属性\n      TAttributesIteratorC iterator = pNode-&gt;Attributes()-&gt;IteratorC();\n      while(iterator.Next()){\n         xmlNewProp(xnodePtr, BAD_CAST(iterator.Name()), BAD_CAST(iterator.Value()));\n      }\n   }\n   // 判断是否存在子节点\n   if(pNode-&gt;HasNode()){\n      FXmlNodes* pNodes = pNode-&gt;Nodes();\n      TInt count = pNodes-&gt;Count();\n      // 获取所有子节点\n      for(TInt n=0; n&lt;count; n++){\n         FXmlNode* pChild = pNodes-&gt;Get(n);\n         switch(pChild-&gt;NodeType()){\n            case EXmlNodeType_Element:{\n               // 新建节点内容\n               xmlNodePtr xchildPtr = xmlNewChild(xnodePtr, NULL, BAD_CAST(pChild-&gt;Name()), BAD_CAST(pChild-&gt;Text()));\n               // 递归处理\n               SyncElementFromNode(pDocument, pChild, xdocPtr, xchildPtr);\n               break;\n               }\n            case EXmlNodeType_Text:{\n               break;\n               }\n            case EXmlNodeType_Data:{\n               break;\n               }\n            case EXmlNodeType_Comment:{\n               xmlNodePtr xchildPtr = xmlNewComment(BAD_CAST(pChild-&gt;Text()));\n               xmlAddChild(xnodePtr, xchildPtr);\n               break;\n               }\n         }\n      }\n   }\n}</Source>
            </Method>
            <Method name="SyncNodeFromElement" description="同步元素节点到配置节点内。">
               <Parameters>
                  <Parameter type="FXmlDocument*" name="pDocument"/>
                  <Parameter type="MSXML2::IXMLDOMDocument3Ptr" name="piDocument" description="文档对象"/>
                  <Parameter type="FXmlNode*" name="pNode" description="配置节点"/>
                  <Parameter type="MSXML2::IXMLDOMNodePtr" name="piNode" description="元素节点"/>
               </Parameters>
               <Return type="void"/>
               <Source>//============================================================\n// &lt;T&gt;同步元素节点到配置节点内。&lt;/T&gt;\n//\n// @param piDocument 文档对象\n// @param pNode 配置节点\n// @param piNode 元素节点\n//============================================================\n\nvoid SyncNodeFromElement(FXmlDocument* pDocument, MSXML2::IXMLDOMDocument3Ptr piDocument, FXmlNode* pNode, MSXML2::IXMLDOMNodePtr piNode){\n   pNode-&gt;SetName(MO_CRT_BSTR_TO_STRING(piNode-&gt;nodeName));\n   // 判断是否存在属性\n   MSXML2::IXMLDOMNamedNodeMapPtr piAttributes = piNode-&gt;Getattributes();\n   TInt attrLength = piAttributes-&gt;Getlength();\n   if(attrLength &gt; 0){\n      // 获取所有属性\n      FAttributes* pAttributes = pNode-&gt;Attributes();\n      for(TInt n=0; n&lt;attrLength; n++){\n         MSXML2::IXMLDOMNodePtr attrNode = piAttributes-&gt;Getitem(n);\n         TCharC* pAttrName = MO_CRT_BSTR_TO_STRING(attrNode-&gt;nodeName);\n         TCharC* pAttrValue = MO_CRT_BSTR_TO_STRING(attrNode-&gt;nodeValue.bstrVal);\n         pAttributes-&gt;Set(pAttrName, pAttrValue);\n      }\n   }\n   // 判断是否存在子节点\n   MSXML2::IXMLDOMNodeListPtr piChildren = piNode-&gt;GetchildNodes();\n   TInt nodeLength = piChildren-&gt;Getlength();\n   if(nodeLength &gt; 0){\n      // 获取所有属性\n      FXmlNodes* pChildren = pNode-&gt;Nodes();\n      for(TInt n=0; n&lt;nodeLength; n++){\n         // 获得当前子节点\n         MSXML2::IXMLDOMNodePtr piChild = piChildren-&gt;Getitem(n);\n         switch(piChild-&gt;GetnodeType()){\n            case NODE_ELEMENT:{\n                  FXmlNode* pChild = pDocument-&gt;CreateNode(EXmlNodeType_Element);\n                  SyncNodeFromElement(pDocument, piDocument, pChild, piChild);\n                  pChildren-&gt;Push(pChild);\n               }\n               break;\n            case NODE_TEXT:{\n                  pNode-&gt;TextAppend(MO_CRT_BSTR_TO_STRING(piChild-&gt;nodeValue.bstrVal));\n               }\n               break;\n            case NODE_CDATA_SECTION:{\n                  pNode-&gt;SetText(MO_CRT_BSTR_TO_STRING(piChild-&gt;nodeValue.bstrVal));\n               }\n               break;\n            case NODE_COMMENT:{\n                  FXmlNode* pChild = pDocument-&gt;CreateNode(EXmlNodeType_Comment);\n                  pChild-&gt;SetText(MO_CRT_BSTR_TO_STRING(piChild-&gt;nodeValue.bstrVal));\n                  pChildren-&gt;Push(pChild);\n               }\n               break;\n         }\n      }\n   }\n}</Source>
            </Method>
            <Method name="SyncNodeFromElement">
               <Parameters>
                  <Parameter type="FXmlDocument*" name="pDocument"/>
                  <Parameter type="FXmlNode*" name="pNode"/>
                  <Parameter type="xmlDocPtr" name="xdocPtr"/>
                  <Parameter type="xmlNodePtr" name="xnodePtr"/>
               </Parameters>
               <Return type="void"/>
               <Source>\nvoid SyncNodeFromElement(FXmlDocument* pDocument, FXmlNode* pNode, xmlDocPtr xdocPtr, xmlNodePtr xnodePtr){\n   pNode-&gt;SetName(TStringPtr(xnodePtr-&gt;name));\n   // 判断是否存在属性\n   xmlAttrPtr xattrsPtr = xnodePtr-&gt;properties;\n   if(NULL != xattrsPtr){\n      // 获取所有属性\n      FAttributes* pAttributes = pNode-&gt;Attributes();\n      while(NULL != xattrsPtr){\n         pAttributes-&gt;Set(TStringPtr(xattrsPtr-&gt;name), TStringPtr(xmlGetProp(xnodePtr, xattrsPtr-&gt;name)));\n         xattrsPtr = xattrsPtr-&gt;next;\n      }\n   }\n   // 判断是否存在子节点\n   xmlNodePtr xchildPtr = xnodePtr-&gt;children;\n   if(NULL != xchildPtr){\n      // 获取所有属性\n      FXmlNodes* pChildren = pNode-&gt;Nodes();\n      while(NULL != xchildPtr){\n         // 获得当前子节点\n         switch(xchildPtr-&gt;type){\n            case XML_ELEMENT_NODE:{\n                  FXmlNode* pChild = pDocument-&gt;CreateNode(EXmlNodeType_Element);\n                  SyncNodeFromElement(pDocument, pChild, xdocPtr, xchildPtr);\n                  pChildren-&gt;Push(pChild);\n               }\n               break;\n            case XML_TEXT_NODE:{\n                  pNode-&gt;TextAppend((TCharC*)xmlNodeGetContent(xchildPtr));\n               }\n               break;\n            case XML_CDATA_SECTION_NODE:{\n                  pNode-&gt;SetText(TStringPtr(xmlNodeGetContent(xchildPtr)));\n               }\n               break;\n            case XML_COMMENT_NODE:{\n                  FXmlNode* pChild = pDocument-&gt;CreateNode(EXmlNodeType_Comment);\n                  pChild-&gt;SetText(TStringPtr(xmlNodeGetContent(xchildPtr)));\n                  pChildren-&gt;Push(pChild);\n               }\n               break;\n         }\n         xchildPtr = xchildPtr-&gt;next;\n      }\n   }\n}</Source>
            </Method>
            <Method name="__MO_THREAD_CALLBACK" description="执行线程处理(WINDOW)。">
               <Parameters>
                  <Parameter type="TAny*" name="pParam" description="参数指针"/>
               </Parameters>
               <Return type="MO_STDCALL" description="处理结果"/>
               <Source>//============================================================\n// &lt;T&gt;执行线程处理(WINDOW)。&lt;/T&gt;\n//\n// @param pParam 参数指针\n// @return 处理结果\n//============================================================\n\nTUint32 MO_STDCALL __MO_THREAD_CALLBACK(TAny* pParam){\n   // 获得线程对象\n   FThread* pThread = (FThread*)pParam;\n   MO_ASSERT(pThread);\n   // 执行线程处理\n   TInt result = EFailure;\n   if(pThread-&gt;OnStart()){\n      try{\n         MO_TRAP( result = pThread-&gt;Process() );\n      }catch(TInt code){\n         pThread-&gt;OnCancel(code);\n      }\n      pThread-&gt;OnFinish(result);\n   }\n   // 释放线程资源\n   MO_PTR_DELETE(pThread);\n   return result;\n}</Source>
            </Method>
            <Method name="__MO_THREAD_CALLBACK" description="执行线程处理(LINUX)。">
               <Parameters>
                  <Parameter type="TAny*" name="pParam" description="参数指针"/>
               </Parameters>
               <Return type="MO_STDCALL" description="处理结果"/>
               <Source>//============================================================\n// &lt;T&gt;执行线程处理(LINUX)。&lt;/T&gt;\n//\n// @param pParam 参数指针\n// @return 处理结果\n//============================================================\n\nTAny* MO_STDCALL __MO_THREAD_CALLBACK(TAny* pParam){\n   // 获得线程对象\n   FThread* pThread = (FThread*)pParam;\n   MO_ASSERT(pThread);\n   // 将自己放入线程管理器里\n   RThreadManager::Instance().Register(pThread);\n   // 执行线程处理\n   TInt result = EFailure;\n   if(pThread-&gt;OnStart()){\n      try{\n         MO_TRAP( result = pThread-&gt;Process() );\n      }catch(TInt code){\n         pThread-&gt;OnCancel(code);\n      }\n      pThread-&gt;OnFinish(result);\n   }\n   // 释放线程资源\n   pthread_exit((TAny*)result);\n   MO_PTR_DELETE(pThread);\n   return (TAny*)result;\n}</Source>
            </Method>
         </Methods>
         <Classes>
            <Class name="*FFileLines">
               <Methods>
                  <Method name="Line" description="得到指定行。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="FString"/>
                     <Source>//============================================================\n// &lt;T&gt;得到指定行。&lt;/T&gt;\n//============================================================\n\nFString *FFileLines::Line(TInt index){\n   MO_ASSERT_RANGE(index, 0, _pLines-&gt;Count());\n   return _pLines-&gt;Get(index);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FAllocatorStack">
               <Methods>
                  <Constructor name="FAllocatorStack"/>
                  <Destructor name="~FAllocatorStack"/>
                  <Method name="Alloc">
                     <Return type="T*"/>
                     <Source>\nT* Alloc(){\n      T* pValue = NULL;\n      if(NULL != _pUnused){\n         pValue = _pUnused;\n         _pUnused = _pUnused-&gt;pNext;\n         pValue-&gt;pNext = NULL;\n      }\n      return pValue;\n   }</Source>
                  </Method>
                  <Method name="Free">
                     <Parameters>
                        <Parameter type="T*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Free(T* pValue){\n      MO_ASSERT(pValue);\n      pValue-&gt;pNext = _pUnused;\n      _pUnused = pValue;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="FApplication">
               <Inherits>
                  <Inherit name="MSingleton" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FApplication"/>
                  <Destructor name="~FApplication"/>
                  <Method name="OnSegmentFault" type="static">
                     <Parameters>
                        <Parameter type="int" name="signum"/>
                        <Parameter type="siginfo_t*" name="info"/>
                        <Parameter type="TAny*" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FApplication::OnSegmentFault(int signum, siginfo_t* info, TAny* ptr){\n   // 获得参数\n   static const char* si_codes[3] = {&quot;&quot;, &quot;SEGV_MAPERR&quot;, &quot;SEGV_ACCERR&quot;};\n   ucontext_t* pUcontext = (ucontext_t*)ptr;\n   // 基础信息\n   fprintf(stderr, &quot;Segmentation Fault!\n&quot;);\n   fprintf(stderr, &quot;   info.si_signo = %d\n&quot;, signum);\n   fprintf(stderr, &quot;   info.si_errno = %d\n&quot;, info-&gt;si_errno);\n   fprintf(stderr, &quot;   info.si_code  = %d (%s)\n&quot;, info-&gt;si_code, si_codes[info-&gt;si_code]);\n   fprintf(stderr, &quot;   info.si_addr  = %p\n&quot;, info-&gt;si_addr);\n   // 寄存器信息\n   for(TInt i = 0; i &lt; NGREG; i++){\n   fprintf(stderr, &quot;reg[%02&quot; MO_FMT_INT &quot;] = 0x%&quot; MO_FMT_HEX &quot;\n&quot;, i, pUcontext-&gt;uc_mcontext.gregs[i]);\n   }\n#if defined(SIGSEGV_STACK_X86) || defined(SIGSEGV_STACK_IA64)\n   TAny** ppBp = NULL;\n   TAny* pIp = NULL;\n# if defined(SIGSEGV_STACK_IA64)\n   pIp = (TAny*)pUcontext-&gt;uc_mcontext.gregs[REG_RIP];\n   ppBp = (TAny**)pUcontext-&gt;uc_mcontext.gregs[REG_RBP];\n# elif defined(SIGSEGV_STACK_X86)\n   pIp = (TAny*)pUcontext-&gt;uc_mcontext.gregs[REG_EIP];\n   ppBp = (TAny**)pUcontext-&gt;uc_mcontext.gregs[REG_EBP];\n# endif\n   // 堆栈信息\n   fprintf(stderr, &quot;Stack trace:\n&quot;);\n   TInt32 level = 0;\n   Dl_info dlinfo;\n   while(ppBp &amp;&amp; pIp) {\n      if(!dladdr(pIp, &amp;dlinfo)){\n         break;\n      }\n      TCharC *pSymName = dlinfo.dli_sname;\n#ifndef NO_CPP_DEMANGLE\n      TInt32 status;\n      TChar* pTemp = abi::__cxa_demangle(pSymName, NULL, 0, &amp;status);\n      if(status == 0 &amp;&amp; pTemp){\n         pSymName = pTemp;\n      }\n#endif\n      fprintf(stderr, &quot;-&gt; %02d: %p [%-48s+%04u] (%s)\n&quot;,\n            ++level, pIp, pSymName, (unsigned)((char*)pIp - (char*)dlinfo.dli_saddr), dlinfo.dli_fname);\n#ifndef NO_CPP_DEMANGLE\n      if(NULL != pTemp){\n         free(pTemp);\n      }\n#endif\n      if(dlinfo.dli_sname &amp;&amp; !strcmp(dlinfo.dli_sname, &quot;main&quot;)){\n         break;\n      }\n      pIp = ppBp[1];\n      ppBp = (TAny**)ppBp[0];\n   }\n#else\n   fprintf(stderr, &quot;Stack trace (non-dedicated):\n&quot;);\n   void* buffer[MO_BACKTRACE_MAXCOUNT];\n   TInt count = backtrace(buffer, MO_BACKTRACE_MAXCOUNT);\n   char** ppStrings = backtrace_symbols(buffer, count);\n   for(TInt n=0; n&lt;count; n++){\n      fprintf(stderr, &quot;-&gt; %s\n&quot;, ppStrings[n]);\n   }\n#endif\n   fprintf(stderr, &quot;End of stack trace\n&quot;);\n#if _DEBUG\n   // 产生崩溃，生成core文件用\n   FObject* pObject = NULL; pObject-&gt;HashCode();\n#endif\n   exit(-1);\n}</Source>
                  </Method>
                  <Method name="OnSignalInterrupt" type="static" description="处理中断信号。">
                     <Parameters>
                        <Parameter type="int" name="signalNo"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;处理中断信号。&lt;/T&gt;\n//\n// @param signo 中断号\n//============================================================\n\nvoid FApplication::OnSignalInterrupt(int signalNo){\n   if(NULL != _pInterrruptListeners){\n      _pInterrruptListeners-&gt;Process();\n   }\n   exit(ESuccess);\n}</Source>
                  </Method>
                  <Method name="LinkArguments">
                     <Parameters>
                        <Parameter type="TChar**" name="ppArguments"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FApplication::LinkArguments(TChar** ppArguments, TInt count){\n   _ppArguments = ppArguments;\n   _argumentCount = count;\n}</Source>
                  </Method>
                  <Method name="GetArgument">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* FApplication::GetArgument(TInt index){\n   MO_ASSERT_RANGE(index, 0, _argumentCount);\n   return _ppArguments[index];\n}</Source>
                  </Method>
                  <Method name="FindArgument">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* FApplication::FindArgument(TCharC* pName){\n   TInt count = _argumentCount - 1;\n   for(TInt n=0; n&lt;count; n++){\n      TCharC* pArgument = _ppArguments[n];\n      if(0 == strcmp(pArgument, pName)){\n         return _ppArguments[n + 1];\n      }\n   }\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="Hinstance" description="获得当前应用程序的句柄。">
                     <Return type="TInstance"/>
                     <Source>//============================================================\n// &lt;T&gt;获得当前应用程序的句柄。&lt;/T&gt;\n//\n// @history 100424 MAOCY 创建\n//============================================================\n\nTInstance FApplication::Hinstance(){\n   return _hInstance;\n}</Source>
                  </Method>
                  <Method name="SetHinstance">
                     <Parameters>
                        <Parameter type="HINSTANCE" name="hinstance"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FApplication::SetHinstance(HINSTANCE instance){\n   _hInstance = instance;\n}</Source>
                  </Method>
                  <Method name="CommandShow">
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FApplication::CommandShow(){\n   return _commandShow;\n}</Source>
                  </Method>
                  <Method name="SetCommandShow">
                     <Parameters>
                        <Parameter type="TInt" name="commandShow"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FApplication::SetCommandShow(TInt commandShow){\n   _commandShow = commandShow;\n}</Source>
                  </Method>
                  <Method name="InterruptListeners">
                     <Return type="FListeners*"/>
                     <Source>//============================================================\n\nFListeners* FApplication::InterruptListeners(){\n   if(NULL == _pInterrruptListeners){\n      _pInterrruptListeners = MO_PTR_CREATE(FListeners);\n   }\n   return _pInterrruptListeners;\n}</Source>
                  </Method>
                  <Method name="CatchSegmentFault" description="拦截无效内存错误。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;拦截无效内存错误。&lt;/T&gt;\n//\n// @history 100412 MAOCY 创建\n//============================================================\n\nTInt FApplication::CatchSegmentFault(){\n#ifdef _LINUX\n   struct sigaction action;\n   memset(&amp;action, 0, sizeof(action));\n   action.sa_flags = SA_SIGINFO;\n   action.sa_sigaction = OnSegmentFault;\n   if(sigaction(SIGSEGV, &amp;action, NULL) &lt; 0){\n      perror(&quot;sigaction&quot;);\n      return EError;\n   }\n   if(sigaction(SIGABRT, &amp;action, NULL) &lt; 0){\n      perror(&quot;sigaction&quot;);\n      return EError;\n   }\n   if(sigaction(SIGTRAP, &amp;action, NULL) &lt; 0){\n      perror(&quot;sigaction&quot;);\n      return EError;\n   }\n   if(sigaction(SIGFPE, &amp;action, NULL) &lt; 0){\n      perror(&quot;sigaction&quot;);\n      return EError;\n   }\n   if(sigaction(SIGSTKFLT, &amp;action, NULL) &lt; 0){\n      perror(&quot;sigaction&quot;);\n      return EError;\n   }\n#endif\n   return ESuccess;\n}</Source>
                  </Method>
                  <Method name="CatchInterrupt" description="捕获中断信号。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;捕获中断信号。&lt;/T&gt;\n//\n//============================================================\n\nTInt FApplication::CatchInterrupt(){\n#ifdef _LINUX\n   sigset_t sig_int;\n   sigemptyset(&amp;sig_int);\n   sigaddset(&amp;sig_int, SIGINT);\n   if(SIG_ERR == signal(SIGINT, OnSignalInterrupt)){\n      MO_STATIC_ERROR(&quot;Set SIG_INT handler error.&quot;);\n      return EError;\n   }\n   if(sigprocmask(SIG_UNBLOCK, &amp;sig_int, NULL)){\n      MO_STATIC_ERROR(&quot;Set SIG_INT unblock error.&quot;);\n      return EError;\n   }\n#endif\n   return ESuccess;\n}</Source>
                  </Method>
                  <Method name="CatchUsr1">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="InstallDaemon" description="获得可执行文件的当前路径。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;获得可执行文件的当前路径。&lt;/T&gt;\n//\n// @history 100302 MAOCY 创建\n//============================================================\n\nvoid FApplication::InstallDaemon(){\n#ifdef _LINUX\n   TFsPath path = RApplication::GetCurrentDirectory();\n   // 更改指定文件的时间属性为当前时间\n   system(&quot;touch application&quot;);\n   // 打开文件\n   TInt handle = open(&quot;./application.lock&quot;, O_RDWR | O_CREAT, 0640);\n   if(handle &lt; 0){\n      MO_STATIC_PFATAL(open);\n   }\n   // 锁定文件\n   TInt result = flock(handle, LOCK_EX | LOCK_NB);\n   if(result &lt; 0){\n      MO_STATIC_PFATAL(flock);\n   }\n   // 克隆进程\n   pid_t pid = fork();\n   if(ESuccess != pid){\n      exit(ESuccess);\n   }\n   // 设置信号\n   setsid();\n   signal(SIGINT, SIG_IGN);\n   signal(SIGHUP, SIG_IGN);\n   signal(SIGQUIT, SIG_IGN);\n   signal(SIGTTOU, SIG_IGN);\n   signal(SIGTTIN, SIG_IGN);\n   signal(SIGCHLD, SIG_IGN);\n   signal(SIGTERM, SIG_IGN);\n   struct sigaction sig;\n   sig.sa_handler = SIG_IGN;\n   sig.sa_flags = 0;\n   sigemptyset(&amp;sig.sa_mask);\n   sigaction(SIGHUP, &amp;sig, NULL);\n   // 克隆进程\n   pid = fork();\n   if(ESuccess != pid){\n      exit(ESuccess);\n   }\n   // 尝试更改路径\n   if(chdir(path.MemoryC())){\n      MO_STATIC_DEBUG(&quot;Can't change run dir to %s after initialize daemon.&quot;, path.MemoryC());\n      exit(2);\n   }\n   // 设置合理文件权限\n   umask(0);\n   // 设置进程组\n   setpgrp();\n#endif\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TChar**" name="_ppArguments"/>
                  <Attribute type="TInt" name="_argumentCount"/>
                  <Attribute type="FListeners*" name="_pInterrruptListeners"/>
                  <Attribute type="TInstance" name="_hInstance"/>
                  <Attribute type="TInt" name="_commandShow"/>
               </Attributes>
            </Class>
            <Class name="FArray">
               <Inherits>
                  <Inherit name="MArray" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FArray" description="构造变长数组。"/>
                  <Constructor name="FArray" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FArray" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FArray" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FArray" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="FArray&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FArray" description="析构变长数组。"/>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      // 当第一次使用的时候，收集不小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n      this-&gt;_length = 0;\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_pMemory = RTypeMemory&lt;T&gt;::Alloc(this-&gt;_size, 0);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MPtrC&lt;T&gt;&amp; ptr){\n      Assign(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="MArrayC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MArrayC&lt;T&gt;&amp; values){\n      Assign(values.MemoryC(), values.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="FArray&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const FArray&lt;T&gt;&amp; values){\n      Assign(values.MemoryC(), values.Length());\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if(size &gt; this-&gt;_size){\n         // 当内存不足时，扩大1.5倍内存，但收集量不得小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n         this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n         this-&gt;_size += this-&gt;_size &gt;&gt; 1;\n         T* pMemory = RTypeMemory&lt;T&gt;::Alloc(this-&gt;_size, 0);\n         if(this-&gt;_length &gt; 0){\n            RTypes&lt;T&gt;::Copy(pMemory, this-&gt;_pMemory, this-&gt;_length);\n         }\n         RTypeMemory&lt;T&gt;::Free(this-&gt;_pMemory);\n         this-&gt;_pMemory = pMemory;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FAtomStorage">
               <Inherits name="FObject" scope="public"/>
               <Methods>
                  <Constructor name="FAtomStorage"/>
                  <Destructor name="~FAtomStorage"/>
                  <Method name="EntryAlloc">
                     <Return type="SEntry*"/>
                     <Source>\nSEntry* EntryAlloc(){\n      // 获得未使用的节点\n      SEntry* pEntry = NULL;\n      if(NULL != _pUnused){\n         pEntry = _pUnused;\n         _pUnused = _pUnused-&gt;pNext;\n      }else{\n         //pEntry = _pEntryAllocator-&gt;Alloc(&quot;SEntry&quot;, sizeof(SEntry), __FILE__, __LINE__);\n      }\n      // 设置节点\n      pEntry-&gt;pNext = NULL;\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryFree">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EntryFree(SEntry* pEntry){\n      pEntry-&gt;pNext = _pFree;\n      _pFree = pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryUnused">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EntryUnused(SEntry* pEntry){\n      pEntry-&gt;pNext = _pUnused;\n      _pUnused = pEntry;\n   }</Source>
                  </Method>
                  <Method name="AtomCreate" flag="virtual">
                     <Return type="T"/>
                  </Method>
                  <Method name="AtomDelete" flag="virtual">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Alloc">
                     <Return type="T"/>
                     <Source>\nvirtual T Alloc(){\n      // 获得一个可用的类型内存\n      if(NULL != _pFree){\n         T value = _pFree-&gt;value;\n         SEntry* pNext = _pFree-&gt;pNext;\n         EntryUnused(_pFree);\n         _pFree = pNext;\n         return value;\n      }\n      // 返回收集的元素\n      return AtomCreate();\n   }</Source>
                  </Method>
                  <Method name="Free">
                     <Parameters>
                        <Parameter type="T" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvirtual void Free(T pValue){\n      // 收集节点\n      SEntry* pEntry = EntryAlloc();\n      // 设置信息\n      pEntry-&gt;value = pValue;\n      // 存储节点\n      EntryFree(pEntry);\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TThreadSection" name="_section"/>
                  <Attribute type="FBlockAllocator*" name="_pEntryAllocator"/>
                  <Attribute type="SEntry*" name="_pFree"/>
                  <Attribute type="SEntry*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="FAttributes">
               <Inherits>
                  <Inherit name="MAttributes" scope="public"/>
               </Inherits>
            </Class>
            <Class name="FBinaryFileStream">
               <Inherits name="FFileStream" scope="public"/>
               <Methods>
                  <Method name="ReadBoolean" description="读取TBool类型数据">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TBool类型数据&lt;/T&gt;\n//\n// @return 返回TBool类型数据\n//============================================================\n\nTBool FBinaryFileStream::ReadBoolean(){\n   TBool value;\n   fread(&amp;value, sizeof(TBool), 1, _handle);\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadUInt" description="读取TUint类型数据">
                     <Return type="TUint"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TUint类型数据&lt;/T&gt;\n//\n// @return 返回TUint类型类型数据\n//============================================================\n\nTUint FBinaryFileStream::ReadUInt(){\n   TUint value;\n   fread(&amp;value, sizeof(TUint), 1, _handle);\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadInt" description="读取TInt类型数据">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TInt类型数据&lt;/T&gt;\n//\n// @return 返回TInt类型类型数据\n//============================================================\n\nTInt FBinaryFileStream::ReadInt(){\n   TInt value;\n   fread(&amp;value, sizeof(TInt), 1, _handle);\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadUInt8" description="读取TUint8类型数据">
                     <Return type="TUint8"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TUint8类型数据&lt;/T&gt;\n//\n// @return 返回TUint8类型类型数据\n//============================================================\n\nTUint8 FBinaryFileStream::ReadUInt8(){\n   TUint8 value;\n   fread(&amp;value, sizeof(TUint8), 1, _handle);\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadInt8" description="读取TInt8类型数据">
                     <Return type="TInt8"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TInt8类型数据&lt;/T&gt;\n//\n// @return 返回TInt类型类型数据\n//============================================================\n\nTInt8 FBinaryFileStream::ReadInt8(){\n   TInt8 value;\n   fread(&amp;value, sizeof(TInt8), 1, _handle);\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadUInt16" description="读取TUint16类型数据">
                     <Return type="TUint16"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TUint16类型数据&lt;/T&gt;\n//\n// @return 返回TUint16类型类型数据\n//============================================================\n\nTUint16 FBinaryFileStream::ReadUInt16(){\n   TUint16 value;\n   fread(&amp;value, sizeof(TUint16), 1, _handle);\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadInt16" description="读取TInt16类型数据">
                     <Return type="TInt16"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TInt16类型数据&lt;/T&gt;\n//\n// @return 返回TInt类型类型数据\n//============================================================\n\nTInt16 FBinaryFileStream::ReadInt16(){\n   TInt16 value;\n   fread(&amp;value, sizeof(TInt16), 1, _handle);\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadUInt32" description="读取TUint32类型数据">
                     <Return type="TUint32"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TUint32类型数据&lt;/T&gt;\n//\n// @return 返回TUint32类型类型数据\n//============================================================\n\nTUint32 FBinaryFileStream::ReadUInt32(){\n    TUint32 value;\n    fread(&amp;value, sizeof(TUint32), 1, _handle);\n    return value;\n}</Source>
                  </Method>
                  <Method name="ReadInt32" description="读取TInt32类型数据">
                     <Return type="TInt32"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TInt32类型数据&lt;/T&gt;\n//\n// @return 返回TInt类型类型数据\n//============================================================\n\nTInt32 FBinaryFileStream::ReadInt32(){\n    TInt32 value;\n    fread(&amp;value, sizeof(TInt32), 1, _handle);\n    return value;\n}</Source>
                  </Method>
                  <Method name="ReadUInt64" description="读取TUint64类型数据">
                     <Return type="TUint64"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TUint64类型数据&lt;/T&gt;\n//\n// @return 返回TUint64类型类型数据\n//============================================================\n\nTUint64 FBinaryFileStream::ReadUInt64(){\n   TInt64 value;\n   fread(&amp;value, sizeof(TUint64), 1, _handle);\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadInt64" description="读取TInt64类型数据">
                     <Return type="TInt64"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TInt64类型数据&lt;/T&gt;\n//\n// @return 返回TInt类型类型数据\n//============================================================\n\nTInt64 FBinaryFileStream::ReadInt64(){\n   TInt64 value;\n   fread(&amp;value, sizeof(TInt64), 1, _handle);\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadFloat" description="读取TFloat类型数据">
                     <Return type="TFloat"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TFloat类型数据&lt;/T&gt;\n//\n// @return 返回TFoalt类型类型数据\n//============================================================\n\nTFloat FBinaryFileStream::ReadFloat(){\n   TFloat value;\n   fread(&amp;value, sizeof(TFloat), 1, _handle);\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadDouble" description="读取TDouble类型数据">
                     <Return type="TDouble"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TDouble类型数据&lt;/T&gt;\n//\n// @return 返回TDouble类型类型数据\n//============================================================\n\nTDouble FBinaryFileStream::ReadDouble(){\n   TDouble value;\n   fread(&amp;value, sizeof(TDouble), 1, _handle);\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadString" description="读取字符串类型数据，先读长度，后读数据。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="buffer"/>
                        <Parameter type="TUint32" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;读取字符串类型数据，先读长度，后读数据。&lt;/T&gt;\n// \n// @param pBuffer 存放读取到的数据的内存块指针。\n// @param length 内存块的长度。\n//============================================================\n\nTInt FBinaryFileStream::ReadString(TChar8C* pBuffer, TUint32 length){\n   TUint32 readed;\n   fread(&amp;readed, sizeof(TUint32),1,_handle);\n   if(readed &gt; 0){\n      MO_ASSERT(readed &lt;= length);\n      fread((TAny*)pBuffer, sizeof(TChar8C) * readed, 1, _handle);\n   }\n   return readed;\n}</Source>
                  </Method>
                  <Method name="ReadString" description="读取字符串类型数据，先读长度，后读数据,宽字符版本。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="buffer"/>
                        <Parameter type="TUint32" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;读取字符串类型数据，先读长度，后读数据,宽字符版本。&lt;/T&gt;\n// \n// @param pBuffer 存放读取到的数据的内存块指针。\n// @param length 内存块的长度。\n//============================================================\n\nTInt FBinaryFileStream::ReadString(TChar16C* pBuffer, TUint32 length){\n   TUint32 readed;\n   fread(&amp;readed, sizeof(TUint32),1,_handle);\n   if(readed &gt; 0){\n      MO_ASSERT(readed &lt;= length);\n      fread((TAny*)pBuffer, sizeof(TChar16C) * readed , 1, _handle);\n   }\n   return readed;\n}</Source>
                  </Method>
                  <Method name="WriteBoolean" description="写入Tbool类型数据">
                     <Parameters>
                        <Parameter type="TBool" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入Tbool类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteBoolean(TBool value){\n   fwrite(&amp;value, sizeof(TBool), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteUInt" description="写入TUint类型数据">
                     <Parameters>
                        <Parameter type="TUint" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TUint类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteUInt(TUint value){\n   fwrite(&amp;value, sizeof(TUint), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteInt" description="写入TInt类型数据">
                     <Parameters>
                        <Parameter type="TInt" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TInt类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteInt(TInt value){\n   fwrite(&amp;value, sizeof(TInt), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteUInt8" description="写入TUint8类型数据">
                     <Parameters>
                        <Parameter type="TUint8" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TUint8类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteUInt8(TUint8 value){\n    fwrite(&amp;value, sizeof(TUint8), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteInt8" description="写入TInt8类型数据">
                     <Parameters>
                        <Parameter type="TInt8" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TInt8类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteInt8(TInt8 value){\n    fwrite(&amp;value, sizeof(TInt8), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteUInt16" description="写入TUint16类型数据">
                     <Parameters>
                        <Parameter type="TUint16" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TUint16类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteUInt16(TUint16 value){\n   fwrite(&amp;value, sizeof(TUint16), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteInt16" description="写入TInt16类型数据">
                     <Parameters>
                        <Parameter type="TInt16" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TInt16类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteInt16(TInt16 value){\n   fwrite(&amp;value, sizeof(TInt16), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteUInt32" description="写入TUint32类型数据">
                     <Parameters>
                        <Parameter type="TUint32" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TUint32类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteUInt32(TUint32 value){\n   fwrite(&amp;value, sizeof(TUint32), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteInt32" description="写入TInt32类型数据">
                     <Parameters>
                        <Parameter type="TInt32" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TInt32类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteInt32(TInt32 value){\n   fwrite(&amp;value, sizeof(TInt32), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteUInt64" description="写入TUint64类型数据">
                     <Parameters>
                        <Parameter type="TUint64" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n//&lt;T&gt;写入TUint64类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteUInt64(TUint64 value){\n   fwrite(&amp;value, sizeof(TUint64), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteInt64" description="写入TInt64类型数据">
                     <Parameters>
                        <Parameter type="TInt64" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n//&lt;T&gt;写入TInt64类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteInt64(TInt64 value){\n   fwrite(&amp;value, sizeof(TInt64), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteFloat" description="写入TFloat类型数据">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n//&lt;T&gt;写入TFloat类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteFloat(TFloat value){\n   fwrite(&amp;value , sizeof(TFloat), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteDouble" description="写入TDouble类型数据">
                     <Parameters>
                        <Parameter type="TDouble" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TDouble类型数据&lt;/T&gt;\n//============================================================\n\nvoid FBinaryFileStream::WriteDouble(TDouble value){\n   fwrite(&amp;value, sizeof(TDouble), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteString" description="写入字符串类型数据，先写长度，后跟数据。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pBuffer"/>
                        <Parameter type="TUint32" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入字符串类型数据，先写长度，后跟数据。&lt;/T&gt;\n//\n// @param pBuffer  写入数据的指针\n// @param length 写入数据长度\n//============================================================\n\nvoid FBinaryFileStream::WriteString(TChar8C* pBuffer, TUint32 length){\n   fwrite(&amp;length, sizeof(TUint32), 1, _handle);\n   if(length &gt; 0){\n      fwrite(pBuffer, sizeof(TChar8C) * length, 1, _handle);\n   }\n}</Source>
                  </Method>
                  <Method name="WriteString" description="写入字符串类型数据，先写长度，后跟数据,宽字符版本。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pBuffer"/>
                        <Parameter type="TUint32" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入字符串类型数据，先写长度，后跟数据,宽字符版本。&lt;/T&gt;\n//\n// @param pBuffer  写入数据的指针\n// @param length 写入数据长度\n//============================================================\n\nvoid FBinaryFileStream::WriteString(TChar16C* pBuffer, TUint32 length){\n   fwrite(&amp;length, sizeof(TUint32), 1, _handle);\n   if(length &gt; 0){\n      fwrite(pBuffer, sizeof(TChar16C) * length, 1, _handle);\n   }\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FBlockAllocator">
               <Inherits>
                  <Inherit name="IAllocator" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FBlockAllocator"/>
                  <Constructor name="FBlockAllocator" description="构造块内存实例。">
                     <Parameters>
                        <Parameter type="TUint" name="atomSize"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FBlockAllocator" description="析构块内存实例。"/>
                  <Method name="EntryExtend" flag="abstract" description="扩展原子内存。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;扩展原子内存。&lt;/T&gt;\n// &lt;P&gt;收集内存的第一块为收集链表，第二块开始为前部分为块信息，后部分为数据区。&lt;/P&gt;\n//\n// @param pEntry 内存原子实例\n//============================================================\n\nvoid FBlockAllocator::EntryExtend(){\n   // 计算要收集的个数，使要收集的内存尽量落在页内\n   TInt atomSize = sizeof(SMemoryEntry) + sizeof(TInt) + _atomSize;\n   // TODO: TInt pageSize = getpagesize();\n   TInt pageSize = 8192;\n   TInt count = MO_MAX((pageSize-sizeof(SMemoryEntry)) / atomSize, MO_OBJECT_CAPACITY);\n   TUint allocSize = sizeof(SMemoryEntry) + atomSize * count;\n   _total += count;\n   _memoryTotal += allocSize;\n   // 收集内存\n   TByte* pMemory = (TByte*)MO_ALIGNED_ALLOC(allocSize, sizeof(TInt));\n   MO_ASSERT(pMemory);\n   memset(pMemory, 0, allocSize);\n   // 保存第一块内存区\n   SMemoryEntry* pAllocAtom = (SMemoryEntry*)pMemory;\n   pAllocAtom-&gt;pMemory = pMemory;\n   pMemory += sizeof(SMemoryEntry);\n   // 压入已收集区\n   if(NULL != _pAlloc){\n      _pAlloc-&gt;pPrior = pAllocAtom;\n   }\n   pAllocAtom-&gt;pNext = _pAlloc;\n   _pAlloc = pAllocAtom;\n   // 初始化所有内存原子\n   while(--count &gt;= 0){\n      // 链初始化\n      SMemoryEntry* pEntry = (SMemoryEntry*)pMemory;\n      pEntry-&gt;pAllocator = this;\n      pEntry-&gt;Link(pMemory + sizeof(SMemoryEntry), _atomSize);\n      pMemory += atomSize;\n      // 压入未使用的队列\n      if(NULL != _pUnused){\n         _pUnused-&gt;pPrior = pEntry;\n      }\n      pEntry-&gt;pNext = _pUnused;\n      _pUnused = pEntry;\n   }\n}</Source>
                  </Method>
                  <Method name="EntryPush" type="inline" description="将链表节点压入尾位置。">
                     <Parameters>
                        <Parameter type="SMemoryEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将链表节点压入尾位置。&lt;/T&gt;\n//\n// @param pEntry 内存原子实例\n//============================================================\n\nvoid FBlockAllocator::EntryPush(SMemoryEntry* pEntry){\n   MO_ASSERT(pEntry);\n   if(NULL == _pLast){\n      _pFirst = pEntry;\n   }else{\n      _pLast-&gt;pNext = pEntry;\n   }\n   pEntry-&gt;pPrior = _pLast;\n   _pLast = pEntry;\n   // 设置内容\n   _count++;\n   pEntry-&gt;pNext = NULL;\n}</Source>
                  </Method>
                  <Method name="EntryRemove" type="inline" description="从链表上删除链表节点。">
                     <Parameters>
                        <Parameter type="SMemoryEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;从链表上删除链表节点。&lt;/T&gt;\n//\n// @param pEntry 内存原子实例\n//============================================================\n\nvoid FBlockAllocator::EntryRemove(SMemoryEntry* pEntry){\n   MO_ASSERT(pEntry);\n   SMemoryEntry* pPrior = pEntry-&gt;pPrior;\n   SMemoryEntry* pNext = pEntry-&gt;pNext;\n   // 处理前节点\n   if(NULL == pPrior){\n      _pFirst = pNext;\n   }else{\n      pPrior-&gt;pNext = pNext;\n   }\n   // 处理后节点\n   if(NULL == pNext){\n      _pLast = pPrior;\n   }else{\n      pNext-&gt;pPrior = pPrior;\n   }\n   // 设置内容\n   _count--;\n   // 释放节点\n   pEntry-&gt;pNext = _pUnused;\n   _pUnused = pEntry;\n}</Source>
                  </Method>
                  <Method name="EntryAlloc" type="inline" description="收集一个内存原子实例。">
                     <Return type="SMemoryEntry*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一个内存原子实例。&lt;/T&gt;\n//\n// @return 内存原子实例\n//============================================================\n\nSMemoryEntry* FBlockAllocator::EntryAlloc(){\n   // 如果没有可使用的内存，则扩展缓冲区\n   if(NULL == _pUnused){\n      EntryExtend();\n   }\n   // 获得一个可用的类型内存\n   SMemoryEntry* pEntry = _pUnused;\n   _pUnused = pEntry-&gt;pNext;\n   // 压入使用中的队列\n   EntryPush(pEntry);\n   // 记录收集操作\n   pEntry-&gt;Alloc();\n   // 返回收集的内存\n   return pEntry;\n}</Source>
                  </Method>
                  <Method name="Name" description="获取类名称。">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获取类名称。&lt;/T&gt;\n//\n// @return 类名称\n//============================================================\n\nTCharC* FBlockAllocator::Name(){\n   return _pName;\n}</Source>
                  </Method>
                  <Method name="SetName" description="设置类名称。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置类名称。&lt;/T&gt;\n//\n// @param pName 类名称\n//============================================================\n\nvoid FBlockAllocator::SetName(TCharC* pName){\n   _pName = pName;\n}</Source>
                  </Method>
                  <Method name="GetMemoryUsed" description="获取已使用内存。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获取已使用内存。&lt;/T&gt;\n//\n// @return 已使用内存\n//============================================================\n\nTInt FBlockAllocator::GetMemoryUsed(){\n   return _atomSize * _count;\n}</Source>
                  </Method>
                  <Method name="GetMemoryTotal" description="获取总使用内存。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获取总使用内存。&lt;/T&gt;\n//\n// @return 总使用内存\n//============================================================\n\nTInt FBlockAllocator::GetMemoryTotal(){\n   return _memoryTotal;\n}</Source>
                  </Method>
                  <Method name="Alloc" flag="override" description="收集一块定长的内存。">
                     <Parameters>
                        <Parameter type="TUint" name="size" default="0"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块定长的内存。&lt;/T&gt;\n//\n// @param size 内存大小\n// @return 内存指针\n//============================================================\n\nTAny* FBlockAllocator::Alloc(TUint size){\n   SMemoryEntry* pEntry = EntryAlloc();\n   MO_ASSERT(pEntry);\n   return pEntry-&gt;pMemory;\n}</Source>
                  </Method>
                  <Method name="Alloc" flag="override" description="收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pTypeName"/>
                        <Parameter type="TUint" name="size"/>
                        <Parameter type="TChar8C*" name="pFileName"/>
                        <Parameter type="TInt" name="fileLine"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param pTypeName 类型名称\n// @param size 内存大小\n// @param pFileName 文件名称\n// @param line 文件行数\n// @return 内存指针\n//============================================================\n\nTAny* FBlockAllocator::Alloc(TCharC* pTypeName, TUint size, TChar8C* pFileName, TInt fileLine){\n   // MO_DEBUG(&quot;new %s(%d)\n&quot;, pTypeName, size);\n   MO_ASSERT(_atomSize == size);\n   SMemoryEntry* pEntry = EntryAlloc();\n   MO_ASSERT(pEntry);\n   pEntry-&gt;SetTypeName(pTypeName);\n   pEntry-&gt;SetFileInfo(pFileName, fileLine);\n   return pEntry-&gt;pMemory;\n}</Source>
                  </Method>
                  <Method name="Free" flag="override" description="释放内存。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放内存。&lt;/T&gt;\n//\n// @param pMemory 内存指针\n//============================================================\n\nvoid FBlockAllocator::Free(TAny* pMemory){\n   // 获得当前使用的实例\n   MO_ASSERT(pMemory);\n   TInt* pAlloc = ((TInt*)pMemory) - 1;\n   SMemoryEntry* pEntry = (SMemoryEntry*)pAlloc[0];\n   MO_ASSERT(pEntry);\n   // 检查内存转换正确性\n   MO_ASSERT(pEntry-&gt;pAllocator == this);\n   MO_ASSERT(pEntry-&gt;pMemory == pMemory);\n   // 记录释放操作\n   pEntry-&gt;Free();\n   _count--;\n   // 压入未使用的队列\n   EntryRemove(pEntry);\n}</Source>
                  </Method>
                  <Method name="DumpTrack">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FBlockAllocator::DumpTrack(){\n   //MO_TRACK(&quot;Size %08d memory is used. [used=%d, free=%d, total=%d, usedTotal=%d, allocTotal=%d]&quot;, _atomSize, _count, _total - _count, _total, GetMemoryUsed(), _memoryTotal);\n   SMemoryEntry* pEntry = _pFirst;\n   while(NULL != pEntry){\n      //MO_TRACK(&quot;-- Block [type=%s, alloc=%d/%d file=%s(%d)]&quot;, pEntry-&gt;pTypeName, pEntry-&gt;allocCount, pEntry-&gt;freeCount, pEntry-&gt;pFileName, pEntry-&gt;fileLine);\n      pEntry = pEntry-&gt;pNext;\n   }\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TCharC*" name="_pName"/>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="TSize" name="_atomSize"/>
                  <Attribute type="SMemoryEntry*" name="_pAlloc"/>
                  <Attribute type="SMemoryEntry*" name="_pFirst"/>
                  <Attribute type="SMemoryEntry*" name="_pLast"/>
                  <Attribute type="SMemoryEntry*" name="_pUnused"/>
                  <Attribute type="TInt" name="_total"/>
                  <Attribute type="TInt" name="_memoryTotal"/>
               </Attributes>
            </Class>
            <Class name="FBlockLockAllocator">
               <Inherits name="FBlockAllocator" scope="public"/>
               <Methods>
                  <Constructor name="FBlockLockAllocator">
                     <Parameters>
                        <Parameter type="TUint" name="atomSize"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FBlockLockAllocator"/>
                  <Method name="Alloc" flag="override" description="收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TUint" name="size" default="0"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param size 内存大小\n// @return 内存指针\n//============================================================\n\nTAny* FBlockLockAllocator::Alloc(TUint size){\n   _section.Enter();\n   TAny* pMemory = FBlockAllocator::Alloc(size);\n   _section.Leave();\n   return pMemory;\n}</Source>
                  </Method>
                  <Method name="Alloc" flag="override" description="收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pClassName"/>
                        <Parameter type="TUint" name="size"/>
                        <Parameter type="TChar8C*" name="pFileName"/>
                        <Parameter type="TInt" name="fileLine"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param pTypeName 类型名称\n// @param size 内存大小\n// @param pFileName 文件名称\n// @param line 文件行数\n// @return 内存指针\n//============================================================\n\nTAny* FBlockLockAllocator::Alloc(TCharC* pTypeName, TUint size, TChar8C* pFileName, TInt fileLine){\n   _section.Enter();\n   TAny* pMemory = FBlockAllocator::Alloc(pTypeName, size, pFileName, fileLine);\n   _section.Leave();\n   return pMemory;\n}</Source>
                  </Method>
                  <Method name="Free" flag="override" description="释放内存。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放内存。&lt;/T&gt;\n//\n// @param pMemory 内存指针\n//============================================================\n\nvoid FBlockLockAllocator::Free(TAny* pMemory){\n   _section.Enter();\n   FBlockAllocator::Free(pMemory);\n   _section.Leave();\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TThreadSection" name="_section"/>
               </Attributes>
            </Class>
            <Class name="FBlockedPipe">
               <Inherits name="FPipe" scope="public"/>
               <Attributes>
                  <Attribute type="TThreadCondition" name="_condition"/>
                  <Attribute type="TBool" name="_readerBlock"/>
                  <Attribute type="TBool" name="_writerBlock"/>
               </Attributes>
            </Class>
            <Class name="FDataset">
               <Inherits name="FList" scope="public"/>
               <Methods>
                  <Constructor name="FDataset"/>
                  <Destructor name="~FDataset"/>
                  <Method name="Fields">
                     <Return type="FFields*"/>
                     <Source>//============================================================\n\nFFields* FDataset::Fields(){\n   if(NULL != _pFields){\n      _pFields = MO_CREATE(FFields);\n   }\n   return _pFields;\n}</Source>
                  </Method>
                  <Method name="CreateRow" description="创建一个数据行。">
                     <Return type="FRow*"/>
                     <Source>//============================================================\n// &lt;T&gt;创建一个数据行。&lt;/T&gt;\n//============================================================\n\nFRow* FDataset::CreateRow(){\n   FRow* pRow = MO_CREATE(FRow, this);\n   Push(pRow);\n   return pRow;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FFields*" name="_pFields"/>
               </Attributes>
            </Class>
            <Class name="FDictionary">
               <Inherits>
                  <Inherit name="MDictionary" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FDictionary" description="创建字典对象。"/>
                  <Constructor name="FDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="MDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="FDictionary&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FDictionary" description="释放字典对象。"/>
                  <Method name="operator=" description="接收另一个字典对象的全部数据。">
                     <Parameters>
                        <Parameter type="MDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MDictionaryC&lt;T&gt;&amp; dictionary){\n      this-&gt;Assign(dictionary);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="接收另一个字典对象的全部数据。">
                     <Parameters>
                        <Parameter type="FDictionary&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const FDictionary&lt;T&gt;&amp; dictionary){\n      this-&gt;Assign(dictionary);\n   }</Source>
                  </Method>
                  <Method name="EntryCreate" type="inline" description="新建一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      EnsureSize(this-&gt;_count + 1);\n      return MO_CREATE(SEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryRelease" type="inline" description="释放一个指定的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRelease(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      MO_DELETE(pEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatCreate" type="inline" description="收集节点列表内存。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="SEntry**"/>
                     <Source>\ninline SEntry** EntryFlatCreate(TInt size){\n      return RTypeMemory&lt;SEntry*&gt;::Alloc(size, NULL);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatRelease" type="inline" description="释放节点列表内存。">
                     <Parameters>
                        <Parameter type="SEntry**" name="pEntries"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFlatRelease(SEntry** pEntries){\n      MO_ASSERT(pEntries);\n      RTypeMemory&lt;SEntry*&gt;::Free(pEntries);\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保当前对象可以容纳指定大小的数据。" note="当哈希表是旧表的8倍时开始扩充，扩大2倍。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if(NULL == this-&gt;_ppEntries) {\n         this-&gt;_entryCount = MO_MAX(size, MO_OBJECT_CAPACITY);\n         // 第一次新建时，生成哈希表\n         this-&gt;_ppEntries = EntryFlatCreate(this-&gt;_entryCount);\n      } else if (size &gt; (this-&gt;_entryCount &lt;&lt; 3)) {\n         // 扩充内存时处理\n         size = this-&gt;_entryCount + (MO_MAX(this-&gt;_entryCount, size) &gt;&gt; 1);\n         // 当总数大于节点列表长度8倍时，重新扩充节点列表\n         SEntry** ppEntries = EntryFlatCreate(size);\n         EntriesResize(ppEntries, size);\n         // 释放旧节点内存\n         EntryFlatRelease(this-&gt;_ppEntries);\n         // 保存新的节点列表\n         this-&gt;_ppEntries = ppEntries;\n         this-&gt;_entryCount = size;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FEntryBufferedAllocator">
               <Methods>
                  <Constructor name="FEntryBufferedAllocator">
                     <Parameters>
                        <Parameter type="FEntryStorage&lt;E&gt;*" name="pStorage"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FEntryBufferedAllocator"/>
                  <Method name="Alloc">
                     <Return type="E*"/>
                     <Source>\nE* Alloc(){\n      // 如果没有可以收集的，则预先收集\n      if(NULL == _pFirst){\n         _pStorage-&gt;AllocList(_capacity, &amp;_pFirst, &amp;_pLast);\n         _count += _capacity;\n      }\n      // 收集一个未使用块\n      E* pEntry = _pFirst;\n      _pFirst = pEntry-&gt;pNext;\n      if(NULL == _pFirst){\n         _pLast = NULL;\n      }\n      pEntry-&gt;pNext = NULL;\n      _count--;\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="Free">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Free(E* pEntry){\n      MO_ASSERT(pEntry);\n      // 释放对象\n      _count++;\n      if(NULL == _pFirst){\n         _pLast = pEntry;\n      }else{\n         pEntry-&gt;pNext = _pFirst;\n      }\n      _pFirst = pEntry;\n      // 大于缓冲个数时全部释放\n      if(_count &gt; _total){\n         Release();\n      }\n   }</Source>
                  </Method>
                  <Method name="FreeList">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                        <Parameter type="E*" name="pFirst"/>
                        <Parameter type="E*" name="pLast"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid FreeList(TInt count, E* pFirst, E* pLast){\n      MO_ASSERT(pFirst);\n      MO_ASSERT(pLast);\n      // 释放对象\n      _count += count;\n      if(NULL == _pFirst){\n         _pLast = pLast;\n      }else{\n         pLast-&gt;pNext = _pFirst;\n      }\n      _pFirst = pFirst;\n      // 大于缓冲个数时全部释放\n      if(_count &gt; _total){\n         Release();\n      }\n   }</Source>
                  </Method>
                  <Method name="Release">
                     <Return type="void"/>
                     <Source>\nvoid Release(){\n      if(NULL != _pFirst){\n         // 释放对象\n         _pStorage-&gt;FreeList(_count, _pFirst, _pLast);\n         _count = 0;\n         _pFirst = NULL;\n         _pLast = NULL;\n      }\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="E*" name="_pFirst"/>
                  <Attribute type="E*" name="_pLast"/>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="TInt" name="_capacity"/>
                  <Attribute type="TInt" name="_total"/>
               </Attributes>
            </Class>
            <Class name="FEntryBufferedPipe">
               <Inherits name="FEntryPipe" scope="public"/>
               <Methods>
                  <Constructor name="FEntryBufferedPipe"/>
                  <Destructor name="~FEntryBufferedPipe"/>
                  <Method name="Readers">
                     <Return type="FReaderList*"/>
                     <Source>\nFReaderList* Readers(){\n      return _pReaders;\n   }</Source>
                  </Method>
                  <Method name="ReaderAlloc">
                     <Return type="R*"/>
                     <Source>\nR* ReaderAlloc(){\n      R* pReader = MO_CREATE(R, this);\n      MO_ASSERT(pReader);\n      _pReaders-&gt;Push(pReader);\n      return pReader;\n   }</Source>
                  </Method>
                  <Method name="ReaderFree">
                     <Parameters>
                        <Parameter type="R*" name="pReader"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid ReaderFree(R* pReader){\n      MO_ASSERT(pReader);\n      _pReaders-&gt;Remove(pReader);\n      MO_DELETE(pReader);\n   }</Source>
                  </Method>
                  <Method name="Writers">
                     <Return type="FWriterList*"/>
                     <Source>\nFWriterList* Writers(){\n      return _pWriters;\n   }</Source>
                  </Method>
                  <Method name="WriterAlloc">
                     <Return type="W*"/>
                     <Source>\nW* WriterAlloc(){\n      W* pWriter = MO_CREATE(W, this);\n      MO_ASSERT(pWriter);\n      _pWriters-&gt;Push(pWriter);\n      return pWriter;\n   }</Source>
                  </Method>
                  <Method name="WriterFree">
                     <Parameters>
                        <Parameter type="W*" name="pWriter"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid WriterFree(W* pWriter){\n      MO_ASSERT(pWriter);\n      _pWriters-&gt;Remove(pWriter);\n      MO_DELETE(pWriter);\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FReaderList*" name="_pReaders"/>
                  <Attribute type="FWriterList*" name="_pWriters"/>
               </Attributes>
            </Class>
            <Class name="FEntryBufferedStorage">
               <Inherits name="FEntryStorage" scope="public"/>
               <Methods>
                  <Constructor name="FEntryBufferedStorage"/>
                  <Destructor name="~FEntryBufferedStorage"/>
                  <Method name="AllocatorAlloc">
                     <Return type="A*"/>
                     <Source>\nA* AllocatorAlloc(){\n      A* pAllocator = MO_CREATE(A, this);\n      _pAtomAllocators-&gt;Push(pAllocator);\n      return pAllocator;\n   }</Source>
                  </Method>
                  <Method name="AllocatorFree">
                     <Parameters>
                        <Parameter type="A*" name="pAllocator"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AllocatorFree(A* pAllocator){\n      MO_ASSERT(pAllocator);\n      _pAtomAllocators-&gt;Remove(pAllocator);\n      MO_DELETE(pAllocator);\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FAtomAllocatorList*" name="_pAtomAllocators"/>
               </Attributes>
            </Class>
            <Class name="FEntryPipe">
               <Methods>
                  <Constructor name="FEntryPipe" description="构造管道。"/>
                  <Destructor name="~FEntryPipe" description="析构管道。"/>
                  <Method name="EntryShift" type="inline" description="弹出一个链接节点。">
                     <Return type="E*"/>
                     <Source>\ninline E* EntryShift(){\n      E* pEntry = _pRead;\n      if(NULL != _pRead){\n         // 读指针指向下一个位置\n         _pRead = _pRead-&gt;pNext;\n         if(NULL == _pRead){\n            _pWrite = NULL;\n         }else{\n            _pRead-&gt;pPrior = NULL;\n         }\n         // 设置内容\n         _count--;\n         pEntry-&gt;pPrior = NULL;\n         pEntry-&gt;pNext = NULL;\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryPush" type="inline" description="压入一个链接节点。">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryPush(E* pEntry){\n      MO_ASSERT(pEntry);\n      if(NULL == _pWrite){\n         _pRead = pEntry;\n      }else{\n         _pWrite-&gt;pNext = pEntry;\n      }\n      // 设置内容\n      _count++;\n      pEntry-&gt;pPrior = _pWrite;\n      pEntry-&gt;pNext = NULL;\n      // 设置尾节点\n      _pWrite = pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryRemove" type="inline" description="释放一个链接节点。">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRemove(E* pEntry){\n      MO_ASSERT(pEntry);\n      // 处理前节点\n      E* pPrior = pEntry-&gt;pPrior;\n      if(NULL == pPrior){\n         MO_ASSERT(pEntry == _pRead);\n         _pRead = pEntry-&gt;pNext;\n         if(NULL != _pRead){\n            _pRead-&gt;pPrior = NULL;\n         }\n      }else{\n         pPrior-&gt;pNext = pEntry-&gt;pNext;\n      }\n      // 处理后节点\n      E* pNext = pEntry-&gt;pNext;\n      if(NULL == pNext){\n         MO_ASSERT(pEntry == _pWrite);\n         _pWrite = pEntry-&gt;pPrior;\n         if(NULL != _pWrite){\n            _pWrite-&gt;pNext = NULL;\n         }\n      }else{\n         pNext-&gt;pPrior = pEntry-&gt;pPrior;\n      }\n      // 设置内容\n      _count--;\n      pEntry-&gt;pPrior = NULL;\n      pEntry-&gt;pNext = NULL;\n   }</Source>
                  </Method>
                  <Method name="Count">
                     <Return type="TInt"/>
                     <Source>\nTInt Count(){\n      return _count;\n   }</Source>
                  </Method>
                  <Method name="Lock" description="锁定管道。">
                     <Return type="void"/>
                     <Source>\nvoid Lock(){\n      _section.Enter();\n   }</Source>
                  </Method>
                  <Method name="Unlock" description="解锁管道。">
                     <Return type="void"/>
                     <Source>\nvoid Unlock(){\n      _section.Leave();\n   }</Source>
                  </Method>
                  <Method name="Read">
                     <Return type="E*"/>
                     <Source>\nE* Read(){\n      E* pEntry = NULL;\n      _section.Enter();\n      // 存储节点\n      pEntry = EntryShift();\n      // 离开\n      _section.Leave();\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="Write">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Write(E* pEntry){\n      MO_ASSERT(pEntry);\n      _section.Enter();\n      // 存储节点\n      EntryPush(pEntry);\n      // 离开\n      _section.Leave();\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="Flip">
                     <Parameters>
                        <Parameter type="TInt&amp;" name="count"/>
                        <Parameter type="E**" name="ppRead"/>
                        <Parameter type="E**" name="ppWrite"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Flip(TInt&amp; count, E** ppRead, E** ppWrite){\n      TBool result = EFalse;\n      _section.Enter();\n      if(NULL != _pRead){\n         // 读取数据\n         count = _count;\n         *ppRead = _pRead;\n         *ppWrite = _pWrite;\n         // 清空内容\n         _count = 0;\n         _pRead = NULL;\n         _pWrite = NULL;\n         result = ETrue;\n      }\n      _section.Leave();\n      return result;\n   }</Source>
                  </Method>
                  <Method name="Flush" description="写入一个节点。">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                        <Parameter type="E*" name="pRead"/>
                        <Parameter type="E*" name="pWrite"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Flush(TInt count, E* pRead, E* pWrite){\n      MO_ASSERT(pRead);\n      MO_ASSERT(pWrite);\n      _section.Enter();\n      // 增加计数\n      _count += count;\n      // 查找最后一个节点\n      if(NULL == _pWrite){\n         _pRead = pRead;\n      }else{\n         _pWrite-&gt;pNext = pRead;\n         pRead-&gt;pPrior = _pWrite;\n      }\n      _pWrite = pWrite;\n      _section.Leave();\n      return ETrue;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TThreadSection" name="_section"/>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="E*" name="_pRead"/>
                  <Attribute type="E*" name="_pWrite"/>
               </Attributes>
            </Class>
            <Class name="FEntryPipeReader">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FEntryPipeReader" description="构造管道写入器。">
                     <Parameters>
                        <Parameter type="FEntryPipe&lt;E&gt;*" name="pPipe"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FEntryPipeReader" description="析构管道写入器。"/>
                  <Method name="Pipe">
                     <Return type="FEntryPipe&lt;E&gt;"/>
                     <Source>\nFEntryPipe&lt;E&gt; Pipe(){\n      return _pPipe;\n   }</Source>
                  </Method>
                  <Method name="Count">
                     <Return type="TInt"/>
                     <Source>\nTInt Count(){\n      return _count;\n   }</Source>
                  </Method>
                  <Method name="Read">
                     <Return type="E*"/>
                     <Source>\nE* Read(){\n      // 获取首个数据\n      E* pRead = _pRead;\n      if(NULL != pRead){\n         _pRead = pRead-&gt;pNext;\n         if(NULL == _pRead){\n            _pWrite = NULL;\n         }\n         // 设置内容\n         _count--;\n         pRead-&gt;pPrior = NULL;\n         pRead-&gt;pNext = NULL;\n      }\n      return pRead;\n   }</Source>
                  </Method>
                  <Method name="Flip">
                     <Return type="TBool"/>
                     <Source>\nTBool Flip(){\n      // 从管道中获取数据\n      TBool result = EFalse;\n      TInt count = 0;\n      E* pRead = NULL;\n      E* pWrite = NULL;\n      if(_pPipe-&gt;Flip(count, &amp;pRead, &amp;pWrite)){\n         _count += count;\n         if(NULL == _pWrite){\n            _pRead = pRead;\n         }else{\n            _pWrite-&gt;pNext = pRead;\n            pRead-&gt;pPrior = _pWrite;\n         }\n         _pWrite = pWrite;\n         result = ETrue;\n      }\n      return result;\n   }</Source>
                  </Method>
                  <Method name="FlipRead">
                     <Return type="E*"/>
                     <Source>\nE* FlipRead(){\n      // 从管道中获取数据\n      if(NULL == _pRead){\n         _pPipe-&gt;Flip(_count, &amp;_pRead, &amp;_pWrite);\n      }\n      // 获取首个数据\n      E* pRead = _pRead;\n      if(NULL != pRead){\n         _pRead = pRead-&gt;pNext;\n         if(NULL == _pRead){\n            _pWrite = NULL;\n         }\n         // 设置内容\n         _count--;\n         pRead-&gt;pPrior = NULL;\n         pRead-&gt;pNext = NULL;\n      }\n      return pRead;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="E*" name="_pRead"/>
                  <Attribute type="E*" name="_pWrite"/>
               </Attributes>
            </Class>
            <Class name="FEntryPipeWriter">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FEntryPipeWriter" description="构造管道写入器。">
                     <Parameters>
                        <Parameter type="FEntryPipe&lt;E&gt;*" name="pPipe"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FEntryPipeWriter" description="析构管道写入器。"/>
                  <Method name="Pipe">
                     <Return type="FEntryPipe&lt;E&gt;"/>
                     <Source>\nFEntryPipe&lt;E&gt; Pipe(){\n      return _pPipe;\n   }</Source>
                  </Method>
                  <Method name="Count" description="获得写入数量。">
                     <Return type="TInt"/>
                     <Source>\nTInt Count(){\n      return _count;\n   }</Source>
                  </Method>
                  <Method name="Write" description="压入一个链接节点。">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Write(E* pEntry){\n      MO_ASSERT(pEntry);\n      if(NULL == _pWrite){\n         _pRead = pEntry;\n      }else{\n         _pWrite-&gt;pNext = pEntry;\n      }\n      // 设置内容\n      _count++;\n      pEntry-&gt;pPrior = _pWrite;\n      pEntry-&gt;pNext = NULL;\n      // 设置尾节点\n      _pWrite = pEntry;\n   }</Source>
                  </Method>
                  <Method name="Flush" description="刷新缓冲区。">
                     <Return type="void"/>
                     <Source>\nvoid Flush(){\n      if(NULL != _pRead){\n         // 写入所有节点\n         _pPipe-&gt;Flush(_count, _pRead, _pWrite);\n         // 数据清空\n         _count = 0;\n         _pRead = NULL;\n         _pWrite = NULL;\n      }\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="E*" name="_pRead"/>
                  <Attribute type="E*" name="_pWrite"/>
               </Attributes>
            </Class>
            <Class name="FEntryStorage">
               <Inherits name="FObject" scope="public"/>
               <Methods>
                  <Constructor name="FEntryStorage"/>
                  <Destructor name="~FEntryStorage"/>
                  <Method name="Count">
                     <Return type="TInt"/>
                     <Source>\nTInt Count(){\n      return _count;\n   }</Source>
                  </Method>
                  <Method name="Total">
                     <Return type="TInt"/>
                     <Source>\nTInt Total(){\n      return _total;\n   }</Source>
                  </Method>
                  <Method name="Alloc">
                     <Return type="E*"/>
                     <Source>\nE* Alloc(){\n      E* pEntry = NULL;\n      _section.Enter();\n      if(NULL == _pUnused){\n         //pEntry = MO_CALLOC(_pAllocator, E);\n         _total++;\n      }else{\n         _count--;\n         pEntry = _pUnused;\n         _pUnused = pEntry-&gt;pNext;\n      }\n      _section.Leave();\n      pEntry-&gt;pNext = NULL;\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="AllocList">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                        <Parameter type="E**" name="ppFirst"/>
                        <Parameter type="E**" name="ppLast"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool AllocList(TInt count, E** ppFirst, E** ppLast){\n      E* pFirst = NULL;\n      E* pLast = NULL;\n      E* pAlloc = NULL;\n      _section.Enter();\n      while(--count &gt;= 0){\n         // 收集一个数据块\n         if(NULL == _pUnused){\n            //pAlloc = MO_CALLOC(_pAllocator, E);\n            _total++;\n         }else{\n            pAlloc = _pUnused;\n            _pUnused = pAlloc-&gt;pNext;\n            _count--;\n         }\n         // 存储数据块\n         pAlloc-&gt;pNext = NULL;\n         if(NULL == pFirst){\n            pFirst = pAlloc;\n            pLast = pAlloc;\n         }else{\n            pLast-&gt;pNext = pAlloc;\n            pLast = pAlloc;\n         }\n      }\n      *ppFirst = pFirst;\n      *ppLast = pAlloc;\n      _section.Leave();\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="Free">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Free(E* pEntry){\n      MO_ASSERT(pEntry);\n      _section.Enter();\n      // 释放节点\n      pEntry-&gt;pNext = _pUnused;\n      _pUnused = pEntry;\n      _count++;\n      _section.Leave();\n   }</Source>
                  </Method>
                  <Method name="FreeList">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                        <Parameter type="E*" name="pFirst"/>
                        <Parameter type="E*" name="pLast"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid FreeList(TInt count, E* pFirst, E* pLast){\n      MO_ASSERT(pFirst);\n      MO_ASSERT(pLast);\n      _section.Enter();\n      _count += count;\n      pLast-&gt;pNext = _pUnused;\n      _pUnused = pFirst;\n      _section.Leave();\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TThreadSection" name="_section"/>
                  <Attribute type="FBlockAllocator*" name="_pAllocator"/>
                  <Attribute type="E*" name="_pUnused"/>
                  <Attribute type="TUint" name="_count"/>
                  <Attribute type="TUint" name="_total"/>
               </Attributes>
            </Class>
            <Class name="FField">
               <Methods>
                  <Constructor name="FField"/>
                  <Destructor name="~FField"/>
                  <Method name="Name">
                     <Return type="MStringPtrC&amp;"/>
                     <Source>//============================================================\n\nconst MStringPtrC&amp; FField::Name(){\n   return _name;\n}</Source>
                  </Method>
                  <Method name="Type">
                     <Return type="ESqlType"/>
                     <Source>//============================================================\n\nESqlType FField::Type(){\n   return _type;\n}</Source>
                  </Method>
                  <Method name="SetName">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FField::SetName(const MStringPtrC&amp; name){\n   _name = name;\n}</Source>
                  </Method>
                  <Method name="SetType">
                     <Parameters>
                        <Parameter type="ESqlType" name="type"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FField::SetType(ESqlType type){\n   _type = type;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsName" name="_name"/>
                  <Attribute type="ESqlType" name="_type"/>
               </Attributes>
            </Class>
            <Class name="FFields">
               <Inherits name="FDictionary" scope="public"/>
            </Class>
            <Class name="FFileBinary">
               <Inherits name="FBytes" scope="public"/>
               <Methods>
                  <Constructor name="FFileBinary"/>
                  <Constructor name="FFileBinary">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FFileBinary"/>
                  <Method name="LoadFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileBinary::LoadFile(TCharC* pFileName){\n   // 打开文件\n   TFileHandle handle;\n#ifdef _WINDOWS\n   fopen_s(&amp;handle, pFileName, &quot;rb&quot;);\n#else\n   handle = fopen(pFileName, &quot;rb&quot;);\n#endif\n   if(NULL == handle){\n      MO_PERROR(fopen);\n      return EFalse;\n   }\n   // 获得长度\n   if(ESuccess != fseek(handle, 0, SEEK_END)){\n      MO_PERROR(fseek);\n      return EFalse;\n   }\n   TInt length = ftell(handle);\n   EnsureSize(length);\n   // 从开始位置读取\n   if(ESuccess != fseek(handle, 0, SEEK_SET)){\n      MO_PERROR(fseek);\n      return EFalse;\n   }\n   TInt readed = fread(_pMemory, length, 1, handle);\n   if(1 != readed){\n      MO_PFATAL(fread);\n   }\n   // 关闭文件\n   if(ESuccess != fclose(handle)){\n      MO_PFATAL(fclose);\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Store">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileBinary::Store(){\n   return SaveFile(_fileName.MemoryC());\n}</Source>
                  </Method>
                  <Method name="SaveFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileBinary::SaveFile(TCharC* pFileName){\n   // 打开文件\n   TFileHandle handle;\n#ifdef _WINDOWS\n   fopen_s(&amp;handle, pFileName, &quot;w+&quot;);\n#else\n   handle = fopen(pFileName, &quot;w+&quot;);\n#endif\n   if(NULL == handle){\n      MO_PERROR(fopen);\n      return EFalse;\n   }\n   // 从开始位置写入\n   if(ESuccess != fseek(handle, 0, SEEK_SET)){\n      MO_PERROR(fseek);\n      return EFalse;\n   }\n   TInt writted = fwrite(_pMemory, _length, 1, handle);\n   if(writted != _length){\n      MO_PFATAL(fwrite);\n   }\n   // 关闭文件\n   if(ESuccess != fclose(handle)){\n      MO_PFATAL(fclose);\n      return EFalse;\n   }\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsPath" name="_fileName"/>
               </Attributes>
            </Class>
            <Class name="FFileLines">
               <Inherits name="FObject" scope="public"/>
               <Methods>
                  <Constructor name="FFileLines" description="构造函数。"/>
                  <Constructor name="FFileLines" description="构造函数, 加载指定文件内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FFileLines" description="析构。"/>
                  <Method name="operator[]" description="得到指定行。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="FString*"/>
                     <Source>//============================================================\n// &lt;T&gt;得到指定行。&lt;/T&gt;\n//============================================================\n\nFString* FFileLines::operator[](TInt index){\n   MO_ASSERT_RANGE(index, 0, _pLines-&gt;Count());\n   return _pLines-&gt;Get(index);\n}</Source>
                  </Method>
                  <Method name="Lines" description="得到所有行。">
                     <Return type="FStringVector*"/>
                     <Source>//============================================================\n// &lt;T&gt;得到所有行。&lt;/T&gt;\n//============================================================\n\nFStringVector* FFileLines::Lines(){\n   return _pLines;\n}</Source>
                  </Method>
                  <Method name="Line">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="FString*"/>
                  </Method>
                  <Method name="Push" description="加入新行。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pLine"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;加入新行。&lt;/T&gt;\n//============================================================\n\nvoid FFileLines::Push(TCharC* pLine){\n   if(pLine) {\n      FString *fsp;\n      fsp = MO_CREATE(FString, pLine);\n      _pLines-&gt;Push(fsp);\n   }\n}</Source>
                  </Method>
                  <Method name="Clear" description="清除原有的行。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;清除原有的行。&lt;/T&gt;\n//============================================================\n\nvoid FFileLines::Clear(){\n   TInt c = _pLines-&gt;Count();\n   for(TInt i = 0; i &lt; c; ++i){\n      FString* pLine = _pLines-&gt;Get(i);\n      MO_DELETE(pLine);\n   }\n   _pLines-&gt;Clear();\n}</Source>
                  </Method>
                  <Method name="LoadFile" description="从文件中载入行。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;从文件中载入行。&lt;/T&gt;\n//============================================================\n\nTBool FFileLines::LoadFile(TCharC* pFileName){\n   if(!pFileName)\n      return EFalse;\n\n   FILE *fp;\n#ifdef _WINDOWS\n   if(fopen_s(&amp;fp, pFileName, &quot;r&quot;)){\n      return EFalse;\n   }\n#else\n   if(!(fp = fopen(pFileName, &quot;r&quot;)))\n      return EFalse;\n#endif\n\n   Clear();\n\n   TChar *p;\n   TChar buf[MO_MAX_LINE];\n   FString *fsp;\n   while(fgets(buf, sizeof(buf), fp)) {\n      fsp = MO_CREATE(FString);\n      while(!(p = strrchr(buf, '\n'))) {\n         fsp-&gt;Append(buf);\n         if(!fgets(buf, sizeof(buf), fp))\n            break;\n      }\n      if(p) {\n         *p = 0;\n      }\n      if((p = strrchr(buf, '\r'))) {\n         *p = 0;\n      }\n      fsp-&gt;Append(buf);\n      _pLines-&gt;Push(fsp);\n   }\n   fclose(fp);\n\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Store" description="将所有行存入文件，文件名称由构造中的变量指定。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;将所有行存入文件，文件名称由构造中的变量指定。&lt;/T&gt;。\n//============================================================\n\nTBool FFileLines::Store(){\n   return SaveFile(_fileName.MemoryZ());\n}</Source>
                  </Method>
                  <Method name="SaveFile" description="将所有行存入指定文件。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;将所有行存入指定文件。&lt;/T&gt;\n//============================================================\n\nTBool FFileLines::SaveFile(TCharC* pFileName){\n   if(!pFileName){\n      return EFalse;\n   }\n   FILE* pFile = NULL;\n\n#ifdef _WINDOWS\n   if(fopen_s(&amp;pFile, pFileName, &quot;w&quot;)){\n      return EFalse;\n   }\n#else\n   if(!(pFile = fopen(pFileName, &quot;w&quot;))){\n      MO_PERROR(fopen);\n      return EFalse;\n   }\n#endif\n\n   TVectorIteratorC&lt;FString*&gt; iterator = _pLines-&gt;IteratorC();\n   while(iterator.Next()){\n      fputs(iterator-&gt;MemoryZ(), pFile);\n      fputc('\n', pFile);\n   }\n   fclose(pFile);\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FStringVector*" name="_pLines"/>
                  <Attribute type="TFsPath" name="_fileName"/>
               </Attributes>
            </Class>
            <Class name="FFileMapping">
               <Methods>
                  <Constructor name="FFileMapping" description="构造函数"/>
                  <Constructor name="FFileMapping" description="构造函数">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FFileMapping" description="析够函数"/>
                  <Method name="FileName" description="返回文件名">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;返回文件名&lt;/T&gt;\n//\n// @return 文件名\n//============================================================\n\nTCharC* FFileMapping::FileName(){\n   return _filename.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Length" description="返回文件长度">
                     <Return type="TUint64"/>
                     <Source>//============================================================\n// &lt;T&gt;返回文件长度&lt;/T&gt;\n//\n// @return 文件长度\n//============================================================\n\nTUint64 FFileMapping::Length(){\n   // TODO: Unsupport\n   return 0;\n}</Source>
                  </Method>
                  <Method name="Position" description="返回当前文件指针">
                     <Return type="TUint64"/>
                     <Source>//============================================================\n// &lt;T&gt;返回当前文件指针&lt;/T&gt;\n//\n// @return 当前文件指针\n//============================================================\n\nTUint64 FFileMapping::Position(){\n   return _position;\n}</Source>
                  </Method>
                  <Method name="Create" description="创建文件,如果文件存在则其内容清空。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;创建文件,如果文件存在则其内容清空。&lt;/T&gt;\n//\n// @param fileName 文件名\n// @return 打开文件成功返回ETrue,失败则返回EFalse\n//============================================================\n\nTBool FFileMapping::Create(TCharC* pFileName){\n   // 获得系统信息\n   SYSTEM_INFO info;\n   GetSystemInfo(&amp;info);\n   _bytesInBlock = info.dwAllocationGranularity * 16;\n   // 打开文件\n   _hFile = CreateFile(pFileName, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n   if(INVALID_HANDLE_VALUE == _hFile){\n      MO_FATAL(&quot;Open file failure. (error=%d, file=%s)&quot;, GetLastError(), pFileName);\n   }\n   // 创建文件映射\n   _hMapping = CreateFileMapping(_hFile, NULL, PAGE_READWRITE, 0, 0x4000000, NULL);\n   if(INVALID_HANDLE_VALUE == _hMapping){\n      MO_FATAL(&quot;Create file mapping failure. (error=%d, file=%s)&quot;, GetLastError(), pFileName);\n   }\n   // 获得映射内存指针\n   _pMemory = (TByte*)MapViewOfFile(\n      _hMapping,\n      FILE_MAP_ALL_ACCESS,\n      (TUint32)(_position &gt;&gt; 32),\n      (TUint32)(_position &amp; 0xFFFFFFFF),\n      _bytesInBlock);\n   // 释放文件内核对象\n   CloseHandle(_hFile);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Open" description="打开文件">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;打开文件&lt;/T&gt;\n//\n// @param fileName 文件名\n// @return 打开文件成功返回ETrue,失败则返回EFalse\n//============================================================\n\nTBool FFileMapping::Open(TCharC* pFileName){\n   // 获得系统信息\n   SYSTEM_INFO info;\n   GetSystemInfo(&amp;info);\n   _bytesInBlock = info.dwAllocationGranularity * 16;\n   // 打开文件\n   _hFile = CreateFile(pFileName, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n   if(INVALID_HANDLE_VALUE == _hFile){\n      MO_FATAL(&quot;Open file failure. (error=%d, file=%s)&quot;, GetLastError(), pFileName);\n   }\n   // 创建文件映射\n   _hMapping = CreateFileMapping(_hFile, NULL, PAGE_READWRITE, 0, 0x4000000, NULL);\n   if(INVALID_HANDLE_VALUE == _hMapping){\n      MO_FATAL(&quot;Create file mapping failure. (error=%d, file=%s)&quot;, GetLastError(), pFileName);\n   }\n   // 获得映射内存指针\n   _pMemory = (TByte*)MapViewOfFile(\n         _hMapping,\n         FILE_MAP_ALL_ACCESS,\n         (TUint32)(_position &gt;&gt; 32),\n         (TUint32)(_position &amp; 0xFFFFFFFF),\n         _bytesInBlock);\n   // 释放文件内核对象\n   CloseHandle(_hFile);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Seek" description="重定位流上的文件指针">
                     <Parameters>
                        <Parameter type="TInt" name="position"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;重定位流上的文件指针&lt;/T&gt;\n//\n// @param position 偏移字节位置\n//============================================================\n\nTBool FFileMapping::Seek(TInt position){\n   // 设置位置\n   if(_position == position){\n      return EFalse;\n   }\n   _position = position;\n   // 断开内存映射\n   if(!UnmapViewOfFile(_pMemory)){\n      MO_FATAL(&quot;Unmap file mapping failure.&quot;);\n   }\n   // 获得内存映射\n   _pMemory = (TByte*)MapViewOfFile(\n         _hMapping,\n         FILE_MAP_ALL_ACCESS,\n         (TUint32)(_position &gt;&gt; 32),\n         (TUint32)(_position &amp; 0xFFFFFFFF),\n         _bytesInBlock);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Read" flag="override" description="从位置pData开始读取size长度的内容存在_buffer中">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;从位置pData开始读取size长度的内容存在_buffer中&lt;/T&gt;\n//\n// @param pData 读取数据的起始位置\n// @param size 读取数据的长度\n//============================================================\n\nTInt FFileMapping::Read(TAny* pData, TSize size){\n   MO_ASSERT(pData);\n   TInt readed = 0;\n   if(size &gt; 0){\n      //readed = fread(pData, size, 1, _handle);\n   }\n   return readed;\n}</Source>
                  </Method>
                  <Method name="Write" flag="override" description="对文件写入size长度的数据">
                     <Parameters>
                        <Parameter type="TAnyC*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;对文件写入size长度的数据&lt;/T&gt;\n//\n// @param pData 要写入数据的起始位置\n// @param size 要写入数据的长度\n//============================================================\n\nTInt FFileMapping::Write(TAnyC* pData, TSize size){\n   MO_ASSERT(pData);\n   TSize bytesWrite = -1;\n   if(size &gt; 0){\n      //bytesWrite =fwrite(pData, size, 1, _handle);\n   }\n   return bytesWrite;\n}</Source>
                  </Method>
                  <Method name="Close" description="关闭文件">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;关闭文件&lt;/T&gt;\n//\n// @return 打开文件成功返回ETrue,失败则返回EFalse\n//============================================================\n\nTBool FFileMapping::Close(){\n   if(!UnmapViewOfFile(_pMemory)){\n      MO_FATAL(&quot;Unmap file mapping failure.&quot;);\n   }\n   if(!CloseHandle(_hMapping)){\n      MO_FATAL(&quot;Close handle failure.&quot;);\n   }\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsFileName" name="_filename"/>
                  <Attribute type="HANDLE" name="_hFile"/>
                  <Attribute type="HANDLE" name="_hMapping"/>
                  <Attribute type="TUint64" name="_position"/>
                  <Attribute type="TUint32" name="_bytesInBlock"/>
                  <Attribute type="TByte*" name="_pMemory"/>
               </Attributes>
            </Class>
            <Class name="FFileStream">
               <Methods>
                  <Constructor name="FFileStream" description="构造函数"/>
                  <Constructor name="FFileStream" description="构造函数">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                        <Parameter type="TFileAccessMode" name="mode"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FFileStream" description="析够函数"/>
                  <Method name="Open" description="打开文件">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                        <Parameter type="TFileAccessMode" name="mode"/>
                     </Parameters>
                     <Return type="TBool" description="打开文件成功返回ETrue,失败则返回EFalse"/>
                     <Source>//============================================================\n// &lt;T&gt;打开文件&lt;/T&gt;\n//\n// @param fileName 文件名\n// @return 打开文件成功返回ETrue,失败则返回EFalse\n//============================================================\n\nTBool FFileStream::Open(const TCharC* pFileName, TFileAccessMode mode){\n   TCharC* pMode = RFile::FILE_MODE_STR[mode];\n#ifdef _WINDOWS\n   fopen_s(&amp;_handle, pFileName, pMode);\n#else\n   _handle = fopen(pFileName, pMode);\n#endif\n   if(NULL == _handle){\n      MO_ERROR(&quot;Open file failure. (filename=%s, mode=%s)&quot;, pFileName, pMode);\n      MO_PERROR(fopen);\n      return EFalse;\n   }\n   Seek(0);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="FileName" description="返回文件名">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;返回文件名&lt;/T&gt;\n//\n// @return 文件名\n//============================================================\n\nTCharC* FFileStream::FileName(){\n   return _filename.MemoryZ();\n}</Source>
                  </Method>
                  <Method name="Length" description="返回文件长度">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;返回文件长度&lt;/T&gt;\n//\n// @return 文件长度\n//============================================================\n\nTInt FFileStream::Length(){\n   return RFile::FileSize(_filename.MemoryC());\n}</Source>
                  </Method>
                  <Method name="Position" description="返回当前文件指针">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;返回当前文件指针&lt;/T&gt;\n//\n// @return 当前文件指针\n//============================================================\n\nTInt FFileStream::Position(){\n   return ftell(_handle);\n}</Source>
                  </Method>
                  <Method name="Seek" description="重定位流上的文件指针">
                     <Parameters>
                        <Parameter type="TInt" name="position"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;重定位流上的文件指针&lt;/T&gt;\n//\n// @param position 偏移字节位置\n//============================================================\n\nTBool FFileStream::Seek(TInt position){\n   if(fseek(_handle, position, SEEK_SET)){\n      MO_PERROR(fseek);\n      return EFalse;\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="SeekEnd">
                     <Parameters>
                        <Parameter type="TInt" name="position"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FFileStream::SeekEnd(TInt position){\n   if(fseek(_handle, position, SEEK_END)){\n      MO_PFATAL(fseek);\n   }\n   return Position();\n}</Source>
                  </Method>
                  <Method name="Read" flag="override" description="从位置pData开始读取size长度的内容存在_buffer中">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;从位置pData开始读取size长度的内容存在_buffer中&lt;/T&gt;\n//\n// @param pData 读取数据的起始位置\n// @param size 读取数据的长度\n//============================================================\n\nTInt FFileStream::Read(TAny* pData, TSize size){\n   MO_ASSERT(pData);\n   TInt result = 0;\n   if(size &gt; 0){\n		if(feof(_handle)){\n			return 0;\n		}\n      result = fread(pData, 1, size, _handle);\n   }\n   return result;\n}</Source>
                  </Method>
                  <Method name="Write" flag="override" description="对文件写入size长度的数据">
                     <Parameters>
                        <Parameter type="TAnyC*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;对文件写入size长度的数据&lt;/T&gt;\n//\n// @param pData 要写入数据的起始位置\n// @param size 要写入数据的长度\n//============================================================\n\nTInt FFileStream::Write(TAnyC* pData, TSize size){\n   MO_ASSERT(pData);\n   TSize result = 0;\n   if(size &gt; 0){\n      result = fwrite(pData, size, 1, _handle);\n   }\n   return result;\n}</Source>
                  </Method>
                  <Method name="Create" description="创建文件,如果文件存在则其内容清空。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;创建文件,如果文件存在则其内容清空。&lt;/T&gt;\n//\n// @param fileName 文件名\n// @return 打开文件成功返回ETrue,失败则返回EFalse\n//============================================================\n\nTBool FFileStream::Create(TCharC* pFileName){\n#ifdef _WINDOWS\n   TFsPath fullPath = pFileName;\n   TInt index = fullPath.LastIndexOf('\\');\n   if(-1 != index){\n      TFsPath path = fullPath.LeftPtrC(index);\n      RFile::CreateFullDirectory(path.MemoryC());\n   }\n   fopen_s(&amp;_handle, pFileName, &quot;wb+&quot;);\n#else\n   _handle = fopen(pFileName, &quot;wb+&quot;);\n#endif\n   if(NULL == _handle){\n      MO_ERROR(&quot;Create file failure. (filename=%s)&quot;, pFileName);\n      MO_PERROR(fopen);\n      return EFalse;\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Open">
                     <Parameters>
                        <Parameter type="TFileAccessMode" name="mode" default="EFileAccessMode_WriteRead"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="OpenAppend">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileStream::OpenAppend(TCharC* pFileName){\n   return Open(pFileName, EFileAccessMode_AppendWrite);\n}</Source>
                  </Method>
                  <Method name="Flush" description="清除文件缓冲区">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;清除文件缓冲区&lt;/T&gt;\n//\n// @return 打开文件成功返回ETrue,失败则返回EFalse\n//============================================================\n\nTBool FFileStream::Flush(){\n   if(ESuccess != fflush(_handle)){\n      MO_PERROR(fflush);\n      return EFalse;\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="SaveAs" description="保存文件">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;保存文件&lt;/T&gt;\n//\n// @param fileName 要保存文件的文件明\n//============================================================\n\nTBool FFileStream::SaveAs(TCharC* pFileName){\n   // 当前文件指针指向首位置\n   TInt size = Length();\n   rewind(_handle);\n   // 打开目标文件\n#ifdef _WINDOWS\n   TFileHandle handle;\n   fopen_s(&amp;handle, pFileName, &quot;w&quot;);\n#else\n   TFileHandle handle = fopen(pFileName, &quot;w&quot;);\n#endif\n   if(NULL == handle){\n      MO_PERROR(fopen);\n      return EFalse;\n   }\n   // 复制信息到目标文件\n   TBool result = ETrue;\n   TByte buffer[MO_FILE_BUFFER];\n   while(size &gt; 0){\n      TInt length = (size &gt; MO_FILE_BUFFER) ? MO_FILE_BUFFER : size;\n      // 复制数据\n      TInt lengthRead = fread(buffer, length, 1, _handle);\n      TInt lengthWrite = fwrite(buffer, lengthRead, 1, handle);\n      // 检查写出长度\n      if(lengthRead != lengthWrite){\n         MO_PERROR(fwrite);\n         result = EFalse;\n         break;\n      }\n      size = size - lengthRead;\n   }\n   // 关闭目标文件\n   if(ESuccess != fclose(handle)){\n      MO_PERROR(fclose);\n      return EFalse;\n   }\n   return result;\n}</Source>
                  </Method>
                  <Method name="Close" description="关闭文件">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;关闭文件&lt;/T&gt;\n//\n// @return 打开文件成功返回ETrue,失败则返回EFalse\n//============================================================\n\nTBool FFileStream::Close(){\n   if(ESuccess != fclose(_handle)){\n      MO_PERROR(fclose);\n      return EFalse;\n   }\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsFileName" name="_filename"/>
                  <Attribute type="TFileHandle" name="_handle"/>
               </Attributes>
            </Class>
            <Class name="FFileString16">
               <Inherits name="FString16" scope="public"/>
               <Methods>
                  <Constructor name="FFileString16"/>
                  <Constructor name="FFileString16">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FFileString16">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                        <Parameter type="TCharC*" name="pCharSet"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FFileString16"/>
                  <Method name="LoadFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString16::LoadFile(TCharC* pFileName){\n   return LoadFile(pFileName, RCharEncoding::Default);\n}</Source>
                  </Method>
                  <Method name="LoadFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                        <Parameter type="TCharC*" name="pCharSet"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString16::LoadFile(TCharC* pFileName, TCharC* pCharSet){\n   TFileHandle handle;\n#ifdef _WINDOWS\n   fopen_s(&amp;handle, pFileName, &quot;rb&quot;);\n#else\n   handle = fopen(pFileName, &quot;rb&quot;);\n#endif\n   if(NULL == handle){\n      MO_PERROR(fopen);\n      return EFalse;\n   }\n   // 获得长度\n   if(ESuccess != fseek(handle, 0, SEEK_END)){\n      MO_PERROR(fseek);\n      return EFalse;\n   }\n   TInt length = ftell(handle);\n   EnsureSize(length);\n\n   TInt readed;\n   TChar* buffer = RTypeMemory&lt;TChar&gt;::Alloc(length, 0);\n\n   TInt result = MO_LIB_STRICMP(pCharSet, RCharSet::Utf8);\n   if(result == 0){\n      fseek(handle, 3, SEEK_SET);\n      readed = fread(buffer, length - 3, 1, handle);\n      MultiByteToWideChar(CP_UTF8, 0, buffer, length, _pMemory, _length);\n   }else{\n      fseek(handle, 2, SEEK_SET);\n      readed = fread(_pMemory, length - 2, 1, handle);\n   }\n\n   if(1 != readed){\n      MO_PFATAL(fread);\n   }\n\n   if(ESuccess != fseek(handle, 0, SEEK_SET)){\n      MO_PERROR(fseek);\n      return EFalse;\n   }\n   // 关闭文件\n   if(ESuccess != fclose(handle)){\n      MO_PFATAL(fclose);\n   }\n   RTypeMemory&lt;TChar&gt;::Free(buffer);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Store">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString16::Store(){\n   return SaveFile(_fileName.MemoryC());\n}</Source>
                  </Method>
                  <Method name="SaveFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString16::SaveFile(TCharC* pFileName){\n   return SaveFile(pFileName, RCharEncoding::Default);\n}</Source>
                  </Method>
                  <Method name="SaveFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                        <Parameter type="TCharC*" name="pCharSet"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString16::SaveFile(TCharC* pFileName, TCharC* pCharSet){\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsPath" name="_fileName"/>
               </Attributes>
            </Class>
            <Class name="FFileString32">
               <Inherits name="FString32" scope="public"/>
               <Methods>
                  <Constructor name="FFileString32"/>
                  <Constructor name="FFileString32">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FFileString32">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                        <Parameter type="TCharC*" name="pCharSet"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FFileString32"/>
                  <Method name="LoadFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString32::LoadFile(TCharC* pFileName){\n   return LoadFile(pFileName, RCharEncoding::Default);\n}</Source>
                  </Method>
                  <Method name="LoadFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                        <Parameter type="TCharC*" name="pCharSet"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString32::LoadFile(TCharC* pFileName, TCharC* pCharSet){\n   TFileHandle handle;\n#ifdef _WINDOWS\n   fopen_s(&amp;handle, pFileName, &quot;rb&quot;);\n#else\n   handle = fopen(pFileName, &quot;rb&quot;);\n#endif\n   if(NULL == handle){\n      MO_PERROR(fopen);\n      return EFalse;\n   }\n   // 获得长度\n   if(ESuccess != fseek(handle, 0, SEEK_END)){\n      MO_PERROR(fseek);\n      return EFalse;\n   }\n   TInt length = ftell(handle);\n   EnsureSize(length);\n   TInt readed;\n   TUchar8 head[4];\n\n   TChar* buffer = RTypeMemory&lt;TChar&gt;::Alloc(length, 0);\n\n   int result = MO_LIB_STRICMP(pCharSet, RCharSet::Utf32);\n\n   if(result != 0){\n      readed = fread(buffer, length, 1, handle);\n      TChar* pIn = buffer;\n      TChar16* pOut = _pMemory;\n      iconv_t cd;\n      cd = iconv_open(&quot;utf-32&quot;, pCharSet);\n      MO_ASSERT(iconv(cd, &amp;pIn, (TUint*)&amp;length, (TChar**)&amp;pOut, (TUint*)&amp;_length) != -1);\n      iconv_close(cd);\n      _length = length;\n   }else{\n      readed = fread(_pMemory, length, 1, handle);\n      _length = length;\n   }\n\n   if(1 != readed){\n      MO_PFATAL(fread);\n   }\n\n   if(ESuccess != fseek(handle, 0, SEEK_SET)){\n      MO_PERROR(fseek);\n      return EFalse;\n   }\n   // 关闭文件\n   if(ESuccess != fclose(handle)){\n      MO_PFATAL(fclose);\n   }\n   RTypeMemory&lt;TChar&gt;::Free(buffer);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Store">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString32::Store(){\n   return SaveFile(_fileName.MemoryC());\n}</Source>
                  </Method>
                  <Method name="SaveFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString32::SaveFile(TCharC* pFileName){\n   return SaveFile(pFileName, RCharEncoding::Default);\n}</Source>
                  </Method>
                  <Method name="SaveFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                        <Parameter type="TCharC*" name="pCharSet"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString32::SaveFile(TCharC* pFileName, TCharC* pCharSet){\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsPath" name="_fileName"/>
               </Attributes>
            </Class>
            <Class name="FFileString8">
               <Inherits name="FString8" scope="public"/>
               <Methods>
                  <Constructor name="FFileString8"/>
                  <Constructor name="FFileString8">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FFileString8"/>
                  <Method name="LoadFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString8::LoadFile(TCharC* pFileName){\n   // 打开文件\n   TFileHandle handle;\n#ifdef _WINDOWS\n   fopen_s(&amp;handle, pFileName, &quot;rb&quot;);\n#else\n   handle = fopen(pFileName, &quot;rb&quot;);\n#endif\n   if(NULL == handle){\n      MO_PERROR(fopen);\n      return EFalse;\n   }\n   // 获得长度\n   if(ESuccess != fseek(handle, 0, SEEK_END)){\n      MO_PERROR(fseek);\n      return EFalse;\n   }\n   TInt length = ftell(handle);\n   EnsureSize(length);\n   // 从开始位置读取\n   if(ESuccess != fseek(handle, 0, SEEK_SET)){\n      MO_PERROR(fseek);\n      return EFalse;\n   }\n   TInt readed = fread(_pMemory, length, 1, handle);\n   if(1 != readed){\n      MO_PFATAL(fread);\n   }\n   _length = length;\n   // 关闭文件\n   if(ESuccess != fclose(handle)){\n      MO_PFATAL(fclose);\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Store">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString8::Store(){\n   return SaveFile(_fileName.MemoryC());\n}</Source>
                  </Method>
                  <Method name="SaveFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FFileString8::SaveFile(TCharC* pFileName){\n   // 打开文件\n   TFileHandle handle;\n#ifdef _WINDOWS\n   fopen_s(&amp;handle, pFileName, &quot;w+&quot;);\n#else\n   handle = fopen(pFileName, &quot;w+&quot;);\n#endif\n   if(NULL == handle){\n      MO_PERROR(fopen);\n      return EFalse;\n   }\n   // 从开始位置写入\n   if(ESuccess != fseek(handle, 0, SEEK_SET)){\n      MO_PERROR(fseek);\n      return EFalse;\n   }\n   TInt writted = fwrite(_pMemory, _length, 1, handle);\n   if(writted != _length){\n      MO_PFATAL(fwrite);\n   }\n   // 关闭文件\n   if(ESuccess != fclose(handle)){\n      MO_PFATAL(fclose);\n      return EFalse;\n   }\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsPath" name="_fileName"/>
               </Attributes>
            </Class>
            <Class name="FFileStringStream">
               <Inherits name="FBinaryFileStream" scope="public"/>
               <Methods>
                  <Method name="ReadString" description="读取型数据">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="TString"/>
                     <Source>//============================================================\n// &lt;T&gt;读取型数据&lt;/T&gt;\n//\n// @return 返回size长度的数据\n//============================================================\n\nTString FFileStringStream::ReadString(TInt size){\n   TString str;\n   fread(&amp;str, size, 1, _handle);\n   return str;\n}</Source>
                  </Method>
                  <Method name="ReadLine" description="写读取一行数据">
                     <Return type="TString"/>
                     <Source>//============================================================\n// &lt;T&gt;写读取一行数据&lt;/T&gt;\n//\n// @return 返回一行数据\n//============================================================\n\nTString FFileStringStream::ReadLine(){\n   TString str;\n   TChar *buff = NULL;\n   TInt size;\n   size = Length();\n   str = fgets(buff, size, _handle);\n   return str;\n}</Source>
                  </Method>
                  <Method name="WriteString" description="写入数据">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入数据&lt;/T&gt;\n//\n// @param value 要写入的数据\n//============================================================\n\nvoid FFileStringStream::WriteString(const TCharC* value){\n   fwrite(value, strlen(value), 1, _handle);\n}</Source>
                  </Method>
                  <Method name="WriteLine" description="写入一行数据">
                     <Parameters>
                        <Parameter type="TCharC*" name="pLine"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入一行数据&lt;/T&gt;\n//\n// @param line 要写入的数据\n//============================================================\n\nvoid FFileStringStream::WriteLine(const TCharC* line){\n   fwrite(line, strlen(line), 1, _handle);\n   fputs(&quot;\n&quot;, _handle);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FList">
               <Inherits>
                  <Inherit name="MList" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FList" description="构造变长读写链表。"/>
                  <Destructor name="~FList" description="析构变长读写链表。"/>
                  <Method name="EntryCreate" type="inline" description="新建一个节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      return MO_MEM_CREATE(SEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryRelease" type="inline" description="释放一个被使用的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRelease(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      MO_MEM_DELETE(pEntry);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="追加一个链表到当前链表中。">
                     <Parameters>
                        <Parameter type="FList&lt;T&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const FList&lt;T&gt;&amp; list){\n      this-&gt;Assign(list.IteratorC());\n	}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FListener">
               <Methods>
                  <Constructor name="FListener"/>
                  <Destructor name="~FListener"/>
                  <Method name="Owner" flag="override">
                     <Return type="FObject*"/>
                     <Source>//============================================================\n\nFObject* FListener::Owner(){\n   return _pOwner;\n}</Source>
                  </Method>
                  <Method name="Sender" flag="override">
                     <Return type="FObject*"/>
                     <Source>//============================================================\n\nFObject* FListener::Sender(){\n   return _pSender;\n}</Source>
                  </Method>
                  <Method name="Process" flag="override">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FListener::Process(){\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FObject*" name="_pOwner"/>
                  <Attribute type="FObject*" name="_pSender"/>
               </Attributes>
            </Class>
            <Class name="FListeners">
               <Inherits name="FObject" scope="public"/>
               <Methods>
                  <Constructor name="FListeners"/>
                  <Destructor name="~FListeners"/>
                  <Method name="IsEmpty">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FListeners::IsEmpty(){\n   if(NULL != _pListeners){\n      return _pListeners-&gt;IsEmpty();\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Push">
                     <Parameters>
                        <Parameter type="IListener*" name="pListener"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FListeners::Push(IListener* pListener){\n   if(NULL == _pListeners){\n      _pListeners = MO_CREATE(FListenerList);\n   }\n   _pListeners-&gt;Push(pListener);\n}</Source>
                  </Method>
                  <Method name="Clear">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FListeners::Clear(){\n   if(NULL != _pListeners){\n      _pListeners-&gt;Clear();\n   }\n}</Source>
                  </Method>
                  <Method name="Process" flag="abstract">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FListeners::Process(){\n   if(NULL != _pListeners){\n      if(!_pListeners-&gt;IsEmpty()){\n         TListIteratorC&lt;IListener*&gt; iterator = _pListeners-&gt;IteratorC();\n         while(iterator.Next()){\n            iterator-&gt;Process();\n         }\n      }\n   }\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FListenerList*" name="_pListeners"/>
               </Attributes>
            </Class>
            <Class name="FLoggerConsole">
               <Methods>
                  <Constructor name="FLoggerConsole" description="构造日志控制台。"/>
                  <Destructor name="~FLoggerConsole" description="析构日志控制台。"/>
                  <Method name="Format" description="格式化输出信息。">
                     <Parameters>
                        <Parameter type="TFsLogger&amp;" name="result"/>
                        <Parameter type="TLoggerLevel" name="level"/>
                        <Parameter type="TAny*" name="pSender"/>
                        <Parameter type="TCharC*" name="pMethod"/>
                        <Parameter type="TDateTime" name="start"/>
                        <Parameter type="TDateTime" name="current"/>
                        <Parameter type="TCharC*" name="pMessage"/>
                        <Parameter type="va_list" name="params"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;格式化输出信息。&lt;/T&gt;\n//\n// @param result 格式化结果\n// @param level 消息级别\n// @param pSender 发送者\n// @param pMethod 函数名称\n// @param start 开始时间\n// @param current 当前时间\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid FLoggerConsole::Format(TFsLogger&amp; result, TLoggerLevel level, TAny* pSender, TCharC* pMethod, TDateTime start, TDateTime current, TCharC* pMessage, va_list params){\n   // 如果存在开始时间，则先计算花费时间\n   TFsDateTime datetime = current;\n   TTimeSpan span = 0;\n   if(start &gt; 0){\n      span = current - start;\n   }\n   // 格式化日志时间\n   result.Append(datetime.Foramt(_format));\n   result.Append('|');\n   // 格式化日志类型\n   switch(level){\n      case ELoggerLevel_Debug:\n         result.Append('D');\n         break;\n      case ELoggerLevel_Info:\n         result.Append('I');\n         break;\n      case ELoggerLevel_Warn:\n         result.Append('W');\n         break;\n      case ELoggerLevel_Error:\n         result.Append('E');\n         break;\n      case ELoggerLevel_Fatal:\n         result.Append('F');\n         break;\n   }\n   result.Append('.');\n   // 格式化线程信息\n   FThread* pThread = RThreadManager::Instance().Current();\n   if(NULL != pThread){\n      result.Append(pThread-&gt;Code());\n      result.AppendFormat(&quot;-%04d&quot;, pThread-&gt;Index());\n   }else{\n      result.AppendFormat(&quot;%08X&quot;, RThread::CurrentId());\n   }\n   // 格式化函数调用信息\n   result.Append(&quot; [ &quot;);\n   result.Append(pMethod);\n   if(NULL != pSender){\n      result.Append('@');\n      result.AppendFormat(&quot;%08X&quot;, pSender);\n   }\n   if(span &gt; 0){\n      // 显示花费时间，精确到毫秒\n      TFsNumber number;\n      number.AppendFormat(&quot;%d&quot;, span);\n      number.Append(&quot;ms&quot;);\n      result.PadRight(' ', MO_LOGGER_PAD_LENGTH - number.Length());\n      result.Append(number);\n   }else{\n      // 自动对齐\n      result.PadRight(' ', MO_LOGGER_PAD_LENGTH);\n   }\n   result.Append(&quot; ] &quot;);\n   // 格式化可变参数字符串信息\n   TChar message[MO_FS_LOGGER_LENGTH];\n#ifdef _WINDOWS\n   vsprintf_s(message, MO_FS_LOGGER_LENGTH, pMessage, params);\n#else\n   vsnprintf(message, MO_FS_LOGGER_LENGTH, pMessage, params);\n#endif\n   message[MO_FS_LOGGER_LENGTH - 1] = 0;\n   result.Append(message);\n   result.Append(&quot;\n&quot;);\n}</Source>
                  </Method>
                  <Method name="Output" flag="override" description="向外输出信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type"/>
                        <Parameter type="TLoggerLevel" name="level"/>
                        <Parameter type="TAny*" name="pSender"/>
                        <Parameter type="TCharC*" name="pMethod"/>
                        <Parameter type="TDateTime" name="start"/>
                        <Parameter type="TCharC*" name="pMessage"/>
                        <Parameter type="va_list" name="params"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;向外输出信息。&lt;/T&gt;\n//\n// @param level 消息级别\n// @param pSender 发送者\n// @param pMethod 调用函数\n// @param start 开始时间\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid FLoggerConsole::Output(TInt type, TLoggerLevel level, TAny* pSender, TCharC* pMethod, TDateTime start, TCharC* pMessage, va_list params){\n   // 获得函数名称\n   TFsText line = pMethod;\n   TInt left = 0;\n   if(line.StartsWith(&quot;static &quot;)){\n      left = 7;\n   }\n   if(line.StartsWith(&quot;virtual &quot;)){\n      left = 8;\n   }\n   left = MO_MAX(line.IndexOf(' ', left) + 1, 0);\n   TInt right = line.IndexOf('(');\n   if(-1 == right){\n      right = line.Length();\n   }\n   TFsName method = line.SubPtrC(left, right);\n   TInt spaceFlag = method.Find(&quot;MO::&quot;);\n   if(ENotFound != spaceFlag){\n      left = spaceFlag + 4;\n   }else{\n      left = 0;\n   }\n   TFsName name = method.SubPtrC(left, method.Length());\n   // 格式化日志\n   TFsLogger logger;\n   TDateTime current = RDateTime::Current();\n   Format(logger, level, pSender, name.MemoryC(), start, current, pMessage, params);\n   // 输出信息\n#ifdef _WINDOWS\n   OutputDebugString(logger.MemoryC());\n#else\n   printf(&quot;%s&quot;, logger.MemoryC());\n#endif\n   ILoggerWriter* pWriter = _pWriters[type];\n   if(NULL != pWriter){\n      pWriter-&gt;Write(logger, logger.Length());\n   }\n}</Source>
                  </Method>
                  <Method name="Register">
                     <Parameters>
                        <Parameter type="ILoggerWriter*" name="pWriter"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FLoggerConsole::Register(ILoggerWriter* pWriter){\n   TInt index = pWriter-&gt;Code();\n   MO_ASSERT_RANGE(index,0,MO_LOGGER_MAXCODE);\n   if(!pWriter-&gt;Open()){\n      MO_DEBUG(&quot;pWriter:%d open failed&quot;,index);\n      return;\n   }\n   _pWriters[index] = pWriter;\n}</Source>
                  </Method>
                  <Method name="Unregister">
                     <Parameters>
                        <Parameter type="ILoggerWriter*" name="pWriter"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FLoggerConsole::Unregister(ILoggerWriter* pWriter){\n   pWriter-&gt;Close();\n   TInt index = pWriter-&gt;Code();\n   MO_ASSERT_RANGE(index,0,MO_LOGGER_MAXCODE);\n   _pWriters[index] = NULL;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsLabel" name="_format"/>
                  <Attribute type="TThreadSection" name="_section"/>
               </Attributes>
            </Class>
            <Class name="FLoggerWriter">
               <Methods>
                  <Constructor name="FLoggerWriter" description="构造日志构造器对象。"/>
                  <Destructor name="~FLoggerWriter" description="析构日志构造器对象。"/>
                  <Method name="Open" flag="override" description="打开日志写入器。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;打开日志写入器。&lt;/T&gt;\n//\n// @return 日否打开成功。\n//============================================================\n\nTBool FLoggerWriter::Open(){\n   if(!RFile::ExistPath(_path)){\n      MO_DEBUG(&quot;log path(%s) is not exist.&quot;, (TCharC*)_path);\n      return EFalse;\n   }\n   TBool ret = EFalse;\n#ifdef _LINUX\n   TInt logFileCount = 1;\n   TFsDateTime fsDate = RDateTime::Current();\n   TFsName pathPrefix;\n   pathPrefix.Append(_path);\n   pathPrefix.Append(&quot;/&quot;);\n   pathPrefix.Append(_name);\n   pathPrefix.Append(&quot;_&quot;);\n   pathPrefix.Append(fsDate.Foramt(&quot;%y%m%d&quot;));\n   pathPrefix.Append(&quot;_&quot;);\n   TFsName fullName;\n   fullName.Append(pathPrefix);\n   fullName.AppendFormat(&quot;%04d.log&quot;, logFileCount);\n   // 看有无000max\n   if(RFile::ExistFile(fullName)){\n      struct dirent* pDir;\n      DIR* pDirBase = opendir(_path);\n      while(NULL != (pDir = readdir(pDirBase))){\n         if((strcmp(pDir-&gt;d_name, &quot;.&quot;) == 0) || (strcmp(pDir-&gt;d_name,&quot;..&quot;))) {\n            continue;\n         }\n         TInt count = GetCountFromName(pDir-&gt;d_name);\n         if(count &gt; logFileCount){\n            logFileCount = count;\n         }\n      }\n\n      fullName.Clear();\n      fullName.Append(pathPrefix);\n      fullName.AppendFormat(&quot;%04d.log&quot;, logFileCount);\n      struct stat st;\n      if(stat(fullName.MemoryC(),&amp;st)){\n         MO_ERROR(&quot;Stat file:%s failed, errno:%d.&quot;, fullName.MemoryC(), errno);\n         return EFalse;\n      }else{\n         if(st.st_size &gt;= _capacity){ //写满\n            logFileCount++;\n            fullName.Clear();\n            fullName.Append(pathPrefix);\n            fullName.AppendFormat(&quot;%04d.log&quot;, logFileCount);\n         }\n      }\n   }\n   ret = _pStream-&gt;OpenAppend(fullName.MemoryC());\n#endif\n   return ret;\n}</Source>
                  </Method>
                  <Method name="Create" flag="override" description="创建一个新的日志文件。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;创建一个新的日志文件。&lt;/T&gt;\n//\n// @return 是否创建成功。\n//============================================================\n\nTBool FLoggerWriter::Create(){\n   TInt count = GetCountFromName(_pStream-&gt;FileName());\n   count++;\n   TFsDateTime fsDate = RDateTime::Current();\n   TFsName fullName;\n   fullName.Append(_path);\n   fullName.Append(&quot;/&quot;);\n   fullName.Append(_name);\n   fullName.Append(&quot;_&quot;);\n   fullName.Append(fsDate.Foramt(&quot;%y%m%d&quot;));\n   fullName.Append(&quot;_&quot;);\n   fullName.AppendFormat(&quot;%04d.log&quot;, count);\n   _pStream-&gt;Close();\n   _pStream-&gt;Open(fullName);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Code" flag="override" description="获得日志写入器的编号。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得日志写入器的编号。&lt;/T&gt;\n//\n// @return 日志写入器的编号。\n//============================================================\n\nTInt FLoggerWriter::Code(){\n   return _code;\n}</Source>
                  </Method>
                  <Method name="Write" flag="override" description="将一个消息记录到日志中。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pMessage"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;将一个消息记录到日志中。&lt;/T&gt;\n//\n// @param TCharC* pMessage 消息的内容。\n// @param TSize length 消息的长度。\n// @return 是否记录成功。\n//============================================================\n\nTBool FLoggerWriter::Write(TCharC* pMessage, TSize length){\n   TSize curSize = _pStream-&gt;Length();\n   if(curSize + length &gt; _capacity){\n      Create();\n   }\n   if(length == _pStream-&gt;Write(pMessage,length)){\n      return ETrue;\n   }\n   return EFalse;\n}</Source>
                  </Method>
                  <Method name="Close" flag="override" description="关闭日志写入器。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;关闭日志写入器。&lt;/T&gt;\n//\n// @return 关闭是否成功。\n//============================================================\n\nTBool FLoggerWriter::Close(){\n  return _pStream-&gt;Close();\n}</Source>
                  </Method>
                  <Method name="GetCountFromName" description="获得日志文件的编号。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得日志文件的编号。&lt;/T&gt;\n//\n// @param TCharC* pName  日志文件的文件名。\n// @return 日志文件的编号。\n//============================================================\n\nTInt FLoggerWriter::GetCountFromName(TCharC* pName){\n   TInt count = -1;\n   TFsName name = pName;\n   TInt offset1 = name.LastIndexOf('_');\n   TInt offset2 = name.LastIndexOf('.');\n   if(ENotFound != offset1 &amp;&amp; offset2 &gt; offset1){\n      TFsName mid = name.SubPtrC(offset1 + 1, offset2);\n      count = atoi(mid);\n   }\n   return count;\n}</Source>
                  </Method>
                  <Method name="SetCode" description="设置日志写入器的标号。">
                     <Parameters>
                        <Parameter type="TInt" name="code"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置日志写入器的标号。&lt;/T&gt;\n//\n// @param TInt code 要设置的编号。\n//============================================================\n\nvoid FLoggerWriter::SetCode(TInt code){\n   _code = code;\n}</Source>
                  </Method>
                  <Method name="SetName" description="设置日志写入器的对应文件名。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置日志写入器的对应文件名。&lt;/T&gt;\n//\n// @param TCharC* pName 写入日志的文件名。\n//============================================================\n\nvoid FLoggerWriter::SetName(TCharC* pName){\n   _name.Assign(pName);\n}</Source>
                  </Method>
                  <Method name="SetPath" description="设置日志文件目录。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pPath"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置日志文件目录。&lt;/T&gt;\n//\n// @param TCharC* pPath 日志文件存放的目录。\n//============================================================\n\nvoid FLoggerWriter::SetPath(TCharC* pPath){\n   _path.Assign(pPath);\n}</Source>
                  </Method>
                  <Method name="SetCapacity" description="设置日志文件的最大大小。">
                     <Parameters>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置日志文件的最大大小。&lt;/T&gt;\n//\n// @param TSize capacity 文件的大小。\n//============================================================\n\nvoid FLoggerWriter::SetCapacity(TSize capacity){\n   _capacity = capacity;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_code"/>
                  <Attribute type="TSize" name="_capacity"/>
                  <Attribute type="TFsName" name="_name"/>
                  <Attribute type="TFsPath" name="_path"/>
                  <Attribute type="FFileStream*" name="_pStream"/>
               </Attributes>
            </Class>
            <Class name="FLuaContext">
               <Methods>
                  <Constructor name="FLuaContext"/>
                  <Destructor name="~FLuaContext"/>
                  <Method name="LoadFile">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FLuaContext::LoadFile(TCharC* pFileName){\n   //luaL_loadfile(_pHandle, pFileName);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FMap">
               <Inherits>
                  <Inherit name="MMap" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FMap" description="构造哈希表对象。"/>
                  <Constructor name="FMap" description="构造哈希表对象。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FMap" description="构造哈希表对象。">
                     <Parameters>
                        <Parameter type="MMapC&lt;N, V&gt;&amp;" name="map"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FMap" description="析构哈希表对象。"/>
                  <Method name="EntryCreate" type="inline" description="新建一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      EnsureSize(this-&gt;_count + 1);\n      return MO_MEM_CREATE(SEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryRelease" type="inline" description="释放一个指定的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRelease(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      MO_MEM_DELETE(pEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatCreate" type="inline" description="收集节点列表内存。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="SEntry**"/>
                     <Source>\ninline SEntry** EntryFlatCreate(TInt size){\n      return RTypeMemory&lt;SEntry*&gt;::Alloc(size, NULL);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatRelease" type="inline" description="释放节点列表内存。">
                     <Parameters>
                        <Parameter type="SEntry**" name="pEntries"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFlatRelease(SEntry** pEntries){\n      MO_ASSERT(pEntries);\n      RTypeMemory&lt;SEntry*&gt;::Free(pEntries);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="复制内容到对象内部。">
                     <Parameters>
                        <Parameter type="MMapC&lt;N, V&gt;&amp;" name="map"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MMapC&lt;N, V&gt;&amp; map){\n      this-&gt;Assign(&amp;map);\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保当前对象可以容纳指定大小的数据。" note="当哈希表是旧表的8倍时开始扩充，扩大2倍。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if(NULL == this-&gt;_ppEntries) {\n         this-&gt;_entryCount = MO_MAX(size, MO_OBJECT_CAPACITY);\n         // 第一次新建时，生成哈希表\n         this-&gt;_ppEntries = EntryFlatCreate(this-&gt;_entryCount);\n      } else if (size &gt; (this-&gt;_entryCount &lt;&lt; 3)) {\n         // 扩充内存时处理\n         size = this-&gt;_entryCount + (MO_MAX(this-&gt;_entryCount, size) &gt;&gt; 1);\n         // 当总数大于节点列表长度8倍时，重新扩充节点列表\n         SEntry** ppEntries = EntryFlatCreate(size);\n         EntriesResize(ppEntries, size);\n         // 释放旧节点内存\n         EntryFlatRelease(this-&gt;_ppEntries);\n         // 保存新的节点列表\n         this-&gt;_ppEntries = ppEntries;\n         this-&gt;_entryCount = size;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FMemoryAllocator">
               <Inherits>
                  <Inherit name="IAllocator" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FMemoryAllocator" description="构造块内存实例。"/>
                  <Destructor name="~FMemoryAllocator" description="析构块内存实例。"/>
                  <Method name="EntryExtend" description="扩展原子内存。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;扩展原子内存。&lt;/T&gt;\n// &lt;P&gt;收集内存的第一块为收集链表，第二块开始为前部分为块信息，后部分为数据区。&lt;/P&gt;\n//\n// @param pEntry 内存原子实例\n//============================================================\n\nvoid FMemoryAllocator::EntryExtend(){\n   // 计算要收集的个数\n   TInt atomSize = sizeof(SMemoryEntry);\n   // TODO: TInt pageSize = getpagesize();\n   TInt pageSize = 8192;\n   TInt count = MO_MAX(pageSize / atomSize, MO_OBJECT_CAPACITY);\n   // 扩展内存\n   TUint allocSize = sizeof(SMemoryEntry) + atomSize * count;\n   TByte* pMemory = (TByte*)MO_ALIGNED_ALLOC(allocSize, sizeof(TInt));\n   MO_ASSERT(pMemory);\n   memset(pMemory, 0, allocSize);\n   // 保存第一块内存区\n   SMemoryEntry* pAllocAtom = (SMemoryEntry*)pMemory;\n   pAllocAtom-&gt;pMemory = pMemory;\n   // 压入已收集区\n   if(NULL != _pAlloc){\n      _pAlloc-&gt;pPrior = pAllocAtom;\n   }\n   pAllocAtom-&gt;pNext = _pAlloc;\n   _pAlloc = pAllocAtom;\n   // 初始化所有内存原子\n   pMemory += sizeof(SMemoryEntry);\n   TInt n = -1;\n   while(++n &lt; count){\n      // 链初始化\n      SMemoryEntry* pEntry = (SMemoryEntry*)pMemory;\n      pEntry-&gt;pAllocator = this;\n      pMemory += atomSize;\n      // 压入未使用的队列\n      if(NULL != _pUnused){\n         _pUnused-&gt;pPrior = pEntry;\n      }\n      pEntry-&gt;pNext = _pUnused;\n      _pUnused = pEntry;\n   }\n}</Source>
                  </Method>
                  <Method name="EntryAlloc" description="收集一个内存原子实例。">
                     <Return type="SMemoryEntry*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一个内存原子实例。&lt;/T&gt;\n//\n// @return 内存原子实例\n//============================================================\n\nSMemoryEntry* FMemoryAllocator::EntryAlloc(){\n   // 如果没有可使用的内存，则扩展缓冲区\n   if(NULL == _pUnused){\n      EntryExtend();\n   }\n   // 获得一个可用的类型内存\n   SMemoryEntry* pEntry = _pUnused;\n   _pUnused = pEntry-&gt;pNext;\n   // 压入使用中的队列\n   //EntryPush(pEntry);\n   // 记录收集操作\n   pEntry-&gt;Alloc();\n   // 返回收集的内存\n   return pEntry;\n}</Source>
                  </Method>
                  <Method name="Alloc" flag="override" description="收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TUint" name="size" default="0"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param size 内存大小\n// @return 内存指针\n//============================================================\n\nTAny* FMemoryAllocator::Alloc(TUint size){\n   MO_ASSERT(size &gt; 0);\n   SMemoryEntry* pEntry = EntryAlloc();\n   MO_ASSERT(pEntry);\n   TByte* pMemory = (TByte*)MO_ALIGNED_ALLOC(size, sizeof(TInt));\n   pEntry-&gt;Link(pMemory, size);\n   return pEntry-&gt;pMemory;\n}</Source>
                  </Method>
                  <Method name="Alloc" flag="override" description="收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pTypeName"/>
                        <Parameter type="TUint" name="size"/>
                        <Parameter type="TChar8C*" name="pFileName"/>
                        <Parameter type="TInt" name="fileLine"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param pTypeName 类型名称\n// @param size 内存大小\n// @param pFileName 文件名称\n// @param fileLine 文件行数\n// @return 内存指针\n//============================================================\n\nTAny* FMemoryAllocator::Alloc(TCharC* pTypeName, TUint size, TChar8C* pFileName, TInt fileLine){\n   MO_ASSERT(size &gt; 0);\n   SMemoryEntry* pEntry = EntryAlloc();\n   MO_ASSERT(pEntry);\n   TByte* pMemory = (TByte*)MO_ALIGNED_ALLOC(size, sizeof(TInt));\n   pEntry-&gt;SetTypeName(pTypeName);\n   pEntry-&gt;SetFileInfo(pFileName, fileLine);\n   pEntry-&gt;Link(pMemory, size);\n   return pEntry-&gt;pMemory;\n}</Source>
                  </Method>
                  <Method name="Free" flag="override" description="释放内存。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放内存。&lt;/T&gt;\n//\n// @param pMemory 内存指针\n//============================================================\n\nvoid FMemoryAllocator::Free(TAny* pMemory){\n   // 获得当前使用的实例\n   MO_ASSERT(pMemory);\n   TInt* pAlloc = ((TInt*)pMemory) - 1;\n   SMemoryEntry* pEntry = (SMemoryEntry*)pAlloc[0];\n   MO_ASSERT(pEntry);\n   // 检查内存转换正确性\n   MO_ASSERT(pEntry-&gt;pAllocator == this);\n   MO_ASSERT(pEntry-&gt;pMemory == pMemory);\n   // 释放内存\n   MO_ALIGNED_FREE(pEntry-&gt;pAlloc);\n   // 记录释放操作\n   pEntry-&gt;Free();\n   // 压入未使用的队列\n   //MLinkedEntryC&lt;SMemoryEntry*&gt;::EntryFree(pEntry);\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SMemoryEntry*" name="_pAlloc"/>
                  <Attribute type="SMemoryEntry*" name="_pFirst"/>
                  <Attribute type="SMemoryEntry*" name="_pLast"/>
                  <Attribute type="SMemoryEntry*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="FMemoryLockAllocator">
               <Inherits name="FMemoryAllocator" scope="public"/>
               <Methods>
                  <Constructor name="FMemoryLockAllocator"/>
                  <Destructor name="~FMemoryLockAllocator"/>
                  <Method name="Alloc" flag="override" description="收集一块定长的内存。">
                     <Parameters>
                        <Parameter type="TUint" name="size" default="0"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块定长的内存。&lt;/T&gt;\n//\n// @param size 内存大小\n// @return 内存指针\n//============================================================\n\nTAny* FMemoryLockAllocator::Alloc(TUint size){\n   MO_ASSERT(size &gt; 0);\n   _section.Enter();\n   TAny* pMemory = FMemoryAllocator::Alloc(size);\n   _section.Leave();\n   return pMemory;\n}</Source>
                  </Method>
                  <Method name="Alloc" flag="override" description="收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pTypeName"/>
                        <Parameter type="TUint" name="size"/>
                        <Parameter type="TChar8C*" name="pFileName"/>
                        <Parameter type="TInt" name="fileLine"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param pTypeName 类型名称\n// @param size 内存大小\n// @param pFileName 文件名称\n// @param line 文件行数\n// @return 内存指针\n//============================================================\n\nTAny* FMemoryLockAllocator::Alloc(TCharC* pTypeName, TUint size, TChar8C* pFileName, TInt fileLine){\n   _section.Enter();\n   TAny* pMemory = FMemoryAllocator::Alloc(pTypeName, size, pFileName, fileLine);\n   _section.Leave();\n   return pMemory;\n}</Source>
                  </Method>
                  <Method name="Free" flag="override" description="释放内存。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放内存。&lt;/T&gt;\n//\n// @param pMemory 内存指针\n//============================================================\n\nvoid FMemoryLockAllocator::Free(TAny* pMemory){\n   _section.Enter();\n   FMemoryAllocator::Free(pMemory);\n   _section.Leave();\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TThreadSection" name="_section"/>
               </Attributes>
            </Class>
            <Class name="FModuleConsole">
               <Methods>
                  <Method name="Construct">
                     <Return type="PPtr"/>
                     <Source>//============================================================\n\nPPtr FModuleConsole::Construct(){\n   _pModules = MO_CREATE(FModuleList);\n   return this;\n}</Source>
                  </Method>
                  <Method name="Dispose">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FModuleConsole::Dispose(){\n   MO_DELETE(_pModules);\n}</Source>
                  </Method>
                  <Method name="Register">
                     <Parameters>
                        <Parameter type="IModule*" name="pModule"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FModuleConsole::Register(IModule* pModule){\n   _pModules-&gt;Push(pModule)\n}</Source>
                  </Method>
                  <Method name="Unregister">
                     <Parameters>
                        <Parameter type="IModule*" name="pModule"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FModuleConsole::Unregister(IModule* pModule){\n   _pModules-&gt;Remove(pModule)\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FMonitorConsole">
               <Inherits>
                  <Inherit name="MConsole" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FMonitorConsole" description="获得线程标识。"/>
                  <Destructor name="~FMonitorConsole"/>
                  <Method name="Machine">
                     <Return type="FMonitorMachine*"/>
                     <Source>//============================================================\n\nFMonitorMachine* FMonitorConsole::Machine(){\n   return _pMachine;\n}</Source>
                  </Method>
                  <Method name="Interval">
                     <Return type="TTimeSpan"/>
                  </Method>
                  <Method name="SetInterval">
                     <Parameters>
                        <Parameter type="TTimeSpan" name="interval"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Register">
                     <Parameters>
                        <Parameter type="IMonitor*" name="pMonitor"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FMonitorConsole::Register(IMonitor* pMonitor){\n   _pMachine-&gt;Register(pMonitor);\n}</Source>
                  </Method>
                  <Method name="Unregister">
                     <Parameters>
                        <Parameter type="IMonitor*" name="pMonitor"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FMonitorConsole::Unregister(IMonitor* pMonitor){\n   _pMachine-&gt;Unregister(pMonitor);\n}</Source>
                  </Method>
                  <Method name="Startup">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FMonitorConsole::Startup(){\n   // 启动处理机\n   _pMachine-&gt;Startup();\n   // 启动监听线程\n   _pThread = MO_CREATE(FMonitorThread, _pMachine);\n   _pThread-&gt;Start();\n}</Source>
                  </Method>
                  <Method name="Shutdown">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FMonitorConsole::Shutdown(){\n   MO_ASSERT(_pThread);\n   _pThread-&gt;Stop();\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TThreadSection" name="_section"/>
                  <Attribute type="FMonitorThread*" name="_pThread"/>
                  <Attribute type="FMonitorMachine*" name="_pMachine"/>
               </Attributes>
            </Class>
            <Class name="FMonitorMachine">
               <Inherits name="FObject" scope="public"/>
               <Methods>
                  <Constructor name="FMonitorMachine" description="获得线程标识。"/>
                  <Destructor name="~FMonitorMachine"/>
                  <Method name="Interval">
                     <Return type="TTimeSpan"/>
                     <Source>//============================================================\n\nTTimeSpan FMonitorMachine::Interval(){\n   return _interval;\n}</Source>
                  </Method>
                  <Method name="SetInterval">
                     <Parameters>
                        <Parameter type="TTimeSpan" name="interval"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FMonitorMachine::SetInterval(TTimeSpan interval){\n   _interval = interval;\n}</Source>
                  </Method>
                  <Method name="FindByName">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="IMonitor*"/>
                     <Source>//============================================================\n\nIMonitor* FMonitorMachine::FindByName(TCharC* pName){\n   TListIteratorC&lt;IMonitor*&gt; iterator = _pMonitors-&gt;IteratorC();\n   while(iterator.Next()){\n      if(iterator-&gt;IsName(pName)){\n         return *iterator;\n      }\n   }\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="Register">
                     <Parameters>
                        <Parameter type="IMonitor*" name="pMonitor"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FMonitorMachine::Register(IMonitor* pMonitor){\n   _pMonitors-&gt;Push(pMonitor);\n}</Source>
                  </Method>
                  <Method name="Unregister">
                     <Parameters>
                        <Parameter type="IMonitor*" name="pMonitor"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FMonitorMachine::Unregister(IMonitor* pMonitor){\n   _pMonitors-&gt;Remove(pMonitor);\n}</Source>
                  </Method>
                  <Method name="LoadConfig">
                     <Parameters>
                        <Parameter type="FXmlNode*" name="pConfig"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FMonitorMachine::LoadConfig(FXmlNode* pConfig){\n   TXmlNodeIteratorC iterator = pConfig-&gt;NodeIteratorC();\n   while(iterator.Next()){\n      if(iterator-&gt;IsName(&quot;Monitor&quot;)){\n         TCharC* pName = iterator-&gt;Get(&quot;name&quot;);\n         MO_ASSERT(pName);\n         IMonitor* pMonitor = FindByName(pName);\n         if(NULL != pMonitor){\n            pMonitor-&gt;LoadConfig(*iterator);\n         }\n      }\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Startup">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FMonitorMachine::Startup(){\n   _lastDateTime = RDateTime::Current();\n}</Source>
                  </Method>
                  <Method name="Process">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FMonitorMachine::Process(){\n   TDateTime currentTime = RDateTime::Current();\n   TTimeSpan span = currentTime - _lastDateTime;\n   TListIteratorC&lt;IMonitor*&gt; iterator = _pMonitors-&gt;IteratorC();\n   while(iterator.Next()){\n      if(iterator-&gt;Test(span)){\n         iterator-&gt;Process();\n      }\n   }\n   _lastDateTime = currentTime;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TTimeSpan" name="_interval"/>
                  <Attribute type="FMonitorList*" name="_pMonitors"/>
                  <Attribute type="TDateTime" name="_lastDateTime"/>
               </Attributes>
            </Class>
            <Class name="FMonitorThread">
               <Inherits name="FThread" scope="public"/>
               <Methods>
                  <Constructor name="FMonitorThread">
                     <Parameters>
                        <Parameter type="FMonitorMachine*" name="pMachine"/>
                     </Parameters>
                  </Constructor>
                  <Method name="Process" flag="override">
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FMonitorThread::Process(){\n   while(!_stop){\n      _pMachine-&gt;Process();\n      TTimeSpan interval = _pMachine-&gt;Interval();\n#ifdef _WINDOWS\n      ::Sleep((TUint32)interval);\n#else\n      usleep(interval);\n#endif\n   }\n   return ESuccess;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FMonitorMachine*" name="_pMachine"/>
               </Attributes>
            </Class>
            <Class name="FNcAttributes">
               <Inherits>
                  <Inherit name="MNcAttributes" scope="public"/>
               </Inherits>
            </Class>
            <Class name="FNcDictionary">
               <Inherits>
                  <Inherit name="MNcDictionary" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FNcDictionary" description="创建字典对象。"/>
                  <Constructor name="FNcDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FNcDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="MDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FNcDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="FDictionary&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FNcDictionary" description="释放字典对象。"/>
                  <Method name="operator=" description="接收另一个字典对象的全部数据。">
                     <Parameters>
                        <Parameter type="MNcDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MNcDictionaryC&lt;T&gt;&amp; dictionary){\n      this-&gt;Assign(dictionary);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="接收另一个字典对象的全部数据。">
                     <Parameters>
                        <Parameter type="FNcDictionary&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const FNcDictionary&lt;T&gt;&amp; dictionary){\n      this-&gt;Assign(dictionary);\n   }</Source>
                  </Method>
                  <Method name="EntryCreate" type="inline" description="新建一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      EnsureSize(this-&gt;_count + 1);\n      return MO_CREATE(SEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryRelease" type="inline" description="释放一个指定的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRelease(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      MO_DELETE(pEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatCreate" type="inline" description="收集节点列表内存。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="SEntry**"/>
                     <Source>\ninline SEntry** EntryFlatCreate(TInt size){\n      return RTypeMemory&lt;SEntry*&gt;::Alloc(size, NULL);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatRelease" type="inline" description="释放节点列表内存。">
                     <Parameters>
                        <Parameter type="SEntry**" name="pEntries"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFlatRelease(SEntry** pEntries){\n      MO_ASSERT(pEntries);\n      RTypeMemory&lt;SEntry*&gt;::Free(pEntries);\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保当前对象可以容纳指定大小的数据。" note="当哈希表是旧表的8倍时开始扩充，扩大2倍。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if(NULL == this-&gt;_ppEntries) {\n         this-&gt;_entryCount = MO_MAX(size, MO_OBJECT_CAPACITY);\n         // 第一次新建时，生成哈希表\n         this-&gt;_ppEntries = EntryFlatCreate(this-&gt;_entryCount);\n      } else if (size &gt; (this-&gt;_entryCount &lt;&lt; 3)) {\n         // 扩充内存时处理\n         size = this-&gt;_entryCount + (MO_MAX(this-&gt;_entryCount, size) &gt;&gt; 1);\n         // 当总数大于节点列表长度8倍时，重新扩充节点列表\n         SEntry** ppEntries = EntryFlatCreate(size);\n         EntriesResize(ppEntries, size);\n         // 释放旧节点内存\n         EntryFlatRelease(this-&gt;_ppEntries);\n         // 保存新的节点列表\n         this-&gt;_ppEntries = ppEntries;\n         this-&gt;_entryCount = size;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FNetClientSocket">
               <Inherits>
                  <Inherit name="MNetSocket" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FNetClientSocket" description="构造客户网路端口。"/>
                  <Constructor name="FNetClientSocket" description="构造客户网路端口。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pHost"/>
                        <Parameter type="TInt" name="port" description="端口"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FNetClientSocket" description="析构客户网路端口。"/>
                  <Method name="Info" flag="override">
                     <Return type="SNetSocketInfo*"/>
                     <Source>//============================================================\n\nSNetSocketInfo* FNetClientSocket::Info(){\n   return &amp;_info;\n}</Source>
                  </Method>
                  <Method name="Connect" description="链接指定服务器。">
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;链接指定服务器。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool FNetClientSocket::Connect(){\n   // 创建链接\n   TSocket handle = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n   if(INVALID_SOCKET == handle){\n      MO_PERROR(socket);\n      return EFalse;\n   }\n   // 绑定链接\n   sockaddr_in address;\n   address.sin_family = AF_INET;\n   address.sin_port = htons(_info.port);\n   address.sin_addr.s_addr = inet_addr(_host.MemoryC());\n   memset(address.sin_zero, 0, sizeof(address.sin_zero));\n   if(ESuccess != connect(handle, (struct sockaddr*)&amp;address, sizeof(sockaddr_in))){\n      MO_ERROR(&quot;Connect socket error. (host=%s, port=%d)&quot;, _host.MemoryC(), _info.port);\n      MO_PERROR(connect);\n      // 关闭已经打开的链接句柄\n#ifdef _WINDOWS\n      if(ESuccess != closesocket(handle)){\n         MO_PERROR(closesocket);\n      }\n#else\n      if(ESuccess != close(handle)){\n         MO_PERROR(close);\n      }\n#endif\n      return EFalse;\n   }\n   _info.handle = handle;\n   _isConnected = ETrue;\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Connect">
                     <Parameters>
                        <Parameter type="TCharC*" name="pHost"/>
                        <Parameter type="TUint16" name="port"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FNetClientSocket::Connect(TCharC* pHost, TUint16 port){\n   SetHost(pHost);\n   SetPort(port);\n   return Connect();\n}</Source>
                  </Method>
                  <Method name="Disconnect" description="断开链接。">
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;断开链接。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool FNetClientSocket::Disconnect(){\n   if(INVALID_SOCKET == _info.handle){\n#ifdef _WINDOWS\n      closesocket(_info.handle);\n#else\n      close(_info.handle);\n#endif\n      _info.handle = INVALID_SOCKET;\n      return ETrue;\n   }\n   return EFalse;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SNetSocketInfo" name="_info"/>
               </Attributes>
            </Class>
            <Class name="FNetEpoll">
               <Methods>
                  <Constructor name="FNetEpoll" description="构造EPOLL端口池。"/>
                  <Destructor name="~FNetEpoll" description="析构EPOLL端口池。"/>
                  <Method name="Handle" flag="override" description="获得句柄。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得句柄。&lt;/T&gt;\n//\n// @return 句柄\n//============================================================\n\nTInt FNetEpoll::Handle(){\n   return _handle;\n}</Source>
                  </Method>
                  <Method name="Add" flag="override" description="增加网络句柄的设置。">
                     <Parameters>
                        <Parameter type="INetSocket*" name="pSocket"/>
                        <Parameter type="TUint" name="flag"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;增加网络句柄的设置。&lt;/T&gt;\n//\n// @param pSocket 网络端口\n// @param flag 标志\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool FNetEpoll::Add(INetSocket* pSocket, TUint flag){\n   MO_ASSERT(pSocket);\n#ifdef _LINUX\n   TInt handle = pSocket-&gt;Handle();\n   epoll_event event;\n   event.events = flag;\n   event.data.fd = handle;\n   TInt result = epoll_ctl(_handle, EPOLL_CTL_ADD, handle, &amp;event);\n   if(EError == result){\n      MO_PERROR(epoll_ctl);\n      return EFalse;\n   }\n#endif\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Modify" flag="override" description="修改网络句柄的设置。">
                     <Parameters>
                        <Parameter type="INetSocket*" name="pSocket"/>
                        <Parameter type="TUint" name="flag"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;修改网络句柄的设置。&lt;/T&gt;\n//\n// @param pSocket 网络端口\n// @param flag 标志\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool FNetEpoll::Modify(INetSocket* pSocket, TUint flag){\n   MO_ASSERT(pSocket);\n#ifdef _LINUX\n   TUint16 handle = pSocket-&gt;Handle();\n   epoll_event event;\n   event.events = flag;\n   event.data.fd = handle;\n   TInt result = epoll_ctl(_handle, EPOLL_CTL_MOD, handle, &amp;event);\n   if(EError == result){\n      MO_PERROR(epoll_ctl);\n      return EFalse;\n   }\n#endif\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Remove" flag="override" description="删除网络句柄的设置。">
                     <Parameters>
                        <Parameter type="INetSocket*" name="pSocket"/>
                        <Parameter type="TUint" name="flag"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;删除网络句柄的设置。&lt;/T&gt;\n//\n// @param pSocket 网络端口\n// @param flag 标志\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool FNetEpoll::Remove(INetSocket* pSocket, TUint flag){\n   MO_ASSERT(pSocket);\n#ifdef _LINUX\n   TUint16 handle = pSocket-&gt;Handle();\n   epoll_event event;\n   event.events = flag;\n   event.data.fd = handle;\n   TInt result = epoll_ctl(_handle, EPOLL_CTL_DEL, handle, &amp;event);\n   if(EError == result){\n      MO_PERROR(epoll_ctl);\n      return EFalse;\n   }\n#endif\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Create" description="创建完成端口。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;创建完成端口。&lt;/T&gt;\n//\n// @param size 处理大小\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool FNetEpoll::Create(TInt size){\n#ifdef _LINUX\n   _processSize = size;\n   _handle = epoll_create(size);\n   if(EError == _handle){\n      MO_PERROR(epoll_create);\n      return EFalse;\n   }\n#endif\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_processSize"/>
                  <Attribute type="TInt" name="_timeout"/>
                  <Attribute type="TInt" name="_handle"/>
                  <Attribute type="epoll_event*" name="pEvents"/>
               </Attributes>
            </Class>
            <Class name="FNetEpollConnection">
               <Inherits>
                  <Inherit name="INetConnection" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FNetEpollConnection" description="构造EPOLL网络链接。"/>
                  <Destructor name="~FNetEpollConnection" description="析构EPOLL网络链接。"/>
                  <Method name="PollSize" description="获得端口池大小。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得端口池大小。&lt;/T&gt;\n//\n// @return 端口池大小\n//============================================================\n\nTInt FNetEpollConnection::PollSize(){\n   return _pollSize;\n}</Source>
                  </Method>
                  <Method name="SetPollSize" description="设置端口池大小。">
                     <Parameters>
                        <Parameter type="TInt" name="pollSize"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置端口池大小。&lt;/T&gt;\n//\n// @param pollSize 端口池大小\n//============================================================\n\nvoid FNetEpollConnection::SetPollSize(TInt pollSize){\n   _pollSize = pollSize;\n}</Source>
                  </Method>
                  <Method name="ReceivePool" description="获得接收端口池。">
                     <Return type="FNetEpoll*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得接收端口池。&lt;/T&gt;\n//\n// @return 接收端口池\n//============================================================\n\nFNetEpoll* FNetEpollConnection::ReceivePool(){\n   return _pReceiveEpool;\n}</Source>
                  </Method>
                  <Method name="SendPool" description="获得发送端口池。">
                     <Return type="FNetEpoll*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得发送端口池。&lt;/T&gt;\n//\n// @return 发送端口池\n//============================================================\n\nFNetEpoll* FNetEpollConnection::SendPool(){\n   return _pSendEpool;\n}</Source>
                  </Method>
                  <Method name="ServerThreads" description="获得服务线程组。">
                     <Return type="FThreadGroup*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得服务线程组。&lt;/T&gt;\n//\n// @return 服务线程组\n//============================================================\n\nFThreadGroup* FNetEpollConnection::ServerThreads(){\n   return _pServerThreads;\n}</Source>
                  </Method>
                  <Method name="QueryThread" description="获得查询线程。">
                     <Return type="FNetEpollQueryThread*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得查询线程。&lt;/T&gt;\n//\n// @return 查询线程\n//============================================================\n\nFNetEpollQueryThread* FNetEpollConnection::QueryThread(){\n   return _pQueryThread;\n}</Source>
                  </Method>
                  <Method name="ProcessThreads" description="获得处理线程组。">
                     <Return type="FThreadGroup*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得处理线程组。&lt;/T&gt;\n//\n// @return 处理线程组\n//============================================================\n\nFThreadGroup* FNetEpollConnection::ProcessThreads(){\n   return _pProcessThreads;\n}</Source>
                  </Method>
                  <Method name="SendThread" description="获得发送线程。">
                     <Return type="FNetEpollSendThread*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得发送线程。&lt;/T&gt;\n//\n// @return 发送线程\n//============================================================\n\nFNetEpollSendThread* FNetEpollConnection::SendThread(){\n   return _pSendThread;\n}</Source>
                  </Method>
                  <Method name="SetSocketStorage">
                     <Parameters>
                        <Parameter type="FNetSocketStorage*" name="pStorage"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FNetEpollConnection::SetSocketStorage(FNetSocketStorage* pStorage){\n   _pSocketStorage = pStorage;\n}</Source>
                  </Method>
                  <Method name="SocketStorage" flag="override" description="获得端口集合。">
                     <Return type="FNetSocketStorage*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得端口集合。&lt;/T&gt;\n//\n// @return 端口集合\n//============================================================\n\nFNetSocketStorage* FNetEpollConnection::SocketStorage(){\n   return _pSocketStorage;\n}</Source>
                  </Method>
                  <Method name="Start" flag="override" description="启动网络链接。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;启动网络链接。&lt;/T&gt;\n//============================================================\n\nvoid FNetEpollConnection::Start(){\n   // 创建接收端口池\n   _pReceiveEpool = MO_CREATE(FNetEpoll);\n   _pReceiveEpool-&gt;Create(_pollSize);\n   // 创建发送端口池\n   _pSendEpool = MO_CREATE(FNetEpoll);\n   _pSendEpool-&gt;Create(_pollSize);\n   // 创建查询线程\n   _pQueryThread = MO_CREATE(FNetEpollQueryThread, this);\n   _pQueryThread-&gt;Start();\n   // 创建处理线程\n   for(TInt n=0; n&lt;MO_NET_PROCESS_COUNT; n++){\n      FNetEpollProcessThread* pProcessThread = MO_CREATE(FNetEpollProcessThread, this);\n      _pProcessThreads-&gt;Push(pProcessThread);\n      pProcessThread-&gt;Start();\n   }\n   // 创建发送线程\n   _pSendThread = MO_CREATE(FNetEpollSendThread, this);\n   _pSendThread-&gt;Start();\n}</Source>
                  </Method>
                  <Method name="Stop" flag="override" description="停止服务。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;停止服务。&lt;/T&gt;\n//============================================================\n\nvoid FNetEpollConnection::Stop(){\n}</Source>
                  </Method>
                  <Method name="Listen" description="监听网络端口。">
                     <Parameters>
                        <Parameter type="TInt" name="port"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;监听网络端口。&lt;/T&gt;\n//\n// @param port 端口\n//============================================================\n\nvoid FNetEpollConnection::Listen(TInt port){\n   // 创建服务端口\n   FNetServerSocket* pServerSocket = MO_CREATE(FNetServerSocket);\n   pServerSocket-&gt;SetConnection(this);\n   pServerSocket-&gt;SetPort(port);\n   pServerSocket-&gt;Connect();\n   // 创建服务端口处理线程\n   FNetEpollServerThread* pServerThread = MO_CREATE(FNetEpollServerThread, this);\n   pServerThread-&gt;SetServerSocket(pServerSocket);\n   _pServerThreads-&gt;Push(pServerThread);\n   // 启动服务线程\n   pServerThread-&gt;Start();\n}</Source>
                  </Method>
                  <Method name="Accept" description="接收一个网络端口。">
                     <Parameters>
                        <Parameter type="INetSocket*" name="pSocket"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;接收一个网络端口。&lt;/T&gt;\n//\n// @param pSocket 网络端口\n//============================================================\n\nvoid FNetEpollConnection::Accept(INetSocket* pSocket){\n#ifdef _LINUX\n   pSocket-&gt;SetNonBlock();\n   pSocket-&gt;SetReceiveBufferSize(MO_NET_BLOCK_SIZE);\n   _pReceiveEpool-&gt;Add(pSocket, EPOLLIN | EPOLLERR | EPOLLHUP | EPOLLET);\n   _pSendEpool-&gt;Add(pSocket, EPOLLOUT | EPOLLET);\n#endif\n}</Source>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="INetSocket*" name="pSocket"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FNetEpollConnection::Remove(INetSocket* pSocket){\n   _pReceiveEpool-&gt;Remove(pSocket, 0);\n   _pSendEpool-&gt;Remove(pSocket, 0);\n   pSocket-&gt;Close();\n}</Source>
                  </Method>
                  <Method name="Connect" description="链接一个远程主机。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pHost"/>
                        <Parameter type="TInt" name="port"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;链接一个远程主机。&lt;/T&gt;\n//\n// @param host 主机名称\n// @param port 端口\n//============================================================\n\nvoid FNetEpollConnection::Connect(TCharC* pHost, TInt port){\n   //  FNetClientSocket* pSocket = (FNetClientSocket*)_pSocketAllocator-&gt;ClientSocketAlloc();\n   //pSocket-&gt;SetConnection(this);\n   //pSocket-&gt;SetHost(pHost);\n   //pSocket-&gt;SetPort(port);\n   //if(pSocket-&gt;Connect()){\n      //Accept(pSocket);\n   //}\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TThreadSection" name="_section"/>
                  <Attribute type="TInt" name="_pollSize"/>
                  <Attribute type="FNetEpoll*" name="_pReceiveEpool"/>
                  <Attribute type="FNetEpoll*" name="_pSendEpool"/>
                  <Attribute type="FThreadGroup*" name="_pServerThreads"/>
                  <Attribute type="FNetEpollQueryThread*" name="_pQueryThread"/>
                  <Attribute type="FThreadGroup*" name="_pProcessThreads"/>
                  <Attribute type="FNetEpollSendThread*" name="_pSendThread"/>
                  <Attribute type="FNetSocketStorage*" name="_pSocketStorage"/>
               </Attributes>
            </Class>
            <Class name="FNetEpollProcessThread">
               <Inherits name="FThread" scope="public"/>
               <Methods>
                  <Constructor name="FNetEpollProcessThread" description="构造EPOLL处理线程。">
                     <Parameters>
                        <Parameter type="INetConnection*" name="pConnection" description="网络链接"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FNetEpollProcessThread" description="构造EPOLL处理线程。"/>
                  <Method name="Process" flag="override" description="处理线程。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;处理线程。&lt;/T&gt;\n//\n// @return 处理结果\n//============================================================\n\nTInt FNetEpollProcessThread::Process(){\n   TInt count = 0;\n   /*SNetSocketEvent* pFirst = NULL;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FNetEpollConnection*" name="_pNetConnection"/>
               </Attributes>
            </Class>
            <Class name="FNetEpollQueryThread">
               <Inherits name="FThread" scope="public"/>
               <Methods>
                  <Constructor name="FNetEpollQueryThread" description="构造EPOLL查询线程。">
                     <Parameters>
                        <Parameter type="INetConnection*" name="pConnection" description="网络链接"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FNetEpollQueryThread"/>
                  <Method name="ProcessReceive">
                     <Parameters>
                        <Parameter type="INetSocket*" name="pSocket"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FNetEpollQueryThread::ProcessReceive(INetSocket* pSocket){\n   TInt total = 0;\n   TInt readed = 0;\n   while(ETrue){\n      // 读取缓冲数据(有长度为0的情况)\n      /*readed = recv(pSocket-&gt;Handle(), _pEvent-&gt;pData, MO_NET_BLOCK_SIZE, 0);\n   return total;\n}</Source>
                  </Method>
                  <Method name="ProcessClientClose">
                     <Parameters>
                        <Parameter type="INetSocket*" name="pSocket"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FNetEpollQueryThread::ProcessClientClose(INetSocket* pSocket){\n   MO_NET_DEBUG(&quot;Client socket closed. (socket=0x%08X)&quot;, pSocket);\n   _pNetConnection-&gt;Remove(pSocket);\n   //_pNetConnection-&gt;SocketFree(pSocket);\n   return ESuccess;\n}</Source>
                  </Method>
                  <Method name="Process" flag="override" description="线程处理。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;线程处理。&lt;/T&gt;\n//\n// @return 处理结果\n//============================================================\n\nTInt FNetEpollQueryThread::Process(){\n#ifdef _LINUX\n   struct epoll_event events[MO_EPOLL_QUERY_COUNT];\n   _pSocketPool = _pNetConnection-&gt;ReceivePool();\n   TInt handle = _pSocketPool-&gt;Handle();\n   MO_NET_DEBUG(&quot;Epoll query process begin. (handle=0x%08X)&quot;, handle);\n   // 循环处理\n   while(!_stop){\n      TInt count = epoll_wait(handle, events, MO_EPOLL_QUERY_COUNT, 0);\n      if(EError == count){\n         // 处理错误\n         MO_PERROR(epoll_wait);\n      }else if(count &gt; 0){\n         MO_NET_DEBUG(&quot;Epoll query events. (count=%d)&quot;, count);\n         // 处理所有事件数据\n         TInt n = -1;\n         while(++n &lt; count){\n            epoll_event&amp; event = events[n];\n            MO_NET_DEBUG(&quot;Epoll event raise. (event=0x%08X)&quot;, event.events);\n            FNetSocket* pSocket = (FNetSocket*)event.data.ptr;\n            // 错误处理\n            if(EPOLLERR &amp; event.events){\n               ProcessClientClose(pSocket);\n            }\n            // 客户端关闭处理\n            if(EPOLLHUP &amp; event.events){\n               ProcessClientClose(pSocket);\n            }\n            // 收到数据处理\n            if(EPOLLIN &amp; event.events){\n               TInt readed = ProcessReceive(pSocket);\n               if(0 == readed){\n                  // 客户端已经关闭\n                  ProcessClientClose(pSocket);\n               }\n            }\n         }\n         // 写入所有事件\n         //_pEventWriter-&gt;Flush();\n         TUint used, total;\n         //TUint max = 1024L * 1024L * 1024L * 2L;\n         TUint max = 1024L * 1024L * 256L * 2L;\n         RAllocator::CalculateStatistics(used, total);\n         if(total &gt; max){\n            MO_THROW(&quot;Memory too large.&quot;);\n         }\n      }else{\n         usleep(MO_EPOLL_QUERY_INTERVAL);\n      }\n   }\n   MO_NET_DEBUG(&quot;Epoll query process end. (handle=0x%08X)&quot;, handle);\n#endif\n   return ESuccess;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FNetEpollConnection*" name="_pNetConnection"/>
                  <Attribute type="FNetEpoll*" name="_pSocketPool"/>
               </Attributes>
            </Class>
            <Class name="FNetEpollSendThread">
               <Inherits name="FThread" scope="public"/>
               <Methods>
                  <Constructor name="FNetEpollSendThread" description="构造EPOLL发送线程。">
                     <Parameters>
                        <Parameter type="INetConnection*" name="pNetConnection"/>
                     </Parameters>
                  </Constructor>
                  <Method name="Process" flag="override" description="处理线程。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;处理线程。&lt;/T&gt;\n//\n// @return 处理结果\n//============================================================\n\nTInt FNetEpollSendThread::Process(){\n#ifdef _LINUX\n   struct epoll_event events[MO_EPOLL_SEND_COUNT];\n   FNetEpoll* pEpoll = _pNetConnection-&gt;SendPool();\n   TInt handle = pEpoll-&gt;Handle();\n   MO_DEBUG(&quot;Epoll query process begin. (handle=0x%08X)&quot;, handle);\n   // 循环处理\n   while(!_stop){\n      TInt count = epoll_wait(handle, events, MO_EPOLL_SEND_COUNT, MO_EPOLL_SEND_INTERVAL);\n      // 设置可写标志\n      if(count &gt; 0){\n         // 处理所有事件\n         TInt n = -1;\n         while(++n &lt; count){\n            epoll_event&amp; event = events[n];\n            FNetSocket* pSocket = (FNetSocket*)event.data.ptr;\n            if(EPOLLOUT &amp; event.events){\n               //pSocket-&gt;SetWriteAble(ETrue);\n            }\n         }\n      }\n      // 处理前操作\n      //_pDataProcessor-&gt;DoSendBegin();\n      // 发送操作\n      if(EError == count){\n         // 处理错误\n         MO_PERROR(epoll_wait);\n      }else if(count &gt; 0){\n         // 处理所有事件\n         TInt n = -1;\n         TInt processCount = 0;\n         while(++n &lt; count){\n            epoll_event&amp; event = events[n];\n            FNetSocket* pSocket = (FNetSocket*)event.data.ptr;\n            // TODO: 系统要对每个端口做超时检查\n            if(EPOLLOUT &amp; event.events){\n               //if(pSocket-&gt;IsWriteAble()){\n               //   if(_pDataProcessor-&gt;DoSend(pSocket)){\n               //      processCount++;\n               //   }\n               //}\n            }\n         }\n         // 如果一个数据没有处理的话，线程睡眠一会儿\n         if(processCount &gt; 0){\n            MO_NET_DEBUG(&quot;Epoll process send socket. (count=%d, process=%d)&quot;, count, processCount);\n         }\n      }\n      // 处理后操作\n      //_pDataProcessor-&gt;DoSendEnd();\n   }\n   MO_DEBUG(&quot;Epoll query process end. (handle=0x%08X)&quot;, handle);\n#endif\n   return ESuccess;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FNetEpollConnection*" name="_pNetConnection"/>
               </Attributes>
            </Class>
            <Class name="FNetEpollServerThread">
               <Inherits name="FThread" scope="public"/>
               <Methods>
                  <Constructor name="FNetEpollServerThread" description="构造EPOLL服务线程。">
                     <Parameters>
                        <Parameter type="INetConnection*" name="pConnection" description="网络链接"/>
                     </Parameters>
                  </Constructor>
                  <Method name="ServerSocket" description="获得服务端口。">
                     <Return type="FNetServerSocket*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得服务端口。&lt;/T&gt;\n//\n// @return 服务端口\n//============================================================\n\nFNetServerSocket* FNetEpollServerThread::ServerSocket(){\n   return _pServerSocket;\n}</Source>
                  </Method>
                  <Method name="SetServerSocket" description="设置服务端口。">
                     <Parameters>
                        <Parameter type="FNetServerSocket*" name="pServerSocket"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置服务端口。&lt;/T&gt;\n//\n// @param pServerSocket 服务端口\n//============================================================\n\nvoid FNetEpollServerThread::SetServerSocket(FNetServerSocket* pServerSocket){\n   _pServerSocket = pServerSocket;\n}</Source>
                  </Method>
                  <Method name="Process" flag="override" description="线程处理。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;线程处理。&lt;/T&gt;\n//\n// @param 处理结果\n//============================================================\n\nTInt FNetEpollServerThread::Process(){\n#ifdef _LINUX\n   // 预先收集一个端口\n   /*INetSocket* pSocket = _pNetConnection-&gt;SocketAlloc();\n   return ESuccess;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FNetEpollConnection*" name="_pNetConnection"/>
                  <Attribute type="FNetServerSocket*" name="_pServerSocket"/>
               </Attributes>
            </Class>
            <Class name="FNetServerSocket">
               <Inherits>
                  <Inherit name="MNetSocket" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FNetServerSocket" description="构造服务网路端口。"/>
                  <Constructor name="FNetServerSocket" description="构造服务网路端口。">
                     <Parameters>
                        <Parameter type="TInt" name="port" description="端口"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FNetServerSocket" description="析构服务网络链接。"/>
                  <Method name="Info" flag="override">
                     <Return type="SNetSocketInfo*"/>
                     <Source>//============================================================\n\nSNetSocketInfo* FNetServerSocket::Info(){\n   return &amp;_info;\n}</Source>
                  </Method>
                  <Method name="Bind" description="绑定服务端口。">
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;绑定服务端口。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool FNetServerSocket::Bind(){\n   // 创建链接\n   _info.handle = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n   if(INVALID_SOCKET == _info.handle){\n      MO_PERROR(socket);\n      return EFalse;\n   }\n   // 绑定链接\n   sockaddr_in address;\n   address.sin_family = AF_INET;\n   address.sin_addr.s_addr = htonl(INADDR_ANY);\n   address.sin_port = htons(_info.port);\n   memset(address.sin_zero, 0, sizeof(address.sin_zero));\n   TInt result = bind(_info.handle, (struct sockaddr*)&amp;address, sizeof(sockaddr_in));\n   if(SOCKET_ERROR == result){\n      MO_ERROR(&quot;Server socket bind failure. (host=%s, port=%d)&quot;, _host.MemoryC(), _info.port);\n      MO_PFATAL(socket);\n      return EFalse;\n   }\n   MO_DEBUG(&quot;Server socket bind success. (host=%s, port=%d)&quot;, _host.MemoryC(), _info.port);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Listen" description="监听服务端口。">
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;监听服务端口。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool FNetServerSocket::Listen(){\n   TInt result = listen(_info.handle, SOMAXCONN);\n   if(SOCKET_ERROR == result){\n      MO_PERROR(socket);\n      return EFalse;\n   }\n   MO_DEBUG(&quot;Server socket listen success. (host=%s, port=%d)&quot;, _host.MemoryC(), _info.port);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Connect" description="链接服务。">
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;链接服务。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool FNetServerSocket::Connect(){\n   TBool result = EFalse;\n   if(Bind()){\n      result = Listen();\n   }\n   return result;\n}</Source>
                  </Method>
                  <Method name="Accept" description="接收客户链接。">
                     <Parameters>
                        <Parameter type="SNetSocketInfo&amp;" name="info"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;接收客户链接。&lt;/T&gt;\n//\n// @return 客户链接\n//============================================================\n\nTBool FNetServerSocket::Accept(SNetSocketInfo&amp; info){\n   sockaddr_in address;\n#ifdef _WINDOWS\n   TInt size = sizeof(struct sockaddr_in);\n   TSocket socket = accept(_info.handle, (struct sockaddr*)&amp;address, &amp;size);\n#else\n   TUint32 size = sizeof(struct sockaddr_in);\n   TSocket socket = accept(_info.handle, (struct sockaddr*)&amp;address, &amp;size);\n#endif\n   if(SOCKET_ERROR != socket){\n      info.handle = socket;\n      info.port = address.sin_port;\n#ifdef _WINDOWS\n      strcpy_s(info.host, sizeof(info.host), inet_ntoa(address.sin_addr));\n#else\n      strcpy(info.host, inet_ntoa(address.sin_addr));\n#endif\n      info.sourceIp = address.sin_addr.s_addr;\n      return ETrue;\n   }\n   return EFalse;\n}</Source>
                  </Method>
                  <Method name="Disconnect" description="断开服务。">
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;断开服务。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool FNetServerSocket::Disconnect(){\n   return Close();\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SNetSocketInfo" name="_info"/>
               </Attributes>
            </Class>
            <Class name="FNetSocket">
               <Inherits>
                  <Inherit name="MNetSocket" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FNetSocket" description="构造网路端口。"/>
                  <Constructor name="FNetSocket" description="构造网路端口。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pHost"/>
                        <Parameter type="TInt" name="port" description="端口"/>
                        <Parameter type="TSocket" name="handle" description="句柄"/>
                     </Parameters>
                  </Constructor>
                  <Method name="Info" flag="override">
                     <Return type="SNetSocketInfo*"/>
                     <Source>//============================================================\n\nSNetSocketInfo* FNetSocket::Info(){\n   return &amp;_info;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SNetSocketInfo" name="_info"/>
               </Attributes>
            </Class>
            <Class name="FNetSocketStorage">
               <Inherits name="FAtomStorage" scope="public"/>
               <Methods>
                  <Constructor name="FNetSocketStorage" description="构造网路端口。"/>
                  <Destructor name="~FNetSocketStorage"/>
                  <Method name="AtomCreate" flag="override">
                     <Return type="INetSocket*"/>
                     <Source>//============================================================\n\nINetSocket* FNetSocketStorage::AtomCreate(){\n   FNetSocket* pSocket = NULL;\n   _section.Enter();\n   pSocket = MO_CREATE(FNetSocket);\n   _section.Leave();\n   return pSocket;\n}</Source>
                  </Method>
                  <Method name="AtomDelete" flag="override">
                     <Parameters>
                        <Parameter type="INetSocket*" name="pSocket"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FNetSocketStorage::AtomDelete(INetSocket* pSocket){\n   _section.Enter();\n   MO_DELETE(pSocket);\n   _section.Leave();\n}</Source>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TSocket" name="handle"/>
                     </Parameters>
                     <Return type="INetSocket*"/>
                     <Source>//============================================================\n\nINetSocket* FNetSocketStorage::Get(TSocket handle){\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TSocket" name="handle"/>
                     </Parameters>
                     <Return type="INetSocket*"/>
                     <Source>//============================================================\n\nINetSocket* FNetSocketStorage::Find(TSocket handle){\n   return NULL;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FObject">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FObject" description="构造基本对象。"/>
                  <Destructor name="~FObject" description="析构基本对象。"/>
                  <Method name="HashCode" flag="abstract" description="获得类借口。获得哈希值。">
                     <Return type="THashCode"/>
                     <Source>//============================================================\n// &lt;T&gt;获得类借口。&lt;/T&gt;\n//\n// @return 类借口\n//============================================================\n//IClass* MObject::GetClass() const{\n//   return NULL;\n//}\n\n//============================================================\n// &lt;T&gt;获得哈希值。&lt;/T&gt;\n//\n// @return 哈希值\n//============================================================\n\nTHashCode FObject::HashCode() const{\n   return (THashCode)this;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FPipe">
               <Inherits>
                  <Inherit name="MPipe" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FPipe" description="构造数据管道对象。"/>
                  <Constructor name="FPipe">
                     <Parameters>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FPipe" description="构造数据管道对象。">
                     <Parameters>
                        <Parameter type="TByte*" name="pMemory" description="内存指针"/>
                        <Parameter type="TSize" name="capacity" description="最大容量"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FPipe"/>
                  <Method name="Info" flag="override">
                     <Return type="SPipeInfo*"/>
                     <Source>//============================================================\n\nSPipeInfo* FPipe::Info(){\n   return &amp;_info;\n}</Source>
                  </Method>
                  <Method name="InnerGetInfo" flag="override">
                     <Parameters>
                        <Parameter type="TByte**" name="ppMemory"/>
                        <Parameter type="TUint32&amp;" name="capacity"/>
                        <Parameter type="TUint32&amp;" name="length"/>
                        <Parameter type="TUint32&amp;" name="first"/>
                        <Parameter type="TUint32&amp;" name="last"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FPipe::InnerGetInfo(TByte** ppMemory, TUint32&amp; capacity, TUint32&amp; length, TUint32&amp; first, TUint32&amp; last){\n   *ppMemory = _pMemory;\n   capacity = _info.capacity;\n   first = _info.first;\n   last = _info.last;\n   length = (first &lt;= last) ? last - first : (capacity - first) + last;\n}</Source>
                  </Method>
                  <Method name="Length" flag="override" description="获得管道以被占用长度。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得管道以被占用长度。&lt;/T&gt;\n//\n// @return 被占用长度。\n//============================================================\n\nTInt FPipe::Length(){\n   TInt first = _info.first;\n   TInt last = _info.last;\n   TInt length = (first &lt;= last) ? last - first : (_info.capacity - first) + last;\n   return length;\n}</Source>
                  </Method>
                  <Method name="Reamin" flag="override" description="获得管道以剩余的长度。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得管道以剩余的长度。&lt;/T&gt;\n//\n// @return 剩余的长度\n//============================================================\n\nTInt FPipe::Reamin(){\n   TInt first = _info.first;\n   TInt last = _info.last;\n   TInt length = (first &lt;= last) ? last - first : (_info.capacity - first) + last;\n   return _info.capacity - length - MO_PIPE_RESERVE_LENGTH;\n}</Source>
                  </Method>
                  <Method name="Reset" description="重置管道空间。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n//&lt;T&gt;重置管道空间。&lt;/T&gt;\n//============================================================\n\nTBool FPipe::Reset(){\n   memset(&amp;_info, 0, sizeof(SPipeInfo));\n   _pMemory = NULL;\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TBool" name="_linked"/>
                  <Attribute type="SPipeInfo" name="_info"/>
                  <Attribute type="TByte*" name="_pMemory"/>
               </Attributes>
            </Class>
            <Class name="FProperties16">
               <Inherits>
                  <Inherit name="MProperties16" scope="public"/>
               </Inherits>
            </Class>
            <Class name="FProperties32">
               <Inherits>
                  <Inherit name="MProperties32" scope="public"/>
               </Inherits>
            </Class>
            <Class name="FProperties8">
               <Inherits>
                  <Inherit name="MProperties8" scope="public"/>
               </Inherits>
            </Class>
            <Class name="FQueue">
               <Inherits name="FPipe" scope="public"/>
               <Methods>
                  <Constructor name="FQueue"/>
                  <Constructor name="FQueue">
                     <Parameters>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FQueue">
                     <Parameters>
                        <Parameter type="TByte*" name="pMemory"/>
                        <Parameter type=":" name="FPipe(pMemory"/>
                        <Parameter type="pMemory," name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FQueue"/>
                  <Method name="Push" description="将一个完整信息写入管道。">
                     <Parameters>
                        <Parameter type="TAnyC*" name="pData"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;将一个完整信息写入管道。&lt;/T&gt;\n// &lt;P&gt;数据可以被分成两端放入管道的尾部和首部。&lt;/P&gt;\n//    写入的数据块长度计算在写入内容内。\n// &lt;/P&gt;\n//============================================================\n\nTBool FQueue::Push(TAnyC* pData, TSize capacity){\n   MO_ASSERT(pData);\n   // 获取变量\n   TByte* pMemory;\n   TUint32 total, length, first, last;\n   InnerGetInfo(&amp;pMemory, total, length, first, last);\n   // 判断是否可以写入\n   if(capacity &gt; (total - length - MO_PIPE_RESERVE_LENGTH)){\n      return EFalse;\n   }\n   TSize size = *(TSize*)pData;\n   if(size != capacity){\n      MO_FATAL(&quot;Push data invalid. (size=%d, capacity=%d, length=%d, first=%d, last=%d)&quot;,\n            size, capacity, length, first, last);\n   }\n   // 处理一次写入数据 [---F===L----] | [===L---F====]\n   TUint32 moved = (first &lt; last) ? MO_MIN(capacity, total - last) : capacity;\n   memcpy(pMemory + last, pData, moved);\n   last += moved;\n   // 处理二次写入数据\n   if(capacity &gt; moved){\n      last = capacity - moved;\n      memcpy(pMemory, (TByte*)pData + moved, last);\n   }\n   // 存储变量\n   _info.last = last;\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Pop">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FQueue::Pop(TAny* pData, TSize capacity){\n   MO_ASSERT(pData);\n   // 获取变量\n   TByte* pMemory;\n   TUint32 total, length, first, last;\n   InnerGetInfo(&amp;pMemory, total, length, first, last);\n   // 判断是否可以读出\n   if(length &lt; sizeof(TInt)){\n      return 0;\n   }\n   TUint32 size = *(TUint32*)(pMemory + first);\n   if(0 == size){\n      MO_FATAL(&quot;Pop data length is 0. (size=%d, length=%d, first=%d, last=%d)&quot;,\n            size, length, first, last);\n   }\n   if((size &gt; capacity) || (size &gt; length)){\n      return 0;\n   }\n   // 处理一次读出数据 [---F===L----] | [===L---F====]\n   TUint32 moved = (first &lt; last) ? size : MO_MIN(size, total - first);\n   memcpy(pData, pMemory + first, moved);\n   // 处理二次读出数据\n   if(size &gt; moved){\n      memcpy((TByte*)pData + moved, pMemory, size - moved);\n      first = size - moved;\n   }else{\n      first += moved;\n   }\n   // 存储变量\n   _info.first = first;\n   return size;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FRow">
               <Inherits name="FObject" scope="public"/>
               <Methods>
                  <Constructor name="FRow">
                     <Parameters>
                        <Parameter type="FDataset*" name="pDataset"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FRow"/>
                  <Method name="operator[]">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="MStringPtrC&amp;"/>
                     <Source>//============================================================\n\nconst MStringPtrC&amp; FRow::operator[](TInt index){\n   return Get(index);\n}</Source>
                  </Method>
                  <Method name="operator[]">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="MStringPtrC&amp;"/>
                     <Source>//============================================================\n\nconst MStringPtrC&amp; FRow::operator[](const MStringPtrC&amp; name){\n   return Get(name);\n}</Source>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="MStringPtrC&amp;"/>
                     <Source>//============================================================\n\nconst MStringPtrC&amp; FRow::Get(TInt index){\n   FString* pValue = _pValues-&gt;Get(index);\n   return *pValue;\n}</Source>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="MStringPtrC&amp;"/>
                     <Source>//============================================================\n\nconst MStringPtrC&amp; FRow::Get(const MStringPtrC&amp; name){\n   FString* pValue = _pValues-&gt;Get(1);\n   return *pValue;\n}</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FRow::Set(TInt index, TCharC* pValue){\n}</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="MStringPtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FRow::Set(TInt index, const MStringPtrC&amp; value){\n}</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                        <Parameter type="MStringPtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FRow::Set(const MStringPtrC&amp; name, const MStringPtrC&amp; value){\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FDataset*" name="_pDataset"/>
                  <Attribute type="FStringArray*" name="_pValues"/>
               </Attributes>
            </Class>
            <Class name="FSet">
               <Inherits>
                  <Inherit name="MSet" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FSet" description="构造集合对象。"/>
                  <Constructor name="FSet" description="构造集合对象。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FSet" description="构造集合对象。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="set"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FSet" description="析构集合对象。"/>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      MSet&lt;FSet&lt;N, V&gt;, N, V&gt;::InnerInitialize();\n      // 第一次新建时，生成哈希表\n      this-&gt;_entryCount = MO_MAX(size, MO_OBJECT_CAPACITY);\n      this-&gt;_ppEntries = RTypeMemory&lt;SEntry*&gt;::Alloc(this-&gt;_entryCount, NULL);\n      this-&gt;_pUnused = NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryCreate" type="inline" description="新建一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      EnsureSize(this-&gt;_count + 1);\n      return MO_MEM_CREATE(SEntry);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="复制内容到对象内部。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="set"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MSetC&lt;N, V&gt;&amp; set){\n      this-&gt;Assign(&amp;set);\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保当前对象可以容纳指定大小的数据。" note="当哈希表是旧表的8倍时开始扩充，扩大2倍。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if (size &gt; (this-&gt;_entryCount &lt;&lt; 3)) {\n         // 扩充内存时处理\n         size = this-&gt;_entryCount + (MO_MAX(this-&gt;_entryCount, size) &gt;&gt; 1);\n         // 当总数大于节点列表长度8倍时，重新扩充节点列表\n         SEntry** ppEntries = RTypeMemory&lt;SEntry*&gt;::Alloc(size, NULL);\n         EntriesResize(ppEntries, size);\n         // 释放旧节点内存\n         RTypeMemory&lt;SEntry*&gt;::Free(this-&gt;_ppEntries);\n         // 保存新的节点列表\n         this-&gt;_ppEntries = ppEntries;\n         this-&gt;_entryCount = size;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FShareMemory">
               <Methods>
                  <Constructor name="FShareMemory" description="构造一块共享内存对象。"/>
                  <Constructor name="FShareMemory" description="构造一块共享内存对象。直接链接共享内存使用。">
                     <Parameters>
                        <Parameter type="TShareKey" name="key" description="共享内存键值"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FShareMemory" description="构造一块共享内存对象。如果存在，大小相同则直接使用。如果大小不同，则创建新共享内存使用。">
                     <Parameters>
                        <Parameter type="TShareKey" name="key" description="共享内存键值"/>
                        <Parameter type="TSize" name="size" description="内存大小"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FShareMemory" description="释放一块共享内存对象。"/>
                  <Method name="IsLinked" flag="override">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FShareMemory::IsLinked(){\n   return _linked;\n}</Source>
                  </Method>
                  <Method name="Create" flag="override" description="创建一块指定大小的共享内存。">
                     <Parameters>
                        <Parameter type="TShareKey" name="key"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;创建一块指定大小的共享内存。&lt;/T&gt;\n//\n// @param key 共享内存键值\n// @param capacity 内存大小\n// @return 是否成功\n//============================================================\n\nTBool FShareMemory::Create(TShareKey key, TSize capacity){\n   _linked = ETrue;\n   _key = key;\n   _pMemory = (TByte*)RShareMemory::Create(key, capacity);\n   _created = ETrue;\n   _capacity = capacity;\n   _position = 0;\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="TryCreate" flag="override" description="尝试创建一块共享内存。">
                     <Parameters>
                        <Parameter type="TShareKey" name="key"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;尝试创建一块共享内存。&lt;/T&gt;\n//\n// @param key 共享内存键值\n// @param capacity 内存大小\n// @return 是否成功\n//============================================================\n\nTBool FShareMemory::TryCreate(TShareKey key, TSize capacity){\n   _linked = ETrue;\n   _key = key;\n   _pMemory = (TByte*)RShareMemory::TryCreate(key, capacity, _created);\n   _capacity = capacity;\n   _position = 0;\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Connect" flag="override" description="链接一块共享内存。">
                     <Parameters>
                        <Parameter type="TShareKey" name="key"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;链接一块共享内存。&lt;/T&gt;\n//\n// @param key 共享内存键值\n// @return 是否成功\n//============================================================\n\nTBool FShareMemory::Connect(TShareKey key){\n   SShareMemoryInfo info;\n   // 获取共享段信息\n   if(!RShareMemory::FetchInfo(key, info)){\n      return EFalse;\n   }\n   _linked = ETrue;\n   _key = key;\n   _pMemory = (TByte*)RShareMemory::Connect(key);\n   _created = EFalse;\n   _capacity = info.size;\n   _position = 0;\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="MemoryC" flag="override" description="获得共享内存指针。">
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得共享内存指针。&lt;/T&gt;\n//\n// @return 共享内存指针\n//============================================================\n\nTAny* FShareMemory::MemoryC(){\n   return _pMemory;\n}</Source>
                  </Method>
                  <Method name="Alloc" flag="override" description="从共享内存中收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;从共享内存中收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param size 内存大小\n// @return 共享内存\n//============================================================\n\nTAny* FShareMemory::Alloc(TSize size){\n   TByte* pMemory = _pMemory + _position;\n   _position += size;\n   return pMemory;\n}</Source>
                  </Method>
                  <Method name="Skip" flag="override" description="从共享内存中跳过一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;从共享内存中跳过一块指定大小的内存。&lt;/T&gt;\n//\n// @param size 内存大小\n// @return 是否成功\n//============================================================\n\nTBool FShareMemory::Skip(TSize size){\n   _position += size;\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="CreateSegment" flag="override" description="在当前共享内存段内，分配新的共享内存段。">
                     <Parameters>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TShareSegment"/>
                     <Source>//============================================================\n// &lt;T&gt;在当前共享内存段内，分配新的共享内存段。&lt;/T&gt;\n//\n// @param size 大小\n// @return 共享内存段\n//============================================================\n\nTShareSegment FShareMemory::CreateSegment(TSize size){\n   TShareSegment segment;\n   segment.Initialize(_pMemory + _position, size, _created);\n   _position += size;\n   return segment;\n}</Source>
                  </Method>
                  <Method name="Free" flag="override" description="释放一块共享内存对象。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;释放一块共享内存对象。&lt;/T&gt;\n//\n// @return 是否成功\n//============================================================\n\nTBool FShareMemory::Free(){\n   // 初始化数据\n   _key = 0;\n   _created = EFalse;\n   _capacity = 0;\n   _position = 0;\n   // 释放共享内存\n   if(NULL != _pMemory){\n      RShareMemory::Free(_key);\n      _pMemory = NULL;\n      return ETrue;\n   }\n   return EFalse;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TBool" name="_linked"/>
                  <Attribute type="TShareKey" name="_key"/>
                  <Attribute type="TByte*" name="_pMemory"/>
                  <Attribute type="TBool" name="_created"/>
                  <Attribute type="TInt" name="_capacity"/>
                  <Attribute type="TInt" name="_position"/>
               </Attributes>
            </Class>
            <Class name="FShared">
               <Inherits name="FObject" scope="public"/>
               <Methods>
                  <Constructor name="FShared" description="构造共享对象的实例。"/>
                  <Method name="OnSharedInitialize" flag="abstract" description="共享内存初始化。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;共享内存初始化。&lt;/T&gt;\n//============================================================\n\nvoid FShared::OnSharedInitialize(){\n}</Source>
                  </Method>
                  <Method name="OnSharedResume" flag="abstract" description="使用已有的共享内存。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;使用已有的共享内存。&lt;/T&gt;\n//============================================================\n\nvoid FShared::OnSharedResume(){\n}</Source>
                  </Method>
                  <Method name="OnSharedLink" flag="virtual">
                     <Parameters>
                        <Parameter type="TShareSegment&amp;" name="segment"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="SharedMemory" description="获得共享内存指针。">
                     <Return type="TByte*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得共享内存指针。&lt;/T&gt;\n//\n// @return 内存指针\n//============================================================\n\nTByte* FShared::SharedMemory(){\n   return _gMemory;\n}</Source>
                  </Method>
                  <Method name="SharedCapacity" flag="virtual">
                     <Return type="TSize"/>
                  </Method>
                  <Method name="SharedLink" flag="abstract" description="关联所需的内存。">
                     <Parameters>
                        <Parameter type="TShareSegment" name="segment"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;关联所需的内存。&lt;/T&gt;\n// &lt;P&gt;内存是新建的时候，初始化共享内存。&lt;/P&gt;\n//\n// @param segment 所需内存\n//============================================================\n\nvoid FShared::SharedLink(TShareSegment segment){\n   // 设置内存指针\n   _gMemory = (TByte*)segment.MemoryC();\n   // 分配内存\n   OnSharedLink(segment);\n   // 检查内存\n   segment.Check();\n   if(segment.IsCreated()){\n      // 共享内存初始化\n      OnSharedInitialize();\n   }else{\n      // 共享内存链接\n      OnSharedResume();\n   }\n}</Source>
                  </Method>
                  <Method name="DumpShared" flag="abstract">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FShared::DumpShared(){\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_sharedId"/>
                  <Attribute type="TByte*" name="_gMemory"/>
               </Attributes>
            </Class>
            <Class name="FSharedConsole">
               <Inherits>
                  <Inherit name="MConsole" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FSharedConsole"/>
                  <Destructor name="~FSharedConsole"/>
                  <Method name="SharedCapacity">
                     <Return type="TSize"/>
                     <Source>//============================================================\n\nTSize FSharedConsole::SharedCapacity(){\n   TListIteratorC&lt;ISingleton*&gt; iterator = RSingletonManager::Instance().Singletons()-&gt;IteratorC();\n   TSize total = 0;\n   while(iterator.Next()){\n      /*if(ESingleton_Shared == iterator-&gt;SingletonType()){\n   return total;\n}</Source>
                  </Method>
                  <Method name="SharedLink">
                     <Parameters>
                        <Parameter type="TShareSegment" name="segment"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSharedConsole::SharedLink(TShareSegment segment){\n   TListIteratorC&lt;ISingleton*&gt; iterator = RSingletonManager::Instance().Singletons()-&gt;IteratorC();\n   while(iterator.Next()){\n      /*if(ESingleton_Shared == iterator-&gt;SingletonType()){\n}</Source>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TInt" name="Code"/>
                     </Parameters>
                     <Return type="FShared*"/>
                     <Source>//============================================================\n\nFShared* FSharedConsole::Get(TInt code){\n   return _pShareds-&gt;Get(code);\n}</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TInt" name="Code"/>
                     </Parameters>
                     <Return type="FShared*"/>
                     <Source>//============================================================\n\nFShared* FSharedConsole::Find(TInt code){\n   return _pShareds-&gt;Find(code);\n}</Source>
                  </Method>
                  <Method name="Register">
                     <Parameters>
                        <Parameter type="FShared*" name="pShared"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSharedConsole::Register(FShared* pShared){\n   //_pShareds-&gt;Set(pShared-&gt;Code(), pShared);\n}</Source>
                  </Method>
                  <Method name="Unregister">
                     <Parameters>
                        <Parameter type="FShared*" name="pShared"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSharedConsole::Unregister(FShared* pShared){\n   //_pShareds-&gt;Remove(pShared-&gt;Code());\n}</Source>
                  </Method>
                  <Method name="LinkGroup">
                     <Parameters>
                        <Parameter type="TShareKey" name="key"/>
                     </Parameters>
                     <Return type="FSharedGroup*"/>
                     <Source>//============================================================\n\nFSharedGroup* FSharedConsole::LinkGroup(TShareKey key){\n   FSharedGroup* pGroup = _pGroups-&gt;Find(key);\n   if(NULL == pGroup){\n      pGroup = MO_CREATE(FSharedGroup, key);\n      _pGroups-&gt;Set(key, pGroup);\n   }\n   return pGroup;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FSharedSet*" name="_pShareds"/>
                  <Attribute type="FSharedGroupSet*" name="_pGroups"/>
               </Attributes>
            </Class>
            <Class name="FSharedEntryAllocator">
               <Inherits name="FShared" scope="public"/>
               <Methods>
                  <Constructor name="FSharedEntryAllocator"/>
                  <Method name="SetCapacity">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid SetCapacity(TInt capacity){\n      _capacity = capacity;\n   }</Source>
                  </Method>
                  <Method name="SharedCapacity">
                     <Return type="TSize"/>
                     <Source>\nTSize SharedCapacity(){\n      TSize size = sizeof(SSharedEntryAllocatorHead);\n      size += sizeof(E) * _capacity;\n      return size;\n   }</Source>
                  </Method>
                  <Method name="SharedLink">
                     <Parameters>
                        <Parameter type="TShareSegment" name="segment"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid SharedLink(TShareSegment segment){\n      _gHead = segment.TypeAlloc&lt;SSharedEntryAllocatorHead&gt;();\n      _gEntries = segment.TypeAlloc&lt;E&gt;(_capacity);\n      FShared::SharedLink(segment);\n   }</Source>
                  </Method>
                  <Method name="SharedInitialize">
                     <Return type="void"/>
                     <Source>\nvoid SharedInitialize(){\n      _gHead-&gt;count = 0;\n      if(_capacity &gt; 0){\n         for(TInt n=0; n&lt;_capacity; n++){\n            if(0 == n){\n               _gEntries[n].prior = -1;\n               _gEntries[n].next = n + 1;\n            }else if(_capacity - 1 == n){\n               _gEntries[n].prior = n - 1;\n               _gEntries[n].next = -1;\n            }else{\n               _gEntries[n].prior = n - 1;\n               _gEntries[n].next = n + 1;\n            }\n         }\n         _gHead-&gt;unused = 0;\n      }else{\n         _gHead-&gt;unused = -1;\n      }\n   }</Source>
                  </Method>
                  <Method name="*">
                     <Return type="operator"/>
                     <Source>\nE* operator *(){\n      return _gEntries;\n   }</Source>
                  </Method>
                  <Method name="[]">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nE&amp; operator [](TInt index){\n      MO_ASSERT_RANGE(index, 0, _capacity);\n      return _gEntries[index];\n   }</Source>
                  </Method>
                  <Method name="Entries">
                     <Return type="E*"/>
                     <Source>\nE* Entries(){\n      return _gEntries;\n   }</Source>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="E&amp;"/>
                     <Source>\nE&amp; Get(TInt index){\n      MO_ASSERT_RANGE(index, 0, _capacity);\n      return _gEntries[index];\n   }</Source>
                  </Method>
                  <Method name="Alloc">
                     <Return type="TInt"/>
                     <Source>\nTInt Alloc(){\n      // 获得未使用的索引\n      TInt index = _gHead-&gt;unused;\n      MO_ASSERT_RANGE(index, 0, _capacity);\n      _gHead-&gt;unused = _gEntries[index].next;\n      _gHead-&gt;count++;\n      return index;\n   }</Source>
                  </Method>
                  <Method name="Alloc">
                     <Parameters>
                        <Parameter type="TInt&amp;" name="index"/>
                     </Parameters>
                     <Return type="E&amp;"/>
                     <Source>\nE&amp; Alloc(TInt&amp; index){\n      // 获得未使用的索引\n      index = _gHead-&gt;unused;\n      MO_ASSERT_RANGE(index, 0, _capacity);\n      _gHead-&gt;unused = _gEntries[index].next;\n      _gHead-&gt;count++;\n      return _gEntries[index];\n   }</Source>
                  </Method>
                  <Method name="Free">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Free(TInt index){\n      MO_ASSERT_RANGE(index, 0, _capacity);\n      _gEntries[index].next = _gHead-&gt;unused;\n      _gHead-&gt;unused = index;\n      _gHead-&gt;count--;\n   }</Source>
                  </Method>
                  <Method name="Free">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                        <Parameter type="TInt" name="first"/>
                        <Parameter type="TInt" name="last"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Free(TInt count, TInt first, TInt last){\n      MO_ASSERT_RANGE(first, 0, _capacity);\n      MO_ASSERT_RANGE(last, 0, _capacity);\n      _gEntries[last].next = _gHead-&gt;unused;\n      _gHead-&gt;unused = first;\n      _gHead-&gt;count -= count;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_capacity"/>
                  <Attribute type="SSharedEntryAllocatorHead*" name="_gHead"/>
                  <Attribute type="E*" name="_gEntries"/>
               </Attributes>
            </Class>
            <Class name="FSharedGroup">
               <Inherits name="FObject" scope="public"/>
               <Methods>
                  <Constructor name="FSharedGroup"/>
                  <Constructor name="FSharedGroup">
                     <Parameters>
                        <Parameter type="TShareKey" name="key"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FSharedGroup"/>
                  <Method name="SharedCapacity">
                     <Return type="TSize"/>
                     <Source>//============================================================\n\nTSize FSharedGroup::SharedCapacity(){\n   TListIteratorC&lt;FShared*&gt; iterator = _pShareds-&gt;IteratorC();\n   TSize total = 0;\n   while(iterator.Next()){\n      // 获得共享对象\n      TSize capacity = iterator-&gt;SharedCapacity();\n      if(capacity &gt; 0){\n         total += capacity;\n      }\n   }\n   return total;\n}</Source>
                  </Method>
                  <Method name="SharedLink">
                     <Parameters>
                        <Parameter type="TShareSegment" name="segment"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FSharedGroup::SharedLink(TShareSegment segment){\n   TListIteratorC&lt;FShared*&gt; iterator = _pShareds-&gt;IteratorC();\n   while(iterator.Next()){\n      // 获得共享对象\n      TSize capacity = iterator-&gt;SharedCapacity();\n      if(capacity &gt; 0){\n         iterator-&gt;SharedLink(segment.CreateSegment(capacity));\n      }\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Register">
                     <Parameters>
                        <Parameter type="FShared*" name="pShared"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSharedGroup::Register(FShared* pShared){\n   _pShareds-&gt;Push(pShared);\n}</Source>
                  </Method>
                  <Method name="Unregister">
                     <Parameters>
                        <Parameter type="FShared*" name="pShared"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSharedGroup::Unregister(FShared* pShared){\n   _pShareds-&gt;Remove(pShared);\n}</Source>
                  </Method>
                  <Method name="Create">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FSharedGroup::Create(){\n   // 计算需要共享内存大小\n   TSize capacity = SharedCapacity();\n   // 收集共享内存\n   MO_ASSERT(NULL == _pAllocator);\n   _pAllocator = MO_CREATE(FShareMemory, _key, capacity);\n   // 分配共享内存\n   return SharedLink(_pAllocator-&gt;CreateSegment(capacity));\n}</Source>
                  </Method>
                  <Method name="Connect">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FSharedGroup::Connect(){\n   // 计算需要共享内存大小\n   TSize capacity = SharedCapacity();\n   // 收集共享内存\n   MO_ASSERT(NULL == _pAllocator);\n   _pAllocator = MO_CREATE(FShareMemory, _key);\n   if(!_pAllocator-&gt;IsLinked()){\n      MO_ERROR(&quot;Link share memory error. (key=%d)&quot;, _key);\n      MO_EXIT(EError);\n   }\n   // 分配共享内存\n   return SharedLink(_pAllocator-&gt;CreateSegment(capacity));\n}</Source>
                  </Method>
                  <Method name="Dump" description="查看共享内存分配信息。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;查看共享内存分配信息。&lt;/T&gt;\n//============================================================\n\nTBool FSharedGroup::Dump(){\n   TInt size = 0;\n   MO_INFO(&quot;Name                     |           Total |  Head    Data&quot;);\n   MO_INFO(MO_DUMP_SHARED_LA);\n   TListIteratorC&lt;FShared*&gt; iterator = _pShareds-&gt;IteratorC();\n   while(iterator.Next()){\n      // 获得共享对象\n      TSize capacity = iterator-&gt;SharedCapacity();\n      if(capacity &gt; 0){\n         if(size &gt; 0){\n            MO_INFO(MO_DUMP_SHARED_LB);\n         }\n         size += capacity;\n         iterator-&gt;DumpShared();\n      }\n   }\n   MO_INFO(MO_DUMP_SHARED_LA);\n   TChar format[MO_MEMORY_FORMATLENGTH];\n   MO_INFO(&quot;                         | %15s |&quot;,\n         RInt::FormatCapacity(size, format, MO_MEMORY_FORMATLENGTH));\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TShareKey" name="_key"/>
                  <Attribute type="FSharedList*" name="_pShareds"/>
                  <Attribute type="IShareAllocator*" name="_pAllocator"/>
               </Attributes>
            </Class>
            <Class name="FSharedListAllocator">
               <Methods>
                  <Constructor name="FSharedListAllocator" description="构造共享链表节点收集器。"/>
                  <Method name="SetCapacity" description="设置链表容量。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置链表容量。&lt;/T&gt;\n//============================================================\n\nvoid FSharedListAllocator::SetCapacity(TInt capacity){\n   _capacity = capacity;\n}</Source>
                  </Method>
                  <Method name="SetEntryCapacity" description="设置节点容量。">
                     <Parameters>
                        <Parameter type="TInt" name="entryCapacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置节点容量。&lt;/T&gt;\n//============================================================\n\nvoid FSharedListAllocator::SetEntryCapacity(TInt entryCapacity){\n   _entryCapacity = entryCapacity;\n}</Source>
                  </Method>
                  <Method name="OnSharedInitialize" description="共享内存初始化。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;共享内存初始化。&lt;/T&gt;\n//============================================================\n\nvoid FSharedListAllocator::OnSharedInitialize(){\n   // 初始化头信息\n   _gHead-&gt;listCount = 0;\n   _gHead-&gt;listUnused = 0;\n   _gHead-&gt;entryCount = 0;\n   _gHead-&gt;entryUnused = 0;\n   // 初始化链表头信息\n   for(TUint32 n=0; n&lt;_capacity; n++){\n      SSharedListHead&amp; list = _gLists[n];\n      list.count = 0;\n      list.index = n;\n      list.first = -1;\n      list.last = -1;\n      list.prior = n - 1;\n      list.next = (_capacity - 1 == n) ? -1 : n + 1;\n   }\n   // 初始化链表节点信息\n   for(TUint32 n=0; n&lt;_entryCapacity; n++){\n      SSharedListEntry&amp; entry = _gEntries[n];\n      entry.list = -1;\n      entry.index = n;\n      entry.prior = n - 1;\n      entry.next = (_entryCapacity - 1 == n) ? 0 : n + 1;\n      entry.code = -1;\n   }\n}</Source>
                  </Method>
                  <Method name="OnSharedLink" description="分配共享内存。">
                     <Parameters>
                        <Parameter type="TShareSegment&amp;" name="segment"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;分配共享内存。&lt;/T&gt;\n//============================================================\n\nvoid FSharedListAllocator::OnSharedLink(TShareSegment&amp; segment){\n   MO_ASSERT(_capacity &gt; 0);\n   MO_ASSERT(_entryCapacity &gt; 0);\n   _gHead = segment.TypeAlloc&lt;SHead&gt;();\n   _gLists = segment.TypeAlloc&lt;SSharedListHead&gt;(_capacity);\n   _gEntries = segment.TypeAlloc&lt;SSharedListEntry&gt;(_entryCapacity);\n}</Source>
                  </Method>
                  <Method name="SharedCapacity" description="计算共享内存大小。">
                     <Return type="TSize"/>
                     <Source>//============================================================\n// &lt;T&gt;计算共享内存大小。&lt;/T&gt;\n//============================================================\n\nTSize FSharedListAllocator::SharedCapacity(){\n   TSize capacity = sizeof(SHead);\n   capacity += sizeof(SSharedListHead) * _capacity;\n   capacity += sizeof(SSharedListEntry) * _entryCapacity;\n   return capacity;\n}</Source>
                  </Method>
                  <Method name="Lists" type="inline">
                     <Return type="SSharedListHead*"/>
                     <Source>\ninline SSharedListHead* Lists(){\n      return _gLists;\n   }</Source>
                  </Method>
                  <Method name="Entries" type="inline">
                     <Return type="SSharedListEntry*"/>
                     <Source>\ninline SSharedListEntry* Entries(){\n      return _gEntries;\n   }</Source>
                  </Method>
                  <Method name="AllocList" description="收集一个未使用的链表。">
                     <Return type="SSharedListHead*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一个未使用的链表。&lt;/T&gt;\n//============================================================\n\nSSharedListHead* FSharedListAllocator::AllocList(){\n   // 获得未使用的索引\n   TInt index = _gHead-&gt;listUnused;\n   MO_ASSERT(index &gt;= 0);\n   _gHead-&gt;listUnused = _gLists[index].next;\n   _gHead-&gt;listCount++;\n   return &amp;_gLists[index];\n}</Source>
                  </Method>
                  <Method name="FreeList" description="释放一个链表。">
                     <Parameters>
                        <Parameter type="SSharedListHead*" name="pList"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放一个链表。&lt;/T&gt;\n//============================================================\n\nvoid FSharedListAllocator::FreeList(SSharedListHead* pList){\n   TInt index = pList-&gt;index;\n   pList-&gt;first = -1;\n   pList-&gt;last = -1;\n   _gLists[index].next = _gHead-&gt;listUnused;\n   _gHead-&gt;listUnused = index;\n   _gHead-&gt;listCount--;\n}</Source>
                  </Method>
                  <Method name="AllocEntry" description="收集一个节点。">
                     <Return type="SSharedListEntry&amp;"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一个节点。&lt;/T&gt;\n//============================================================\n\nSSharedListEntry&amp; FSharedListAllocator::AllocEntry(){\n   // 获得未使用的索引\n   TInt index = _gHead-&gt;entryUnused;\n   MO_ASSERT(index &gt;= 0);\n   SSharedListEntry&amp; entry = _gEntries[index];\n   _gHead-&gt;entryUnused = entry.next;\n   _gHead-&gt;entryCount++;\n   return entry;\n}</Source>
                  </Method>
                  <Method name="FreeEntry" description="释放一个索引位置。">
                     <Parameters>
                        <Parameter type="SSharedListEntry&amp;" name="entry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放一个索引位置。&lt;/T&gt;\n//============================================================\n\nvoid FSharedListAllocator::FreeEntry(SSharedListEntry&amp; entry){\n   TInt index = entry.index;\n   _gEntries[index].next = _gHead-&gt;entryUnused;\n   _gHead-&gt;entryUnused = index;\n   _gHead-&gt;entryCount--;\n}</Source>
                  </Method>
                  <Method name="FreeEntries" description="释放一个索引链表。">
                     <Parameters>
                        <Parameter type="SSharedListHead*" name="pList"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放一个索引链表。&lt;/T&gt;\n//============================================================\n\nvoid FSharedListAllocator::FreeEntries(SSharedListHead* pList){\n   _gEntries[pList-&gt;last].next = _gHead-&gt;entryUnused;\n   _gHead-&gt;entryUnused = pList-&gt;first;\n   _gHead-&gt;entryCount -= pList-&gt;count;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TUint32" name="_capacity"/>
                  <Attribute type="TUint32" name="_entryCapacity"/>
                  <Attribute type="SHead*" name="_gHead"/>
                  <Attribute type="SSharedListHead*" name="_gLists"/>
                  <Attribute type="SSharedListEntry*" name="_gEntries"/>
               </Attributes>
            </Class>
            <Class name="FSharedPipe">
               <Methods>
                  <Constructor name="FSharedPipe" description="无参数构造函数。"/>
                  <Constructor name="FSharedPipe" description="带参数构造函数">
                     <Parameters>
                        <Parameter type="TSize" name="capacity" description="管道的容量"/>
                     </Parameters>
                  </Constructor>
                  <Method name="CalculateCapacity" type="static" description="计算共享管道所需内存空间。">
                     <Parameters>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TSize"/>
                     <Source>//============================================================\n// &lt;T&gt;计算共享管道所需内存空间。&lt;/T&gt;\n//\n// @return 所需空间。\n//============================================================\n\nTSize FSharedPipe::CalculateCapacity(TSize capacity){\n   return sizeof(SPipeInfo) + capacity;\n}</Source>
                  </Method>
                  <Method name="Capacity">
                     <Return type="TSize"/>
                     <Source>//============================================================\n\nTSize FSharedPipe::Capacity(){\n   return _capacity;\n}</Source>
                  </Method>
                  <Method name="SetCapacity" description="设置FSharedPipe所需内存空间。">
                     <Parameters>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置FSharedPipe所需内存空间。&lt;/T&gt;\n//\n// @param capacity 存放数据的内存长度。\n//============================================================\n\nvoid FSharedPipe::SetCapacity(TSize capacity){\n   _capacity = capacity;\n}</Source>
                  </Method>
                  <Method name="OnSharedInitialize" flag="override" description="初始化共享内存。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;初始化共享内存。&lt;/T&gt;\n//============================================================\n\nvoid FSharedPipe::OnSharedInitialize(){\n   _gInfo-&gt;capacity = _capacity;\n   _gInfo-&gt;first = 0;\n   _gInfo-&gt;last = 0;\n}</Source>
                  </Method>
                  <Method name="OnSharedLink" flag="override" description="分配共享内存。">
                     <Parameters>
                        <Parameter type="TShareSegment&amp;" name="segment"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;分配共享内存。&lt;/T&gt;\n//============================================================\n\nvoid FSharedPipe::OnSharedLink(TShareSegment&amp; segment){\n   // 获得信息部分\n   _gInfo = segment.TypeAlloc&lt;SPipeInfo&gt;();\n   // 获得内存部分\n   _gData = (TByte*)segment.Alloc(_capacity);\n}</Source>
                  </Method>
                  <Method name="SharedCapacity" flag="override" description="计算共享管道所需内存空间。">
                     <Return type="TSize"/>
                     <Source>//============================================================\n// &lt;T&gt;计算共享管道所需内存空间。&lt;/T&gt;\n//\n// @return 所需空间。\n//============================================================\n\nTSize FSharedPipe::SharedCapacity(){\n   return CalculateCapacity(_capacity);\n}</Source>
                  </Method>
                  <Method name="Info" flag="override" description="获得计算共享管道所需内存空间。">
                     <Return type="SPipeInfo*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得计算共享管道所需内存空间。&lt;/T&gt;\n//\n// @return 所需空间。\n//============================================================\n\nSPipeInfo* FSharedPipe::Info(){\n   return _gInfo;\n}</Source>
                  </Method>
                  <Method name="InnerGetInfo" flag="override" description="获取共享管道的成员。">
                     <Parameters>
                        <Parameter type="TByte**" name="ppMemory"/>
                        <Parameter type="TUint32&amp;" name="capacity"/>
                        <Parameter type="TUint32&amp;" name="length"/>
                        <Parameter type="TUint32&amp;" name="first"/>
                        <Parameter type="TUint32&amp;" name="last"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;获取共享管道的成员。&lt;/T&gt;\n//\n// @param pMemory 数据的存放内存\n// @param capacity 存放数据的内存长度。\n// @param length 已存数据长度\n// @param first 读位置\n// @param last 写位置\n// @return 无返回\n//============================================================\n\nvoid FSharedPipe::InnerGetInfo(TByte** ppMemory, TUint32&amp; capacity, TUint32&amp; length, TUint32&amp; first, TUint32&amp; last){\n   MO_ASSERT(_gData);\n   MO_ASSERT(_gInfo-&gt;capacity &gt; 0);\n   *ppMemory = _gData;\n   capacity = _gInfo-&gt;capacity;\n   first = _gInfo-&gt;first;\n   last = _gInfo-&gt;last;\n   length = (first &lt;= last) ? last - first : (capacity - first) + last;\n}</Source>
                  </Method>
                  <Method name="IsEmpty" flag="override" description="判断管道是否为空。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;判断管道是否为空。&lt;/T&gt;\n//\n// @return 是否为空\n//============================================================\n\nTBool FSharedPipe::IsEmpty(){\n   return (_gInfo-&gt;first == _gInfo-&gt;last);\n}</Source>
                  </Method>
                  <Method name="Length" flag="override" description="获得管道以被占用长度。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得管道以被占用长度。&lt;/T&gt;\n//\n// @return 被占用长度。\n//============================================================\n\nTInt FSharedPipe::Length(){\n   TInt first = _gInfo-&gt;first;\n   TInt last = _gInfo-&gt;last;\n   TInt length = (first &lt;= last) ? last - first : (_gInfo-&gt;capacity - first) + last;\n   return length;\n}</Source>
                  </Method>
                  <Method name="Reamin" flag="override" description="获得管道以剩余的长度。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得管道以剩余的长度。&lt;/T&gt;\n//\n// @return 剩余的长度\n//============================================================\n\nTInt FSharedPipe::Reamin(){\n   TInt first = _gInfo-&gt;first;\n   TInt last = _gInfo-&gt;last;\n   TInt length = (first &lt;= last) ? last - first : (_gInfo-&gt;capacity - first) + last;\n   return _gInfo-&gt;capacity - length - MO_PIPE_RESERVE_LENGTH;\n}</Source>
                  </Method>
                  <Method name="Reset" description="重置FSharePipe对象。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;重置FSharePipe对象。&lt;/T&gt;\n//\n// @return TBool变量表示初始化成功。\n//============================================================\n\nTBool FSharedPipe::Reset(){\n   _gInfo-&gt;first = 0;\n   _gInfo-&gt;last = 0;\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TSize" name="_capacity"/>
                  <Attribute type="SPipeInfo*" name="_gInfo"/>
                  <Attribute type="TByte*" name="_gData"/>
               </Attributes>
            </Class>
            <Class name="FSharedQueue">
               <Inherits name="FSharedPipe" scope="public"/>
               <Methods>
                  <Constructor name="FSharedQueue"/>
                  <Constructor name="FSharedQueue">
                     <Parameters>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Method name="Push" description="将一个完整信息写入管道。">
                     <Parameters>
                        <Parameter type="TAnyC*" name="pData"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;将一个完整信息写入管道。&lt;/T&gt;\n// &lt;P&gt;数据可以被分成两端放入管道的尾部和首部。&lt;/P&gt;\n//    写入的数据块长度计算在写入内容内。\n// &lt;/P&gt;\n//============================================================\n\nTBool FSharedQueue::Push(TAnyC* pData, TSize capacity){\n   // 检查参数\n   MO_ASSERT(pData);\n   if(0 == capacity){\n      return ETrue;\n   }\n   // 获取变量\n   TByte* pMemory;\n   TUint32 total, length, first, last;\n   InnerGetInfo(&amp;pMemory, total, length, first, last);\n   // 判断是否可以写入\n   if(capacity &gt; (total - length - MO_PIPE_RESERVE_LENGTH)){\n      return EFalse;\n   }\n   TSize size = *(TSize*)pData;\n   if(size != capacity){\n      MO_FATAL(&quot;Push data invalid. (size=%d, capacity=%d, length=%d, first=%d, last=%d)&quot;,\n            size, capacity, length, first, last);\n   }\n   // 处理一次写入数据 [---F===L----] | [===L---F====]\n   TUint32 moved = (first &lt; last) ? MO_MIN(capacity, total - last) : capacity;\n   memcpy(pMemory + last, pData, moved);\n   last += moved;\n   // 处理二次写入数据\n   if(capacity &gt; moved){\n      last = capacity - moved;\n      memcpy(pMemory, (TByte*)pData + moved, last);\n   }\n   // 存储变量\n   _gInfo-&gt;last = last;\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Pop">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FSharedQueue::Pop(TAny* pData, TSize capacity){\n   // 检查参数\n   MO_ASSERT(pData);\n   if(0 == capacity){\n      return 0;\n   }\n   // 获取变量\n   TByte* pMemory;\n   TUint32 total, length, first, last;\n   InnerGetInfo(&amp;pMemory, total, length, first, last);\n   // 判断是否可以读出\n   if(length &lt; sizeof(TUint32)){\n      return 0;\n   }\n   TUint32 size = *(TUint32*)(pMemory + first);\n   if(0 == size){\n      MO_FATAL(&quot;Pop data length is 0. (size=%d, length=%d, first=%d, last=%d)&quot;,\n            size, length, first, last);\n   }\n   if((size &gt; capacity) || (size &gt; length)){\n      return 0;\n   }\n   // 处理一次读出数据 [---F===L----] | [===L---F====]\n   TUint32 moved = (first &lt; last) ? size : MO_MIN(size, total - first);\n   memcpy(pData, pMemory + first, moved);\n   // 处理二次读出数据\n   if(size &gt; moved){\n      memcpy((TByte*)pData + moved, pMemory, size - moved);\n      first = size - moved;\n   }else{\n      first += moved;\n   }\n   // 存储变量\n   _gInfo-&gt;first = first;\n   return size;\n}</Source>
                  </Method>
                  <Method name="BlockPush" description="将一个完整信息写入管道。">
                     <Parameters>
                        <Parameter type="TAnyC*" name="pData"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;将一个完整信息写入管道。&lt;/T&gt;\n// &lt;P&gt;数据块总是一次被写入，不会被分成两端存储在尾部和首部。\n//    写入的数据块长度不算在写入内容内。\n//    写入失败的情况：\n//    - 容量不够\n//    - 尾部不够放入整个数据块，而首部也不够放入整个数据块\n// &lt;/P&gt;\n//============================================================\n\nTBool FSharedQueue::BlockPush(TAnyC* pData, TSize capacity){\n   // 检查参数\n   MO_ASSERT(pData);\n   if(0 == capacity){\n      return ETrue;\n   }\n   // 获取变量\n   TByte* pMemory;\n   TUint32 total, length, first, last;\n   InnerGetInfo(&amp;pMemory, total, length, first, last);\n   // 判断是否可以写入\n   if(capacity &gt; (total - length - MO_PIPE_RESERVE_LENGTH)){\n      return EFalse;\n   }\n   // 设置写入信息\n   TByte* pPtr = NULL;\n   TUint32 writed = sizeof(TUint32) + capacity;\n   // 测试尾部是否能放入\n   if(first &lt; last){\n      // 计算位置 [---F===L----]\n      if(writed &lt; total - last){\n         // 写入结尾\n         pPtr = pMemory + last;\n         last += writed;\n      }else if(writed &lt; first){\n         // 写入开头\n         pPtr = pMemory;\n         last = writed;\n      }else{\n         // 写入失败\n         return EFalse;\n      }\n   }else{\n      // 计算位置 [===L---F====]\n      pPtr = pMemory + last;\n      last += writed;\n   }\n   // 写入长度\n   *(TUint32*)pPtr = capacity;\n   // 写入数据\n   memcpy(pPtr + sizeof(TUint32), pData, capacity);\n   // 设置结束位置\n   _gInfo-&gt;last = last;\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="BlockPop" description="从管道内读取一个完整信息。">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;从管道内读取一个完整信息。&lt;/T&gt;\n// &lt;P&gt;数据块总是一次被读出，不会被从尾部和首部两个部分读出。\n//    读取的数据块长度不算在写入内容内。\n//    读取失败的情况：\n//    - 容量不够\n// &lt;/P&gt;\n// TODO: 暂时未实现\n//============================================================\n\nTInt FSharedQueue::BlockPop(TAny* pData, TSize capacity){\n   MO_ASSERT(pData);\n   // 获取变量\n   TByte* pMemory;\n   TUint32 total, length, first, last;\n   InnerGetInfo(&amp;pMemory, total, length, first, last);\n   // 判断是否可以读出\n   if(length &lt; sizeof(TInt)){\n      return 0;\n   }\n   TUint32 size = *(TUint32*)(pMemory + first);\n   if((size &gt; capacity) || (size &gt; length)){\n      return 0;\n   }\n   // 处理一次读出数据 [---F===L----] | [===L---F====]\n   TUint32 moved = (first &lt; last) ? size : MO_MIN(size, total - first);\n   memcpy(pData, pMemory + first, moved);\n   // 处理二次读出数据\n   if(size &gt; moved){\n      memcpy((TByte*)pData + moved, pMemory, size - moved);\n      first = size - moved;\n   }else{\n      first += moved;\n   }\n   // 存储变量\n   _gInfo-&gt;first = first;\n   return size;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FSharedQueueConnection">
               <Inherits name="FShared" scope="public"/>
               <Methods>
                  <Constructor name="FSharedQueueConnection" description="构造链接对象，不需要参数。" note="以后使用前先要设置输入输出管道大小。"/>
                  <Constructor name="FSharedQueueConnection" description="构造链接对象。">
                     <Parameters>
                        <Parameter type="TSize" name="inputCapacity" description="输入管道的容量"/>
                        <Parameter type="TSize" name="outputCapacity" description="输出管道的容量"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FSharedQueueConnection" description="析构链接对象。"/>
                  <Method name="SetInputCapacity" description="指定读写管道的长度。">
                     <Parameters>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;指定读写管道的长度。&lt;/T&gt;\n//\n// @param capacity 输入队列的长度\n//============================================================\n\nvoid FSharedQueueConnection::SetInputCapacity(TSize capacity){\n   _pInputQueue-&gt;SetCapacity(capacity);\n}</Source>
                  </Method>
                  <Method name="SetOutputCapacity" description="指定读写管道的长度。">
                     <Parameters>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;指定读写管道的长度。&lt;/T&gt;\n//\n// @param capacity 输出队列的长度\n//============================================================\n\nvoid FSharedQueueConnection::SetOutputCapacity(TSize capacity){\n   _pOutputQueue-&gt;SetCapacity(capacity);\n}</Source>
                  </Method>
                  <Method name="OnSharedLink" flag="override" description="将共享内存段分派给链接。">
                     <Parameters>
                        <Parameter type="TShareSegment&amp;" name="segment"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将共享内存段分派给链接。&lt;/T&gt;\n//\n// @param segment 共享内存段的对象\n//============================================================\n\nvoid FSharedQueueConnection::OnSharedLink(TShareSegment&amp; segment){\n   segment.SharedLink(_pInputQueue);\n   segment.SharedLink(_pOutputQueue);\n}</Source>
                  </Method>
                  <Method name="SharedCapacity" flag="override" description="获得链接所需的共享内存大小。">
                     <Return type="TSize"/>
                     <Source>//============================================================\n// &lt;T&gt;获得链接所需的共享内存大小。&lt;/T&gt;\n//\n// @return 链接所需的共享内存大小。\n//============================================================\n\nTSize FSharedQueueConnection::SharedCapacity(){\n   TSize intputSize = _pInputQueue-&gt;SharedCapacity();\n   TSize outputSize = _pOutputQueue-&gt;SharedCapacity();\n   TSize capacity = intputSize + outputSize;\n   return capacity;\n}</Source>
                  </Method>
                  <Method name="InputQueue" description="获得收队列的指针。">
                     <Return type="FSharedQueue*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得收队列的指针。&lt;/T&gt;\n//\n// @return 收队列的指针。\n//============================================================\n\nFSharedQueue* FSharedQueueConnection::InputQueue(){\n   return _pInputQueue;\n}</Source>
                  </Method>
                  <Method name="OutputQueue" description="获得写队列的指针。">
                     <Return type="FSharedQueue*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得写队列的指针。&lt;/T&gt;\n//\n// @return 写队列的指针。\n//============================================================\n\nFSharedQueue* FSharedQueueConnection::OutputQueue(){\n   return _pOutputQueue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FSharedQueue*" name="_pInputQueue"/>
                  <Attribute type="FSharedQueue*" name="_pOutputQueue"/>
               </Attributes>
            </Class>
            <Class name="FSingletonConsole">
               <Methods>
                  <Constructor name="FSingletonConsole" description="构造唯一对象控制台。"/>
                  <Destructor name="~FSingletonConsole" description="析构唯一对象控制台。"/>
                  <Method name="Singletons" description="获得唯一对象列表。">
                     <Return type="FSingletonList*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得唯一对象列表。&lt;/T&gt;\n//\n// @return 唯一对象列表\n//============================================================\n\nFSingletonList* FSingletonConsole::Singletons(){\n   return _pSingletons;\n}</Source>
                  </Method>
                  <Method name="Register" description="注册唯一对象。">
                     <Parameters>
                        <Parameter type="ISingleton*" name="pSingleton"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;注册唯一对象。&lt;/T&gt;\n//\n// @param pSingleton 唯一对象列表\n//============================================================\n\nvoid FSingletonConsole::Register(ISingleton* pSingleton){\n   _pSingletons-&gt;Push(pSingleton);\n}</Source>
                  </Method>
                  <Method name="Unregister" description="注销唯一对象列表。">
                     <Parameters>
                        <Parameter type="ISingleton*" name="pSingleton"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;注销唯一对象列表。&lt;/T&gt;\n//\n// @param pSingleton 唯一对象列表\n//============================================================\n\nvoid FSingletonConsole::Unregister(ISingleton* pSingleton){\n   _pSingletons-&gt;Remove(pSingleton);\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FSingletonList*" name="_pSingletons"/>
               </Attributes>
            </Class>
            <Class name="FSql">
               <Inherits name="FString" scope="public"/>
            </Class>
            <Class name="FSqlConnection">
               <Methods>
                  <Constructor name="FSqlConnection" description="构造数据库链接。"/>
                  <Destructor name="~FSqlConnection" description="析构数据库链接。"/>
                  <Method name="Connect">
                     <Parameters>
                        <Parameter type="TCharC*" name="pHost"/>
                        <Parameter type="pHost,TUint" name="port"/>
                        <Parameter type="port,TCharC*" name="pUserName"/>
                        <Parameter type="pUserName,TCharC*" name="pPassword"/>
                        <Parameter type="pPassword,TCharC*" name="pDatabase"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSqlConnection::Connect(\n      TCharC* pHost,\n      TUint port,\n      TCharC* pUserName,\n      TCharC* pPassword,\n      TCharC* pDatabase){\n   // 设置基础信息\n   _host.Assign(pHost);\n   _port = port;\n   _username.Assign(pUserName);\n   _password.Assign(pPassword);\n   _database.Assign(pDatabase);\n   // 连接到服务器\n   MO_DEBUG(&quot;Connect mysql server (host=%s:%d, user=%s, database=%s)&quot;, pHost, port, pUserName, pDatabase);\n#ifdef _LINUX\n   if(!mysql_real_connect(&amp;_connection, pHost, pUserName, pPassword, pDatabase, port, NULL, 0)){\n      MO_FATAL(&quot;Error connection to database: %s&quot;, mysql_error(&amp;_connection));\n   }\n   MO_INFO(&quot;Connect mysql server success.&quot;);\n#endif\n   _connected = ETrue;\n}</Source>
                  </Method>
                  <Method name="Id" flag="override">
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FSqlConnection::Id(){\n   return _id;\n}</Source>
                  </Method>
                  <Method name="Host" flag="override">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* FSqlConnection::Host(){\n   return _host.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Port" flag="override">
                     <Return type="TUint16"/>
                     <Source>//============================================================\n\nTUint16 FSqlConnection::Port(){\n   return _port;\n}</Source>
                  </Method>
                  <Method name="UserName" flag="override">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* FSqlConnection::UserName(){\n   return _username.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Password" flag="override">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* FSqlConnection::Password(){\n   return _password.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Database" flag="override">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* FSqlConnection::Database(){\n   return _database.MemoryC();\n}</Source>
                  </Method>
                  <Method name="SetId">
                     <Parameters>
                        <Parameter type="TInt" name="id"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSqlConnection::SetId(TInt id){\n   _id = id;\n}</Source>
                  </Method>
                  <Method name="SetHost">
                     <Parameters>
                        <Parameter type="TCharC*" name="host"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSqlConnection::SetHost(TCharC* host){\n   _host.Assign(host);\n}</Source>
                  </Method>
                  <Method name="SetHostPort">
                     <Parameters>
                        <Parameter type="TUint16" name="port"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSqlConnection::SetHostPort(TUint16 port){\n   _port = port;\n}</Source>
                  </Method>
                  <Method name="SetUserName">
                     <Parameters>
                        <Parameter type="TCharC*" name="uname"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSqlConnection::SetUserName(TCharC* uname){\n   _username.Assign(uname);\n}</Source>
                  </Method>
                  <Method name="SetPassword">
                     <Parameters>
                        <Parameter type="TCharC*" name="passwd"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSqlConnection::SetPassword(TCharC* passwd){\n   _password.Assign(passwd);\n}</Source>
                  </Method>
                  <Method name="SetDatabase">
                     <Parameters>
                        <Parameter type="TCharC*" name="database"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSqlConnection::SetDatabase(TCharC* database){\n   _database.Assign(database);\n}</Source>
                  </Method>
                  <Method name="Connect" flag="override">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSqlConnection::Connect(){\n   MO_DEBUG(&quot;Connect mysql server (host=%s:%d, user=%s, database=%s)&quot;,\n         _host.MemoryC(), _port, _username.MemoryC(), _database.MemoryC());\n#ifdef _LINUX\n    if(!mysql_real_connect(&amp;_connection, _host.MemoryC(), _username.MemoryC(), _password.MemoryC(), _database.MemoryC(), _port, NULL, 0)){\n      MO_FATAL(&quot;Error connection to database: %s&quot;, mysql_error(&amp;_connection));\n   }\n   MO_INFO(&quot;Connect mysql server success.&quot;);\n#endif\n   _connected = ETrue;\n}</Source>
                  </Method>
                  <Method name="Connect">
                     <Parameters>
                        <Parameter type="TCharC*" name="pHost"/>
                        <Parameter type="TUint" name="port"/>
                        <Parameter type="TCharC*" name="pUserName"/>
                        <Parameter type="TCharC*" name="pPassword"/>
                        <Parameter type="TCharC*" name="pDatabase"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Commit" flag="override">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FSqlConnection::Commit(){\n   MO_DEBUG(&quot;Connection %s.&quot;, &quot;commit&quot;);\n#ifdef _LINUX\n   if(!mysql_query(&amp;_connection, &quot;COMMIT&quot;)){\n      return ETrue;\n   }\n#endif\n   return EFalse;\n}</Source>
                  </Method>
                  <Method name="Rollback" flag="override">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FSqlConnection::Rollback(){\n   MO_DEBUG(&quot;Connection %s.&quot;, &quot;rollback&quot;);\n#ifdef _LINUX\n   if(!mysql_query(&amp;_connection, &quot;ROLLBACK&quot;)){\n      return ETrue;\n   }\n#endif\n   return EFalse;\n}</Source>
                  </Method>
                  <Method name="Close" flag="override">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FSqlConnection::Close(){\n   MO_DEBUG(&quot;Connection %s.&quot;, &quot;close&quot;);\n#ifdef _LINUX\n   if(_connected){\n      mysql_close(&amp;_connection);\n      _connected = EFalse;\n   }\n#endif\n}</Source>
                  </Method>
                  <Method name="ExecuteInsertSql" flag="override" description="执行一条新建记录的SQL命令。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pSql"/>
                        <Parameter type="TInt&amp;" name="lastId"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;执行一条新建记录的SQL命令。&lt;/T&gt;\n//\n// @param sql SQL命令\n// @param lastId 最后影响的自增编号\n// @return 影响的记录数\n//============================================================\n\nTInt FSqlConnection::ExecuteInsertSql(TCharC* pSql, TInt&amp; lastId){\n   MO_ASSERT(pSql);\n   MO_ASSERT(_connected);\n   // 执行SQL\n   TInt affected = 0;\n#ifdef _LINUX\n   TInt result = mysql_query(&amp;_connection, pSql);\n   if(ESuccess != result){\n      MO_FATAL(&quot;Execute sql error. (sql=[%s]\n%s)&quot;, pSql, mysql_error(&amp;_connection));\n      return 0;\n   }\n   lastId = mysql_insert_id(&amp;_connection);\n   // 获取影响的记录\n   affected = mysql_affected_rows(&amp;_connection);\n   if(EError == affected){\n      MO_ERROR(&quot;Fetch affected row error. (%s)&quot;, mysql_error(&amp;_connection));\n   }\n   MO_DEBUG(&quot;Execute sql [%d(%d)=%s]&quot;, affected, lastId, pSql);\n#endif\n   return affected;\n}</Source>
                  </Method>
                  <Method name="ExecuteSql" flag="override" description="执行一条SQL命令。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pSql"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;执行一条SQL命令。&lt;/T&gt;\n//\n// @param sql SQL命令\n// @return 影响的记录数\n//============================================================\n\nTInt FSqlConnection::ExecuteSql(TCharC* pSql){\n   MO_ASSERT(pSql);\n   MO_ASSERT(_connected);\n   TInt affected = 0;\n#ifdef _LINUX\n   // 执行SQL\n   TInt result = mysql_query(&amp;_connection, pSql);\n   if(ESuccess != result){\n      MO_FATAL(&quot;Execute sql error. (sql=[%s]\n%s)&quot;, pSql, mysql_error(&amp;_connection));\n      return 0;\n   }\n   // 获取影响的记录\n   affected = mysql_affected_rows(&amp;_connection);\n   if(EError == affected){\n      MO_ERROR(&quot;Fetch affected row error. (%s)&quot;, mysql_error(&amp;_connection));\n   }\n   MO_DEBUG(&quot;Execute sql [%d=%s]&quot;, affected, pSql);\n#endif\n   return affected;\n}</Source>
                  </Method>
                  <Method name="ExecuteScalar">
                     <Parameters>
                        <Parameter type="TCharC*" name="pSql"/>
                     </Parameters>
                     <Return type="TString"/>
                     <Source>//============================================================\n\nTString FSqlConnection::ExecuteScalar(TCharC* pSql){\n   MO_ASSERT(pSql);\n   return TString();\n}</Source>
                  </Method>
                  <Method name="ExecuteExist">
                     <Parameters>
                        <Parameter type="TCharC*" name="pSql"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FSqlConnection::ExecuteExist(TCharC* pSql){\n   MO_ASSERT(pSql);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Find" flag="override">
                     <Parameters>
                        <Parameter type="TCharC*" name="pSql"/>
                        <Parameter type="ISqlRowFill*" name="pFill"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FSqlConnection::Find(TCharC* pSql, ISqlRowFill* pFill){\n   MO_ASSERT(pSql);\n   MO_ASSERT(pFill);\n   MO_ASSERT(_connected);\n   // 查询SQL\n#ifdef _LINUX\n   TInt result = mysql_query(&amp;_connection, pSql);\n   if(ESuccess != result){\n      MO_FATAL(&quot;Error query from database: %s&quot;, pSql);\n      return EFalse;\n   }\n   // 获得结果集\n   MYSQL_RES* pResult = mysql_store_result(&amp;_connection);\n   TInt fieldCount = mysql_num_fields(pResult);\n   MYSQL_ROW row = mysql_fetch_row(pResult);\n   if(row){\n      // 读取行数据\n      pFill-&gt;Fill(row, fieldCount);\n   }\n   MO_DEBUG(&quot;Find row. [row=0x%08X, fields=%d, sql=%s]&quot;, row, fieldCount, pSql);\n   // 释放结果集\n   mysql_free_result(pResult);\n#endif\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Fetch" flag="override">
                     <Parameters>
                        <Parameter type="TCharC*" name="pSql"/>
                        <Parameter type="ISqlRowFill**" name="ppFills"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FSqlConnection::Fetch(TCharC* pSql, ISqlRowFill** ppFills, TInt count){\n   MO_ASSERT(pSql);\n   MO_ASSERT(ppFills);\n   MO_ASSERT(_connected);\n   TInt readed = 0;\n   // 查询SQL\n#ifdef _LINUX\n   TInt result = mysql_query(&amp;_connection, pSql);\n   if(ESuccess != result){\n      MO_FATAL(&quot;Error query from database: %s&quot;, pSql);\n      return 0;\n   }\n   // 获得结果集\n   MYSQL_RES* pResult = mysql_store_result(&amp;_connection);\n   TInt fieldCount = mysql_num_fields(pResult);\n   // 遍历结果集\n   MYSQL_ROW row;\n   TInt n = -1;\n   while((row = mysql_fetch_row(pResult))){\n      // 创建新数据行\n      if(++n &lt; count){\n         ppFills[n]-&gt;Fill(row, fieldCount);\n         readed++;\n      }\n   }\n   MO_DEBUG(&quot;Fetch dataset [count=0x%08X, fields=%d, sql=%s]&quot;, n, fieldCount, pSql);\n   // 释放结果集\n   mysql_free_result(pResult);\n#endif\n   return readed;\n}</Source>
                  </Method>
                  <Method name="Find" flag="override">
                     <Parameters>
                        <Parameter type="TCharC*" name="pSql"/>
                        <Parameter type="ISqlRowFiller*" name="pFiller"/>
                        <Parameter type="TAny*" name="pRow"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool FSqlConnection::Find(TCharC* pSql, ISqlRowFiller* pFiller, TAny* pRow){\n   MO_ASSERT(pSql);\n   MO_ASSERT(pFiller);\n   MO_ASSERT(_connected);\n   TBool result = EFalse;\n   // 查询SQL\n#ifdef _LINUX\n   if(ESuccess != mysql_query(&amp;_connection, pSql)){\n      MO_FATAL(&quot;Error query from database: %s&quot;, pSql);\n      return EFalse;\n   }\n   // 获得结果集\n   MYSQL_RES* pResult = mysql_store_result(&amp;_connection);\n   TInt fieldCount = mysql_num_fields(pResult);\n   MYSQL_ROW row = mysql_fetch_row(pResult);\n   if(row){\n      // 读取行数据\n      pFiller-&gt;Fill(pRow, row, fieldCount);\n      // 设置结果\n      result = ETrue;\n   }\n   MO_DEBUG(&quot;Find row. [row=0x%08X, fields=%d, sql=%s]&quot;, row, fieldCount, pSql);\n   // 释放结果集\n   mysql_free_result(pResult);\n#endif\n   return result;\n}</Source>
                  </Method>
                  <Method name="Fetch" flag="override">
                     <Parameters>
                        <Parameter type="TCharC*" name="pSql"/>
                        <Parameter type="ISqlRowFiller*" name="pFiller"/>
                        <Parameter type="TAny**" name="ppRows"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FSqlConnection::Fetch(TCharC* pSql, ISqlRowFiller* pFiller, TAny** ppRows, TInt count){\n   MO_ASSERT(pSql);\n   MO_ASSERT(pFiller);\n   MO_ASSERT(ppRows);\n   MO_ASSERT(_connected);\n   TInt readed = 0;\n   // 查询SQL\n#ifdef _LINUX\n   TInt result = mysql_query(&amp;_connection, pSql);\n   if(ESuccess != result){\n      MO_FATAL(&quot;Error query from database: %s&quot;, pSql);\n      return 0;\n   }\n   // 获得结果集\n   MYSQL_RES* pResult = mysql_store_result(&amp;_connection);\n   TInt fieldCount = mysql_num_fields(pResult);\n   // 遍历结果集\n   MYSQL_ROW row;\n   TInt n = -1;\n   while((row = mysql_fetch_row(pResult))){\n      // 创建新数据行\n      if(++n &lt; count){\n         pFiller-&gt;Fill(ppRows[n], row, fieldCount);\n         readed++;\n      }\n   }\n   MO_DEBUG(&quot;Fetch dataset [count=0x%08X, fields=%d, sql=%s]&quot;, n, fieldCount, pSql);\n   // 释放结果集\n   mysql_free_result(pResult);\n#endif\n   return readed;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_id"/>
                  <Attribute type="TBool" name="_connected"/>
                  <Attribute type="TFsName" name="_host"/>
                  <Attribute type="TUint16" name="_port"/>
                  <Attribute type="TFsName" name="_username"/>
                  <Attribute type="TFsName" name="_password"/>
                  <Attribute type="TFsName" name="_database"/>
                  <Attribute type="st_mysql" name="_connection"/>
               </Attributes>
            </Class>
            <Class name="FString16">
               <Inherits>
                  <Inherit name="MString16" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FString16" description="构造一个ANSI字符串类。"/>
                  <Constructor name="FString16" description="从ANSI字符对象构造实例。">
                     <Parameters>
                        <Parameter type="FString16&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FString16" description="从ANSI字符串构造实例。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FString16" description="从ANSI字符对象构造实例。">
                     <Parameters>
                        <Parameter type="MString16PtrC&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FString16" description="构造一个ANSI字符串类。"/>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      this-&gt;_length = 0;\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_pMemory = RTypeMemory&lt;TChar16&gt;::Alloc(this-&gt;_size, 0);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="FString16&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param value ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid FString16::operator=(const FString16&amp; value){\n   this-&gt;Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串的内容。&lt;/T&gt;\n//\n// @param pValue ANSI字符串\n// @return 结果字符串对象\n//============================================================\n\nvoid FString16::operator=(TChar16C* pValue){\n   Assign(pValue);\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="MString16PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param value ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid FString16::operator=(const MString16PtrC&amp; value){\n   this-&gt;Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;确保内存大小。&lt;/T&gt;\n// &lt;P&gt;当第一次使用是，会收集第一块内存。\n// 当前大小内存不足时，会重新收集指定大小1.5倍的内存存放数据，暂未使用的作为缓冲使用。\n// 当内存不再发生大小上改变的时候，可以使用压缩函数释放掉所有未使用的缓冲内存。&lt;/P&gt;\n//\n// @param size 大小\n//============================================================\n\nvoid FString16::EnsureSize(TInt size){\n   if(size &gt; this-&gt;_size){\n      // 当内存不足时，扩大1.5倍内存，但收集量不得小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_size += this-&gt;_size &gt;&gt; 1;\n      TChar16* pMemory = RTypeMemory&lt;TChar16&gt;::Alloc(this-&gt;_size, 0);\n      if(this-&gt;_length &gt; 0){\n         RTypes&lt;TChar16&gt;::Copy(pMemory, this-&gt;_pMemory, this-&gt;_length);\n      }\n      RTypeMemory&lt;TChar16&gt;::Free(this-&gt;_pMemory);\n      this-&gt;_pMemory = pMemory;\n   }\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FString16s">
               <Inherits>
                  <Inherit name="MString16s" scope="public"/>
               </Inherits>
            </Class>
            <Class name="FString32">
               <Inherits>
                  <Inherit name="MString32" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FString32" description="构造一个ANSI字符串类。"/>
                  <Constructor name="FString32" description="从ANSI字符对象构造实例。">
                     <Parameters>
                        <Parameter type="FString32&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FString32" description="从ANSI字符串构造实例。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FString32" description="从ANSI字符对象构造实例。">
                     <Parameters>
                        <Parameter type="MString32PtrC&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FString32" description="构造一个ANSI字符串类。"/>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      this-&gt;_length = 0;\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_pMemory = RTypeMemory&lt;TChar32&gt;::Alloc(this-&gt;_size, 0);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="FString32&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param value ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid FString32::operator=(const FString32&amp; value){\n   this-&gt;Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串的内容。&lt;/T&gt;\n//\n// @param pValue ANSI字符串\n// @return 结果字符串对象\n//============================================================\n\nvoid FString32::operator=(TChar32C* pValue){\n   Assign(pValue);\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="MString32PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param value ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid FString32::operator=(const MString32PtrC&amp; value){\n   this-&gt;Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;确保内存大小。&lt;/T&gt;\n// &lt;P&gt;当第一次使用是，会收集第一块内存。\n// 当前大小内存不足时，会重新收集指定大小1.5倍的内存存放数据，暂未使用的作为缓冲使用。\n// 当内存不再发生大小上改变的时候，可以使用压缩函数释放掉所有未使用的缓冲内存。&lt;/P&gt;\n//\n// @param size 大小\n//============================================================\n\nvoid FString32::EnsureSize(TInt size){\n   if(size &gt; this-&gt;_size){\n      // 当内存不足时，扩大1.5倍内存，但收集量不得小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_size += this-&gt;_size &gt;&gt; 1;\n      TChar32* pMemory = RTypeMemory&lt;TChar32&gt;::Alloc(this-&gt;_size, 0);\n      if(this-&gt;_length &gt; 0){\n         RTypes&lt;TChar32&gt;::Copy(pMemory, this-&gt;_pMemory, this-&gt;_length);\n      }\n      RTypeMemory&lt;TChar32&gt;::Free(this-&gt;_pMemory);\n      this-&gt;_pMemory = pMemory;\n   }\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FString32s">
               <Inherits>
                  <Inherit name="MString32s" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FString32s"/>
                  <Constructor name="FString32s">
                     <Parameters>
                        <Parameter type="MString32sC&amp;" name="strings"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FString32s">
                     <Parameters>
                        <Parameter type="FString32s&amp;" name="strings"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="MString32sC&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString32sC&amp; strings){\n		Assign(strings);\n	}</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="FString32s&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const FString32s&amp; strings){\n		Assign(strings);\n	}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FString8">
               <Inherits>
                  <Inherit name="MString8" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FString8" description="构造一个ANSI字符串类。"/>
                  <Constructor name="FString8" description="从ANSI字符对象构造实例。">
                     <Parameters>
                        <Parameter type="FString8&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FString8" description="从ANSI字符串构造实例。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FString8" description="从ANSI字符对象构造实例。">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FString8" description="构造一个ANSI字符串类。"/>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      this-&gt;_length = 0;\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_pMemory = RTypeMemory&lt;TChar8&gt;::Alloc(this-&gt;_size, 0);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="FString8&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param value ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid FString8::operator=(const FString8&amp; value){\n   this-&gt;Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串的内容。&lt;/T&gt;\n//\n// @param pValue ANSI字符串\n// @return 结果字符串对象\n//============================================================\n\nvoid FString8::operator=(TChar8C* pValue){\n   Assign(pValue);\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param value ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid FString8::operator=(const MString8PtrC&amp; value){\n   this-&gt;Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;确保内存大小。&lt;/T&gt;\n// &lt;P&gt;当第一次使用是，会收集第一块内存。\n// 当前大小内存不足时，会重新收集指定大小1.5倍的内存存放数据，暂未使用的作为缓冲使用。\n// 当内存不再发生大小上改变的时候，可以使用压缩函数释放掉所有未使用的缓冲内存。&lt;/P&gt;\n//\n// @param size 大小\n//============================================================\n\nvoid FString8::EnsureSize(TInt size){\n   if(size &gt; this-&gt;_size){\n      // 当内存不足时，扩大1.5倍内存，但收集量不得小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_size += this-&gt;_size &gt;&gt; 1;\n      TChar8* pMemory = RTypeMemory&lt;TChar8&gt;::Alloc(this-&gt;_size, 0);\n      if(this-&gt;_length &gt; 0){\n         RTypes&lt;TChar8&gt;::Copy(pMemory, this-&gt;_pMemory, this-&gt;_length);\n      }\n      RTypeMemory&lt;TChar8&gt;::Free(this-&gt;_pMemory);\n      this-&gt;_pMemory = pMemory;\n   }\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FString8s">
               <Inherits>
                  <Inherit name="MString8s" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FString8s"/>
                  <Constructor name="FString8s">
                     <Parameters>
                        <Parameter type="MString8sC&amp;" name="strings"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FString8s">
                     <Parameters>
                        <Parameter type="FString8s&amp;" name="strings"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FString8s"/>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="MString8sC&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString8sC&amp; strings){\n		Assign(strings);\n	}</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="FString8s&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const FString8s&amp; strings){\n		Assign(strings);\n	}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FThread">
               <Methods>
                  <Constructor name="FThread" description="启动线程处理。"/>
                  <Destructor name="~FThread" description="终止线程处理。"/>
                  <Method name="Index">
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FThread::Index(){\n   return _index;\n}</Source>
                  </Method>
                  <Method name="SetIndex">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FThread::SetIndex(TInt index){\n   _index = index;\n}</Source>
                  </Method>
                  <Method name="Code">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nconst TCharC* FThread::Code(){\n   return _code.MemoryC();\n}</Source>
                  </Method>
                  <Method name="SetCode">
                     <Parameters>
                        <Parameter type="TCharC*" name="pCode"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FThread::SetCode(TCharC* pCode){\n   _code.Assign(pCode);\n}</Source>
                  </Method>
                  <Method name="Name">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* FThread::Name(){\n   return _name.MemoryC();\n}</Source>
                  </Method>
                  <Method name="SetName">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FThread::SetName(TCharC* pName){\n   _name.Assign(pName);\n}</Source>
                  </Method>
                  <Method name="Handle" flag="override" description="获得线程优先级。">
                     <Return type="TThreadHandle"/>
                     <Source>//============================================================\n// &lt;T&gt;获得线程优先级。&lt;/T&gt;\n//\n// @return 线程优先级\n//============================================================\n\nTThreadHandle FThread::Handle() const{\n   return _handle;\n}</Source>
                  </Method>
                  <Method name="ThreadId" flag="override" description="获得线程优先级。">
                     <Return type="TThreadId"/>
                     <Source>//============================================================\n// &lt;T&gt;获得线程优先级。&lt;/T&gt;\n//\n// @return 线程优先级\n//============================================================\n\nTThreadId FThread::ThreadId() const{\n#ifdef _WINDOWS\n   return _threadId;\n#else\n   return _handle;\n#endif\n}</Source>
                  </Method>
                  <Method name="Priority" flag="override" description="获得线程优先级。">
                     <Return type="EThreadPriority"/>
                     <Source>//============================================================\n// &lt;T&gt;获得线程优先级。&lt;/T&gt;\n//\n// @return 线程优先级\n//============================================================\n\nEThreadPriority FThread::Priority() const{\n   return _priority;\n}</Source>
                  </Method>
                  <Method name="SetPriority" description="设置线程优先级。">
                     <Parameters>
                        <Parameter type="EThreadPriority" name="priority"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置线程优先级。&lt;/T&gt;\n//\n// @param priority 线程优先级\n//============================================================\n\nvoid FThread::SetPriority(EThreadPriority priority){\n   _priority = priority;\n}</Source>
                  </Method>
                  <Method name="ThreadTrap" description="获得线程陷阱。">
                     <Return type="FThreadTrap*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得线程陷阱。&lt;/T&gt;\n//\n// @return 线程优先级\n//============================================================\n\nFThreadTrap* FThread::ThreadTrap(){\n   return _pThreadTrap;\n}</Source>
                  </Method>
                  <Method name="ThreadMemory" description="获得线程内存。">
                     <Return type="FThreadMemory*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得线程内存。&lt;/T&gt;\n//\n// @return 线程优先级\n//============================================================\n\nFThreadMemory* FThread::ThreadMemory(){\n   return _pThreadMemory;\n}</Source>
                  </Method>
                  <Method name="OnStart" flag="abstract" description="线程开始处理。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;线程开始处理。&lt;/T&gt;\n//============================================================\n\nTBool FThread::OnStart(){\n   MO_INFO(&quot;Execute thread start (name=%s)&quot;, _name.MemoryC());\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="OnCancel" flag="abstract" description="线程取消处理。">
                     <Parameters>
                        <Parameter type="TInt" name="code"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;线程取消处理。&lt;/T&gt;\n//============================================================\n\nTBool FThread::OnCancel(TInt code){\n   MO_ERROR(&quot;Execute thread cancel (name=%s, code=%d)&quot;, _name.MemoryC(), code);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="OnFinish" flag="abstract" description="线程结束处理。">
                     <Parameters>
                        <Parameter type="TInt" name="result"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;线程结束处理。&lt;/T&gt;\n//============================================================\n\nTBool FThread::OnFinish(TInt result){\n   MO_INFO(&quot;Execute thread finish (name=%s, result=%d)&quot;, _name.MemoryC(), result);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Process" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Start" flag="override" description="启动线程处理。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;启动线程处理。&lt;/T&gt;\n//============================================================\n\nvoid FThread::Start(){\n#ifdef _WINDOWS\n   MO_ASSERT(NULL == _handle);\n   // 创建等待线程\n   _handle = CreateThread(NULL, 0, __MO_THREAD_CALLBACK, this, CREATE_SUSPENDED, &amp;_threadId);\n   MO_ASSERT(_handle);\n   // 将自己放入线程管理器里\n   RThreadManager::Instance().Register(this);\n   // 开始执行线程\n   ResumeThread(_handle);\n#else\n   TInt result = pthread_create(&amp;_handle, NULL, __MO_THREAD_CALLBACK, this);\n   if(ESuccess != result){\n      MO_PFATAL(&quot;pthread_create&quot;);\n   }\n#endif\n}</Source>
                  </Method>
                  <Method name="Suspend" flag="override" description="挂起线程处理。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;挂起线程处理。&lt;/T&gt;\n//============================================================\n\nvoid FThread::Suspend(){\n   MO_ASSERT(_handle);\n   MO_DEBUG(&quot;Thread suspend begin.(thread=0x%08X)&quot;, this);\n#ifdef _WINDOWS\n   SuspendThread(_handle);\n#else\n   pthread_mutex_lock(&amp;_mutex);\n   pthread_cond_wait(&amp;_condition, &amp;_mutex);\n   pthread_mutex_unlock(&amp;_mutex);\n#endif\n   MO_DEBUG(&quot;Thread suspend end.(thread=0x%08X)&quot;, this);\n}</Source>
                  </Method>
                  <Method name="Resume" flag="override" description="继续线程处理。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;继续线程处理。&lt;/T&gt;\n//============================================================\n\nvoid FThread::Resume(){\n   MO_ASSERT(_handle);\n   MO_DEBUG(&quot;Thread resume begin.(thread=0x%08X)&quot;, this);\n#ifdef _WINDOWS\n   ResumeThread(_handle);\n#else\n   pthread_mutex_lock(&amp;_mutex);\n   pthread_cond_signal(&amp;_condition);\n   pthread_mutex_unlock(&amp;_mutex);\n#endif\n   MO_DEBUG(&quot;Thread resume end.(thread=0x%08X)&quot;, this);\n}</Source>
                  </Method>
                  <Method name="Join" flag="override" description="等待其他线程结束。">
                     <Parameters>
                        <Parameter type="IThread*" name="pThread"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;等待其他线程结束。&lt;/T&gt;\n//============================================================\n\nvoid FThread::Join(IThread* pThread){\n#ifdef _WINDOWS\n   MO_ASSERT(_handle);\n   WaitForSingleObject(pThread-&gt;Handle(), INFINITE);\n#else\n   TAny* pResult;\n   pthread_join(pThread-&gt;Handle(), (TAny**)&amp;pResult);\n#endif\n}</Source>
                  </Method>
                  <Method name="Wait" flag="override" description="等待其他线程结束。">
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;等待其他线程结束。&lt;/T&gt;\n//============================================================\n\nTAny* FThread::Wait(){\n   MO_ASSERT(_handle);\n   TAny* pResult = NULL;\n#ifdef _WINDOWS\n   WaitForSingleObject(_handle, INFINITE);\n#else\n   pthread_join(_handle, (TAny**)&amp;pResult);\n#endif\n   return pResult;\n}</Source>
                  </Method>
                  <Method name="Stop" flag="override" description="停止线程处理。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;停止线程处理。&lt;/T&gt;\n// &lt;P&gt;只是一个标志位变更操作。&lt;/P&gt;\n//============================================================\n\nvoid FThread::Stop(){\n   MO_ASSERT(_handle);\n   _stop = ETrue;\n}</Source>
                  </Method>
                  <Method name="Terminate" flag="override" description="停止线程处理。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;停止线程处理。&lt;/T&gt;\n//============================================================\n\nvoid FThread::Terminate(){\n#ifdef _WINDOWS\n   MO_ASSERT(_handle);\n   TerminateThread(_handle, 0);\n#else\n   pthread_detach(_handle);\n#endif\n}</Source>
                  </Method>
                  <Method name="Sleep" description="当前线程睡眠处理。">
                     <Parameters>
                        <Parameter type="TInt" name="interval"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;当前线程睡眠处理。&lt;/T&gt;\n//\n// @param interval 间隔\n//============================================================\n\nvoid FThread::Sleep(TInt interval){\n#ifdef _WINDOWS\n   ::Sleep(interval);\n#else\n   usleep(interval);\n#endif\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_index"/>
                  <Attribute type="TFsCode" name="_code"/>
                  <Attribute type="TFsName" name="_name"/>
                  <Attribute type="TThreadHandle" name="_handle"/>
                  <Attribute type="pthread_mutex_t" name="_mutex"/>
                  <Attribute type="pthread_cond_t" name="_condition"/>
                  <Attribute type="TThreadId" name="_threadId"/>
                  <Attribute type="TBool" name="_stop"/>
                  <Attribute type="EThreadPriority" name="_priority"/>
                  <Attribute type="FThreadTrap*" name="_pThreadTrap"/>
                  <Attribute type="FThreadMemory*" name="_pThreadMemory"/>
               </Attributes>
            </Class>
            <Class name="FThreadConsole">
               <Methods>
                  <Constructor name="FThreadConsole" description="创建线程管理器。"/>
                  <Destructor name="~FThreadConsole" description="释放线程管理器。"/>
                  <Method name="Register" flag="override" description="注册线程对象。">
                     <Parameters>
                        <Parameter type="FThread*" name="pThread"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;注册线程对象。&lt;/T&gt;\n//\n// @param pThread 线程对象\n//============================================================\n\nvoid FThreadConsole::Register(FThread* pThread){\n   MO_ASSERT(pThread);\n   // 获得线程标识\n   TThreadId threadId = pThread-&gt;ThreadId();\n   // 检查是否重复\n   _section.Enter();\n   if(_pThreads-&gt;Contains(threadId)){\n      MO_THROW(&quot;Thread id duplicate.&quot;);\n   }\n   // 存储线程\n   _pThreads-&gt;Set(threadId, pThread);\n   pThread-&gt;SetIndex(++_index);\n   _section.Leave();\n}</Source>
                  </Method>
                  <Method name="Unregister" flag="override" description="注销线程对象。">
                     <Parameters>
                        <Parameter type="FThread*" name="pThread"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;注销线程对象。&lt;/T&gt;\n//\n// @param pThread 线程对象\n//============================================================\n\nvoid FThreadConsole::Unregister(FThread* pThread){\n   MO_ASSERT(pThread);\n   TThreadId threadId = pThread-&gt;ThreadId();\n   // 检查是否重复\n   if(!_pThreads-&gt;Contains(threadId)){\n      MO_THROW(&quot;Thread id is not founded.&quot;);\n   }\n   _section.Enter();\n   _pThreads-&gt;Remove(threadId);\n   _section.Leave();\n}</Source>
                  </Method>
                  <Method name="Current" flag="override" description="获得当前线程对象。">
                     <Return type="FThread*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得当前线程对象。&lt;/T&gt;\n//\n// @param threadId 线程标识\n//============================================================\n\nFThread* FThreadConsole::Current(){\n   return Find(RThread::CurrentId());\n}</Source>
                  </Method>
                  <Method name="Get" flag="override" description="根据线程标识获得线程对象。">
                     <Parameters>
                        <Parameter type="TThreadId" name="threadId" default="0"/>
                     </Parameters>
                     <Return type="FThread*"/>
                     <Source>//============================================================\n// &lt;T&gt;根据线程标识获得线程对象。&lt;/T&gt;\n//\n// @param threadId 线程标识\n// @return 线程对象\n//============================================================\n\nFThread* FThreadConsole::Get(TThreadId threadId){\n   _section.Enter();\n   FThread* pThread = _pThreads-&gt;Get(threadId);\n   _section.Leave();\n   MO_ASSERT(pThread);\n   return pThread;\n}</Source>
                  </Method>
                  <Method name="Find" flag="override" description="根据线程标识获得线程对象。">
                     <Parameters>
                        <Parameter type="TThreadId" name="threadId" default="0"/>
                     </Parameters>
                     <Return type="FThread*"/>
                     <Source>//============================================================\n// &lt;T&gt;根据线程标识获得线程对象。&lt;/T&gt;\n//\n// @param threadId 线程标识\n// @return 线程对象\n//============================================================\n\nFThread* FThreadConsole::Find(TThreadId threadId){\n   _section.Enter();\n   FThread* pThread = _pThreads-&gt;Find(threadId);\n   _section.Leave();\n   return pThread;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_index"/>
                  <Attribute type="TThreadSection" name="_section"/>
                  <Attribute type="FThreadSet*" name="_pThreads"/>
               </Attributes>
            </Class>
            <Class name="FThreadGroup">
               <Inherits name="FList" scope="public"/>
               <Methods>
                  <Method name="Suspend">
                     <Return type="void"/>
                     <Source>//============================================================\n\n\n\n//============================================================\n\nvoid FThreadGroup::Suspend(){\n}</Source>
                  </Method>
                  <Method name="Resume">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FThreadGroup::Resume(){\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FThreadMemory">
               <Methods>
                  <Constructor name="FThreadMemory" description="创建线程内存。"/>
                  <Destructor name="~FThreadMemory" description="释放线程内存块。"/>
                  <Method name="Alloc" description="收集线程内存块。">
                     <Parameters>
                        <Parameter type="TUint" name="size"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集线程内存块。&lt;/T&gt;\n//\n// @param size 内存大小\n// @return 内存块\n//============================================================\n\nTAny* FThreadMemory::Alloc(TUint size){\n   FBlockAllocator* pAllocator = _pBlockAllocators-&gt;Get(size);\n   if(NULL == pAllocator){\n      pAllocator = RAllocator::BlockAllocatorAlloc(size);\n      _pBlockAllocators-&gt;Set(size, pAllocator);\n   }\n   return pAllocator-&gt;Alloc(size);\n}</Source>
                  </Method>
                  <Method name="Alloc" description="收集线程内存块。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pTypeName"/>
                        <Parameter type="TUint" name="size"/>
                        <Parameter type="TChar8C*" name="pFileName"/>
                        <Parameter type="TInt" name="fileLine"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集线程内存块。&lt;/T&gt;\n//\n// @param pTypeName 类名\n// @param size 内存大小\n// @param pFileName 文件名称\n// @param line 文件行号\n// @return 内存块\n//============================================================\n\nTAny* FThreadMemory::Alloc(TCharC* pTypeName, TUint size, TChar8C* pFileName, TInt fileLine){\n   FBlockAllocator* pAllocator = _pBlockAllocators-&gt;Get(size);\n   if(NULL == pAllocator){\n      pAllocator = RAllocator::BlockAllocatorAlloc(size);\n      _pBlockAllocators-&gt;Set(size, pAllocator);\n   }\n   return pAllocator-&gt;Alloc(pTypeName, size, pFileName, fileLine);\n}</Source>
                  </Method>
                  <Method name="Free" description="释放线程内存块。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放线程内存块。&lt;/T&gt;\n//\n// @param pMemory 内存对象\n//============================================================\n\nvoid FThreadMemory::Free(TAny* pMemory){\n   MO_ASSERT(pMemory);\n   // 获得当前使用的实例\n   TInt* pAlloc = ((TInt*)pMemory) - 1;\n   IAllocator* pAllocator = (IAllocator*)pAlloc[0];\n   // 释放类型内存块\n   pAllocator-&gt;Free(pMemory);\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FBlockAllocatorSet*" name="_pBlockAllocators"/>
               </Attributes>
            </Class>
            <Class name="FThreadMemoryTrackThread">
               <Inherits name="FThread" scope="public"/>
               <Methods>
                  <Method name="Process">
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FThreadMemoryTrackThread::Process(){\n   TUint used, total;\n   while(!_stop){\n      if(RAllocator::CalculateStatistics(used, total)){\n         //MO_TRACK(&quot;Memory track: used=%0.3fM, total=%0.3fM&quot;, used/1024.0/1024.0, total/1024.0/1024.0);\n      }\n#ifdef _WINDOWS\n      ::Sleep(2000);\n#else\n      sleep(2);\n#endif\n   }\n   return ESuccess;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FThreadPool">
               <Inherits>
                  <Inherit name="IThreadPool" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FThreadPool" description="构造线程缓冲池。"/>
                  <Destructor name="~FThreadPool" description="析构线程缓冲池。"/>
                  <Method name="ActiveCount">
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FThreadPool::ActiveCount(){\n   return _pUsedWorks-&gt;Count();\n}</Source>
                  </Method>
                  <Method name="SleepCount">
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt FThreadPool::SleepCount(){\n   return _pUnusedWorks-&gt;Count();\n}</Source>
                  </Method>
                  <Method name="NotifyFree">
                     <Parameters>
                        <Parameter type="FThreadWorker&amp;" name="worker"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FThreadPool::NotifyFree(FThreadWorker&amp; worker){\n   _section.Enter();\n   _pUsedWorks-&gt;Remove(&amp;worker);\n   _pUnusedWorks-&gt;Push(&amp;worker);\n   _section.Leave();\n   MO_DEBUG(&quot;Process thread (active=%d, sleep=%d)&quot;, _pUsedWorks-&gt;Count(), _pUnusedWorks-&gt;Count());\n}</Source>
                  </Method>
                  <Method name="NotifyTimeout">
                     <Parameters>
                        <Parameter type="FThreadWorker&amp;" name="worker"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid FThreadPool::NotifyTimeout(FThreadWorker&amp; worker){\n}</Source>
                  </Method>
                  <Method name="Process" description="执行处理。">
                     <Parameters>
                        <Parameter type="CRunable" name="runable"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;执行处理。&lt;/T&gt;\n//\n// @param runable 工作函数\n//============================================================\n\nvoid FThreadPool::Process(CRunable runable){\n   FThreadWorker* pWorker = NULL;\n   _section.Enter();\n   if(_pUnusedWorks-&gt;IsEmpty()){\n      pWorker = MO_CREATE(FThreadWorker, this);\n      pWorker-&gt;Start();\n      _pUsedWorks-&gt;Push(pWorker);\n   }else{\n      pWorker = _pUnusedWorks-&gt;Shift();\n   }\n   pWorker-&gt;SetRunable(runable);\n   _pUsedWorks-&gt;Push(pWorker);\n   pWorker-&gt;Resume();\n   _section.Leave();\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TThreadSection" name="_section"/>
                  <Attribute type="FThreadWorkerList*" name="_pUsedWorks"/>
                  <Attribute type="FThreadWorkerList*" name="_pUnusedWorks"/>
                  <Attribute type="TInt" name="_incrementCapacity"/>
                  <Attribute type="TThreadSection" name="_eventStop"/>
               </Attributes>
            </Class>
            <Class name="FThreadRunable">
               <Inherits name="FThread" scope="public"/>
               <Methods>
                  <Constructor name="FThreadRunable"/>
                  <Constructor name="FThreadRunable" description="构造可运行线程对象。">
                     <Parameters>
                        <Parameter type="CRunable" name="cRunable"/>
                     </Parameters>
                  </Constructor>
                  <Method name="SetRunable" description="设置工作函数。">
                     <Parameters>
                        <Parameter type="CRunable" name="cRunable"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置工作函数。&lt;/T&gt;\n//\n// @param cRunable 工作函数\n//============================================================\n\nvoid FThreadRunable::SetRunable(CRunable cRunable){\n   _cRunable = cRunable;\n}</Source>
                  </Method>
                  <Method name="Process" flag="override" description="执行处理。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;执行处理。&lt;/T&gt;\n//\n// @return 执行结果\n//============================================================\n\nTInt FThreadRunable::Process(){\n   if(NULL != _cRunable){\n      return (*_cRunable)(this);\n   }\n   return ESuccess;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="CRunable" name="_cRunable"/>
               </Attributes>
            </Class>
            <Class name="FThreadTrap">
               <Methods>
                  <Constructor name="FThreadTrap" description="创建线程陷阱对象。">
                     <Parameters>
                        <Parameter type="TInt" name="threadId"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FThreadTrap" description="释放线程陷阱对象。"/>
                  <Method name="ThreadId" description="获得线程标识。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得线程标识。&lt;/T&gt;\n//\n// @return 线程标识\n//============================================================\n\nTInt FThreadTrap::ThreadId(){\n   return _threadId;\n}</Source>
                  </Method>
                  <Method name="IsEmpty" description="是否为空。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;是否为空。&lt;/T&gt;\n//\n// @return 是否为空\n//============================================================\n\nTBool FThreadTrap::IsEmpty(){\n   return (NULL == _pUsed);\n}</Source>
                  </Method>
                  <Method name="CurrentTrap" description="获得当前陷阱对象。">
                     <Return type="FTrap*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得当前陷阱对象。&lt;/T&gt;\n//\n// @return 当前陷阱对象\n//============================================================\n\nFTrap* FThreadTrap::CurrentTrap(){\n   return _pUsed;\n}</Source>
                  </Method>
                  <Method name="Push" description="压入陷阱对象。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;压入陷阱对象。&lt;/T&gt;\n//============================================================\n\nvoid FThreadTrap::Push(){\n   // 获得一个可用的实例\n   FTrap* pTrap = NULL;\n   if(NULL == _pUnused){\n      pTrap = new FTrap();\n   }else{\n      pTrap = _pUnused;\n      _pUnused = pTrap-&gt;Parent();\n   }\n   // 压入使用中的队列\n   pTrap-&gt;SetParent(_pUsed);\n   _pUsed = pTrap;\n}</Source>
                  </Method>
                  <Method name="Pop" description="弹出陷阱对象。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;弹出陷阱对象。&lt;/T&gt;\n//============================================================\n\nvoid FThreadTrap::Pop(){\n   MO_ASSERT(_pUsed);\n   // 获得当前使用的实例\n   FTrap* pTrap = _pUsed;\n   _pUsed = pTrap-&gt;Parent();\n   // 压入未使用的队列\n   pTrap-&gt;SetParent(_pUnused);\n   _pUnused = pTrap;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_threadId"/>
                  <Attribute type="FTrap*" name="_pUsed"/>
                  <Attribute type="FTrap*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="FThreadWorker">
               <Inherits name="FThreadRunable" scope="public"/>
               <Methods>
                  <Constructor name="FThreadWorker" description="构造线程池的工作对象。">
                     <Parameters>
                        <Parameter type="IThreadPool*" name="pPool" description="缓冲池"/>
                     </Parameters>
                  </Constructor>
                  <Method name="Process" flag="override" description="执行处理。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;执行处理。&lt;/T&gt;\n//\n// @return 执行结果\n//============================================================\n\nTInt FThreadWorker::Process(){\n   while(!_stop){\n      // 执行处理\n      if(NULL != _cRunable){\n         (*_cRunable)(this);\n         _cRunable = NULL;\n      }\n      // 挂起，等待下一个执行命令\n      Suspend();\n   }\n   return ESuccess;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="IThreadPool*" name="_pPool"/>
                  <Attribute type="TBool" name="_stop"/>
               </Attributes>
            </Class>
            <Class name="FTrap">
               <Methods>
                  <Constructor name="FTrap" description="创建陷阱对象。"/>
                  <Destructor name="~FTrap" description="释放陷阱对象。"/>
                  <Method name="Parent" description="获得父陷阱对象。">
                     <Return type="FTrap*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得父陷阱对象。&lt;/T&gt;\n//\n// @return 父陷阱对象\n//============================================================\n\nFTrap* FTrap::Parent(){\n   return _pParent;\n}</Source>
                  </Method>
                  <Method name="SetParent" description="设置父陷阱对象。">
                     <Parameters>
                        <Parameter type="FTrap*" name="parent"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置父陷阱对象。&lt;/T&gt;\n//\n// @param pParent 父陷阱对象\n//============================================================\n\nvoid FTrap::SetParent(FTrap* pParent){\n   _pParent = pParent;\n}</Source>
                  </Method>
                  <Method name="Alloc" description="收集内存块。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集内存块。&lt;/T&gt;\n//\n// @return 已收集的内存\n//============================================================\n\nTAny* FTrap::Alloc(TInt size){\n   return Alloc(NULL, size, NULL, 0);\n}</Source>
                  </Method>
                  <Method name="Alloc" description="收集内存块。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pClassName"/>
                        <Parameter type="TInt" name="size"/>
                        <Parameter type="TChar8C*" name="pFileName"/>
                        <Parameter type="TInt" name="line"/>
                     </Parameters>
                     <Return type="TAny*"/>
                     <Source>//============================================================\n// &lt;T&gt;收集内存块。&lt;/T&gt;\n//\n// @param pClassName 类名称\n// @param size 对象大小\n// @param pFileName 编译文件\n// @param line 编译行数\n// @return 对象实例指针\n//============================================================\n\nTAny* FTrap::Alloc(TChar8C* pClassName, TInt size, TChar8C* pFileName, TInt line){\n   // 创建内存结构\n   FTrapBlock* pBlock = new FTrapBlock();\n   pBlock-&gt;pClassName = pClassName;\n   pBlock-&gt;pMemory = RMemory::Alloc(size);\n   pBlock-&gt;Size = size;\n   pBlock-&gt;pFileName = pFileName;\n   pBlock-&gt;Line = line;\n   // 加入链表\n   _pBlocks-&gt;Set((TInt)pBlock-&gt;pMemory, pBlock);\n   return pBlock-&gt;pMemory;\n}</Source>
                  </Method>
                  <Method name="Remove" description="删除内存块。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;删除内存块。&lt;/T&gt;\n//\n// @param pMemory 内存指针\n//============================================================\n\nvoid FTrap::Remove(TAny* pMemory){\n   FTrapBlock* pBlock = _pBlocks-&gt;Get((TInt)pMemory);\n   if(NULL != pBlock){\n      _pBlocks-&gt;Set((TInt)pMemory, NULL);\n      MO_PTR_DELETE(pBlock);\n   }\n}</Source>
                  </Method>
                  <Method name="Free" description="释放内存块。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放内存块。&lt;/T&gt;\n//\n// @param pMemory 内存指针\n//============================================================\n\nvoid FTrap::Free(TAny* pMemory){\n   FTrapBlock* pBlock = _pBlocks-&gt;Get((TInt)pMemory);\n   if(NULL != pBlock){\n      _pBlocks-&gt;Set((TInt)pMemory, NULL);\n      MO_PTR_DELETE(pBlock);\n   }\n   RMemory::Free(pMemory);\n}</Source>
                  </Method>
                  <Method name="Check" description="检查内存块。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;检查内存块。&lt;/T&gt;\n// &lt;P&gt;如果含有未回收的内存块，则打印出内存泄漏错误。&lt;/P&gt;\n//============================================================\n\nvoid FTrap::Check(){\n   if(!_pBlocks-&gt;IsEmpty()){\n      // 检查未释放的指针\n      TBool hasLeak = EFalse;\n      TSetIteratorC&lt;TInt, FTrapBlock*&gt; iterator = _pBlocks-&gt;IteratorC();\n      while(iterator.Next()){\n         FTrapBlock* pBlock = iterator.Value();\n         if(NULL != pBlock){\n            hasLeak = ETrue;\n            MO_FATAL(&quot;Memory leak. (instance=%s@0x%08X, size=%08d, file=%s(%d))&quot;,\n                  TFsName(pBlock-&gt;pClassName).MemoryC(), pBlock-&gt;pMemory, pBlock-&gt;Size, TFsFileName(pBlock-&gt;pFileName).MemoryC(), pBlock-&gt;Line);\n         }\n      }\n      // 如果有内存泄露，则抛出错误。\n      if(hasLeak){\n         throw EError_NoMemory;\n      }\n   }\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FTrap*" name="_pParent"/>
                  <Attribute type="FTrapBlockSet*" name="_pBlocks"/>
               </Attributes>
            </Class>
            <Class name="FTrapBlock">
               <Attributes>
                  <Attribute type="TChar8C*" name="pClassName"/>
                  <Attribute type="TAny*" name="pMemory"/>
                  <Attribute type="TUint" name="Size"/>
                  <Attribute type="TChar8C*" name="pFileName"/>
                  <Attribute type="TInt" name="Line"/>
               </Attributes>
            </Class>
            <Class name="FTree">
               <Inherits>
                  <Inherit name="MTree" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FTree">
                     <Parameters>
                        <Parameter type="TInt" name="level"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FTree">
                     <Parameters>
                        <Parameter type="MTreeC&lt;N, V&gt;&amp;" name="tree"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FTree"/>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="MTreeC&lt;N, V&gt;&amp;" name="tree"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MTreeC&lt;N, V&gt;&amp; tree){\n      this-&gt;Assign(tree);\n	}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FVector">
               <Inherits>
                  <Inherit name="MVector" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="FVector" description="构造变长数组。"/>
                  <Constructor name="FVector" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FVector" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FVector" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FVector" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FVector" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="FVector&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FVector" description="析构变长数组。"/>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      // 当第一次使用的时候，收集不小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n      this-&gt;_count = 0;\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_pMemory = RTypeMemory&lt;T&gt;::Alloc(this-&gt;_size, NULL);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定数据指针。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MPtrC&lt;T&gt;&amp; ptr){\n      Assign(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定数据数组。">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MVectorC&lt;T&gt;&amp; values){\n      Assign(values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定数据数组。">
                     <Parameters>
                        <Parameter type="FVector&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const FVector&lt;T&gt;&amp; values){\n      Assign(values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if(size &gt; this-&gt;_size){\n         // 当内存不足时，扩大1.5倍内存，但收集量不得小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n         this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n         this-&gt;_size += this-&gt;_size &gt;&gt; 1;\n         T* pMemory = RTypeMemory&lt;T&gt;::Alloc(this-&gt;_size, NULL);\n         if(this-&gt;_count &gt; 0){\n            RTypes&lt;T&gt;::Copy(pMemory, this-&gt;_pMemory, this-&gt;_count);\n         }\n         RTypeMemory&lt;T&gt;::Free(this-&gt;_pMemory);\n         this-&gt;_pMemory = pMemory;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="FXmlDocument">
               <Inherits name="FObject" scope="public"/>
               <Methods>
                  <Constructor name="FXmlDocument" description="创建配置文件实例。"/>
                  <Constructor name="FXmlDocument" description="创建配置文件实例，加载配置文件。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FXmlDocument" description="释放当前实例。"/>
                  <Method name="FileName" description="获得一个文件名称。">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得一个文件名称。&lt;/T&gt;\n//\n// @return 文件名称\n//============================================================\n\nTCharC* FXmlDocument::FileName(){\n   return _fileName.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Encoding" description="获得文字编码。">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得文字编码。&lt;/T&gt;\n//\n// @return 文字编码\n//============================================================\n\nTCharC* FXmlDocument::Encoding(){\n   return _encoding.MemoryC();\n}</Source>
                  </Method>
                  <Method name="SetEncoding" description="设置文字编码。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pEncoding"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置文字编码。&lt;/T&gt;\n//\n// @param pEncoding 文字编码\n//============================================================\n\nvoid FXmlDocument::SetEncoding(TCharC* pEncoding){\n   _encoding.Assign(pEncoding);\n}</Source>
                  </Method>
                  <Method name="HasNode" description="判断是否存在节点。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;判断是否存在节点。&lt;/T&gt;\n//\n// @return 是否存在节点\n//============================================================\n\nTBool FXmlDocument::HasNode(){\n   return NULL != _pRoot;\n}</Source>
                  </Method>
                  <Method name="Root" description="获得根节点。">
                     <Return type="FXmlNode*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得根节点。&lt;/T&gt;\n//\n// @return 配置节点\n//============================================================\n\nFXmlNode* FXmlDocument::Root(){\n   if(NULL == _pRoot){\n      // 创建根节点\n      _pRoot = CreateNode(EXmlNodeType_Element);\n      _pRoot-&gt;SetName(MO_DEF_ROOT_NAME);\n   }\n   return _pRoot;\n}</Source>
                  </Method>
                  <Method name="CreateNode" description="创建一个配置节点。">
                     <Parameters>
                        <Parameter type="EXmlNodeType" name="type" default="EXmlNodeType_Element"/>
                     </Parameters>
                     <Return type="FXmlNode*"/>
                     <Source>//============================================================\n// &lt;T&gt;创建一个配置节点。&lt;/T&gt;\n//\n// @return 配置节点\n//============================================================\n\nFXmlNode* FXmlDocument::CreateNode(EXmlNodeType type){\n   FXmlNode* pNode = MO_CREATE(FXmlNode, this, type);\n   pNode-&gt;SetName(MO_DEF_NODE_NAME);\n   _pNodes-&gt;Push(pNode);\n   return pNode;\n}</Source>
                  </Method>
                  <Method name="LoadFile" flag="abstract" description="加载配置文件。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;加载配置文件。&lt;/T&gt;\n//\n// @param fileName 文件名称\n//============================================================\n\nTBool FXmlDocument::LoadFile(TCharC* pFileName){\n   MO_DEBUG(&quot;Load configuration file. (file_name=%s)&quot;, pFileName);\n#ifdef _WINDOWS\n   // 存储要加载文件的名称\n   _fileName.Assign(pFileName);\n   // 创建文档对象\n   MSXML2::IXMLDOMDocument3Ptr piDocument;\n   HRESULT hr = piDocument.CreateInstance(__uuidof(MSXML2::DOMDocument60));\n   if(FAILED(hr)){\n      throw EError_Unknown;\n   }\n   piDocument-&gt;put_async(VARIANT_FALSE);\n   piDocument-&gt;put_validateOnParse(VARIANT_FALSE);\n   piDocument-&gt;put_resolveExternals(VARIANT_FALSE);\n   piDocument-&gt;put_preserveWhiteSpace(VARIANT_TRUE);\n   VARIANT_BOOL result = piDocument-&gt;load(pFileName);\n   if(!result){\n      MO_FATAL(&quot;Load file error. (file_name=%s)&quot;, pFileName);\n   }\n   // 元素节点到配置节点\n   MSXML2::IXMLDOMElementPtr piRoot = piDocument-&gt;documentElement;\n   SyncNodeFromElement(this, piDocument, Root(), piRoot);\n   // 释放对象\n   piDocument.Release();\n#else\n   // 初始化环境\n   xmlInitParser();\n   // 打开文档\n   xmlDocPtr xdocPtr;\n   if(NULL == (xdocPtr = xmlReadFile(pFileName, NULL, XML_PARSE_RECOVER | XML_PARSE_NOBLANKS))){\n      MO_PERROR(xmlParseFile);\n      return EFalse;\n   }\n   // 获得跟节点\n   xmlNodePtr nodePtr;\n   if(NULL == (nodePtr = xmlDocGetRootElement(xdocPtr))){\n      MO_PERROR(xmlDocGetRootElement);\n      xmlFreeDoc(xdocPtr);\n      xdocPtr = NULL;\n      return EFalse;\n   }\n   // 元素节点到配置节点\n   SyncNodeFromElement(this, Root(), xdocPtr, nodePtr);\n   // 释放对象\n   xmlFreeDoc(xdocPtr);\n   xmlCleanupParser();\n#ifdef _DEBUG\n   xmlMemoryDump();\n#endif\n#endif\n   _fileName.Assign(pFileName);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="SaveFile" flag="abstract" description="存储配置文件。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;存储配置文件。&lt;/T&gt;\n//\n// @param fileName 文件名称\n//============================================================\n\nTBool FXmlDocument::SaveFile(TCharC* pFileName){\n#ifdef _WINDOWS\n#if 1\n   // 保存文件\n   TString xml = Xml();\n   HANDLE handle = CreateFile(pFileName, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n   MO_ASSERT(INVALID_HANDLE_VALUE != handle);\n   TUint32 writted;\n   WriteFile(handle, xml.MemoryC(), xml.Length(), &amp;writted, NULL);\n   MO_ASSERT(writted == xml.Length());\n   CloseHandle(handle);\n#else\n   // 创建文档对象\n   MSXML2::IXMLDOMDocument3Ptr piDocument;\n   HRESULT hr = piDocument.CreateInstance(__uuidof(MSXML2::DOMDocument60));\n   if(FAILED(hr)){\n      throw EError_Unknown;\n   }\n   piDocument-&gt;put_async(VARIANT_FALSE);\n   piDocument-&gt;put_validateOnParse(VARIANT_FALSE);\n   piDocument-&gt;put_resolveExternals(VARIANT_FALSE);\n   piDocument-&gt;put_preserveWhiteSpace(VARIANT_TRUE);\n   // 创建文件声明\n   MSXML2::IXMLDOMProcessingInstructionPtr piInstruction = piDocument-&gt;createProcessingInstruction(&quot;xml&quot;, &quot;version='1.0' encoding='UTF-8'&quot;);\n   piDocument-&gt;appendChild(piInstruction);\n   // 创建空行\n   //MSXML2::IXMLDOMTextPtr piSpace = piDocument-&gt;createTextNode(&quot;\n&quot;);\n   //piFragment-&gt;appendChild(piSpace);\n   // 同步配置节点到元素节点\n   FXmlNode* pRoot = Root();\n   MSXML2::IXMLDOMElementPtr piRoot = piDocument-&gt;createNode(NODE_ELEMENT, _bstr_t(pRoot-&gt;Name()), _bstr_t());\n   SyncElementFromNode(this, piDocument, piRoot, pRoot, 1);\n   piDocument-&gt;documentElement = piRoot;\n   piDocument-&gt;save(_bstr_t(pFileName));\n   // 释放对象\n   piDocument.Release();\n#endif\n#else\n#if 0\n   // TODO:无法控制格式化\n   // 打开文件\n   xmlDocPtr xdocPtr = xmlNewDoc(BAD_CAST(&quot;1.0&quot;));\n   if(NULL == xdocPtr){\n      MO_PERROR(xmlNewDoc);\n      return EFalse;\n   }\n   // 创建根节点\n   FXmlNode* pRoot = Root();\n   xmlNodePtr xnodePtr = xmlNewDocNode(xdocPtr, NULL, BAD_CAST(pRoot-&gt;Name().MemoryC()), BAD_CAST(pRoot-&gt;Text().MemoryC()));\n   if(NULL == xnodePtr){\n      MO_PERROR(xmlNewDocNode);\n      xmlFreeDoc(xdocPtr);\n      xdocPtr = NULL;\n      return EFalse;\n   }\n   xmlDocSetRootElement(xdocPtr, xnodePtr);\n   // 同步节点\n   SyncElementFromNode(this, Root(), xdocPtr, xnodePtr);\n   // 保存文件\n   /*xmlKeepBlanksDefault(0);\n   // 释放对象\n   xmlFreeDoc(xdocPtr);\n#ifdef _DEBUG\n   xmlMemoryDump();\n#endif\n#else\n   // 保存文件\n   TString xml = Xml();\n   TInt handle = open(pFileName, O_CREAT | O_TRUNC | O_WRONLY, 0777);\n   TUint size = write(handle, xml.MemoryC(), xml.Length());\n   MO_ASSERT(size == xml.Length());\n   close(handle);\n#endif\n#endif\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Xml" description="获得XML字符串。">
                     <Return type="TString"/>
                     <Source>//============================================================\n// &lt;T&gt;获得XML字符串。&lt;/T&gt;\n//\n// @return XML字符串\n//============================================================\n\nTString FXmlDocument::Xml(){\n   TString xml;\n   xml.EnsureSize(1024*1024*16);\n   xml.Append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;&quot;);\n   xml.Append(_encoding);\n   xml.Append(&quot;\&quot;?&gt;\n&quot;);\n   Root()-&gt;BuildXml(xml);\n   return xml;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsFileName" name="_fileName"/>
                  <Attribute type="TFsCode" name="_encoding"/>
                  <Attribute type="FXmlNodes*" name="_pNodes"/>
                  <Attribute type="FXmlNode*" name="_pRoot"/>
                  <Attribute type="TFsCode" name="_indent"/>
               </Attributes>
            </Class>
            <Class name="FXmlNode">
               <Inherits name="FObject" scope="public"/>
               <Methods>
                  <Constructor name="FXmlNode" description="创建配置节点实例。">
                     <Parameters>
                        <Parameter type="FXmlDocument*" name="pDocument"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="FXmlNode" description="创建配置节点实例。">
                     <Parameters>
                        <Parameter type="FXmlDocument*" name="pDocument"/>
                        <Parameter type="EXmlNodeType" name="nodeType" description="节点类型"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~FXmlNode" description="释放配置节点实例。"/>
                  <Method name="GetAsBool" description="以布尔格式，获得节点属性，如果节点属性为空，则返回默认值。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TBool" name="nvl" description="节点属性为空时的取值"/>
                     </Parameters>
                     <Return type="TBool" description="数字内容"/>
                     <Source>//============================================================\n// &lt;T&gt;以布尔格式，获得节点属性，如果节点属性为空，则返回默认值。&lt;/T&gt;\n//\n// @param nvl 节点属性为空时的取值\n// @return 数字内容\n//============================================================\n\nTBool FXmlNode::GetAsBool(TCharC* pName, TBool nvl){\n   if(NULL == _pAttributes){\n      return EFalse;\n   }\n   TCharC* pValue = _pAttributes-&gt;Find(pName);\n   return (NULL == pValue) ? nvl : RBool::IsTrue(pValue);\n}</Source>
                  </Method>
                  <Method name="GetAsInt" description="以数字格式，获得节点属性，如果节点属性为空，则返回默认值。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TInt" name="nvl" description="节点属性为空时的取值"/>
                     </Parameters>
                     <Return type="TInt" description="数字内容"/>
                     <Source>//============================================================\n// &lt;T&gt;以数字格式，获得节点属性，如果节点属性为空，则返回默认值。&lt;/T&gt;\n//\n// @param nvl 节点属性为空时的取值\n// @return 数字内容\n//============================================================\n\nTInt FXmlNode::GetAsInt(TCharC* pName, TInt nvl){\n   if(NULL == _pAttributes){\n      return 0;\n   }\n   TCharC* pValue = _pAttributes-&gt;Find(pName);\n   return (NULL == pValue) ? nvl : atoi(pValue);\n}</Source>
                  </Method>
                  <Method name="GetAsFloat" description="以浮点数格式，获得节点属性，如果节点属性为空，则返回默认值。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TFloat" name="nvl" description="节点属性为空时的取值"/>
                     </Parameters>
                     <Return type="TFloat" description="浮点数"/>
                     <Source>//============================================================\n// &lt;T&gt;以浮点数格式，获得节点属性，如果节点属性为空，则返回默认值。&lt;/T&gt;\n//\n// @param nvl 节点属性为空时的取值\n// @return 浮点数\n//============================================================\n\nTFloat FXmlNode::GetAsFloat(TCharC* pName, TFloat nvl){\n   if(NULL == _pAttributes){\n      return 0.0f;\n   }\n   TCharC* pValue = _pAttributes-&gt;Find(pName);\n   return (NULL == pValue) ? nvl : (TFloat)atof(pValue);\n}</Source>
                  </Method>
                  <Method name="InnerBuildXml" description="建立XML文本内容。">
                     <Parameters>
                        <Parameter type="TString&amp;" name="xml"/>
                        <Parameter type="FXmlNode*" name="pNode"/>
                        <Parameter type="TInt" name="level"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;建立XML文本内容。&lt;/T&gt;\n//\n// @param xml 文本内容\n// @param pNode 节点对象\n// @param level 层次\n//============================================================\n\nvoid FXmlNode::InnerBuildXml(TString&amp; xml, FXmlNode* pNode, TInt level){\n   xml.AppendRepeat(&quot;   &quot;, level);\n   if(EXmlNodeType_Comment == pNode-&gt;NodeType()){\n      // 处理注释节点\n      xml.Append(&quot;&lt;--&quot;);\n      xml.Append(pNode-&gt;Text());\n      xml.Append(&quot;--&gt;\n&quot;);\n   }else{\n      // 处理数据节点\n      xml.Append('&lt;');\n      xml.Append(pNode-&gt;Name());\n      if(pNode-&gt;HasAttribute()){\n         xml.Append(' ');\n         TAttributesIteratorC iterator = pNode-&gt;Attributes()-&gt;IteratorC();\n         while(iterator.Next()){\n            xml.Append(iterator.Name());\n            xml.Append(&quot;=\&quot;&quot;);\n            RXml::MakeNodeAttribute(xml, iterator.Value());\n            xml.Append('&quot;');\n            if(iterator.HasNext()){\n               xml.Append(' ');\n            }\n         }\n      }\n      if(pNode-&gt;HasNode()){\n         xml.Append(&quot;&gt;\n&quot;);\n         // 处理所有子节点\n         TListIteratorC&lt;FXmlNode*&gt; iterator = pNode-&gt;Nodes()-&gt;IteratorC();\n         while(iterator.Next()){\n            InnerBuildXml(xml, iterator.Get(), level + 1);\n         }\n         // 关闭节点\n         xml.AppendRepeat(&quot;   &quot;, level);\n         xml.Append(&quot;&lt;/&quot;);\n         xml.Append(pNode-&gt;Name());\n         xml.Append(&quot;&gt;\n&quot;);\n      }else if(pNode-&gt;HasText()){\n         xml.Append(&quot;&gt;&quot;);\n         RXml::MakeNodeText(xml, pNode-&gt;Text());\n         xml.Append(&quot;&lt;/&quot;);\n         xml.Append(pNode-&gt;Name());\n         xml.Append(&quot;&gt;\n&quot;);\n      }else{\n         xml.Append(&quot;/&gt;\n&quot;);\n      }\n   }\n}</Source>
                  </Method>
                  <Method name="Document" description="获得文档对象。">
                     <Return type="FXmlDocument*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得文档对象。&lt;/T&gt;\n//============================================================\n\nFXmlDocument* FXmlNode::Document(){\n   return _pDocument;\n}</Source>
                  </Method>
                  <Method name="NodeType" description="获得节点类型。">
                     <Return type="EXmlNodeType"/>
                     <Source>//============================================================\n// &lt;T&gt;获得节点类型。&lt;/T&gt;\n//\n// @return 节点类型\n//============================================================\n\nEXmlNodeType FXmlNode::NodeType(){\n   return _nodeType;\n}</Source>
                  </Method>
                  <Method name="IsName" description="判断节点的名称是否为指定名称。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;相等"/>
                        <L value="value='EFalse'&gt;不等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断节点的名称是否为指定名称。&lt;/T&gt;\n//\n// @param pName 名称\n// @return\n//    &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;不等&lt;/L&gt;\n//============================================================\n\nTBool FXmlNode::IsName(TCharC* pName){\n   return _name.EqualsIgnoreCase(pName);\n}</Source>
                  </Method>
                  <Method name="Name" description="获得节点名称。">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得节点名称。&lt;/T&gt;\n//\n// @return 节点名称\n//============================================================\n\nTCharC* FXmlNode::Name(){\n   return _name.MemoryC();\n}</Source>
                  </Method>
                  <Method name="SetName" description="设置节点名称。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置节点名称。&lt;/T&gt;\n//\n// @param name 节点名称\n//============================================================\n\nvoid FXmlNode::SetName(TCharC* pName){\n   _name.Assign(pName);\n}</Source>
                  </Method>
                  <Method name="IsAttribute" description="判断节点的属性名称的内容是否为指定内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pAttrName"/>
                        <Parameter type="TCharC*" name="pAttrValue"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;相等"/>
                        <L value="value='EFalse'&gt;不等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断节点的属性名称的内容是否为指定内容。&lt;/T&gt;\n//\n// @param pAttrName 属性名称\n// @param pAttrValue 属性内容\n// @return\n//    &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;不等&lt;/L&gt;\n//============================================================\n\nTBool FXmlNode::IsAttribute(TCharC* pAttrName, TCharC* pAttrValue){\n   if(NULL == _pAttributes){\n      return EFalse;\n   }\n   TCharC* pValue = _pAttributes-&gt;Get(pAttrName);\n   TBool result = EFalse;\n   if(NULL != pValue){\n      if(0 == strcmp(pAttrValue, pValue)){\n         result = ETrue;\n      }\n   }\n   return result;\n}</Source>
                  </Method>
                  <Method name="HasText" description="获得节点内容。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;获得节点内容。&lt;/T&gt;\n//\n// @return 节点内容\n//============================================================\n\nTBool FXmlNode::HasText(){\n   return !_text.IsEmpty();\n}</Source>
                  </Method>
                  <Method name="Text" description="获得节点内容。">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得节点内容。&lt;/T&gt;\n//\n// @return 节点内容\n//============================================================\n\nTCharC* FXmlNode::Text(){\n   return _text.MemoryC();\n}</Source>
                  </Method>
                  <Method name="TextAsBool" description="以布尔格式，获得节点内容，如果节点内容为空，则返回默认值。">
                     <Parameters>
                        <Parameter type="TBool" name="nvl" default="EFalse"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;以布尔格式，获得节点内容，如果节点内容为空，则返回默认值。&lt;/T&gt;\n//\n// @param nvl 节点内容为空时的取值\n// @return 布尔内容\n//============================================================\n\nTBool FXmlNode::TextAsBool(TBool nvl){\n   return _text.IsEmpty() ? nvl : RBool::IsTrue(_text.MemoryC());\n}</Source>
                  </Method>
                  <Method name="TextAsInt" description="以整数格式，获得节点内容，如果节点内容为空，则返回默认值。">
                     <Parameters>
                        <Parameter type="TInt" name="nvl" default="0"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;以整数格式，获得节点内容，如果节点内容为空，则返回默认值。&lt;/T&gt;\n//\n// @param nvl 节点内容为空时的取值\n// @return 整数内容\n//============================================================\n\nTInt FXmlNode::TextAsInt(TInt nvl){\n   return _text.IsEmpty() ? nvl : atoi(_text.MemoryC());\n}</Source>
                  </Method>
                  <Method name="TextAsFloat" description="以浮点数格式，获得节点内容，如果节点内容为空，则返回默认值。">
                     <Parameters>
                        <Parameter type="TFloat" name="nvl" default="0"/>
                     </Parameters>
                     <Return type="TFloat"/>
                     <Source>//============================================================\n// &lt;T&gt;以浮点数格式，获得节点内容，如果节点内容为空，则返回默认值。&lt;/T&gt;\n//\n// @param nvl 节点内容为空时的取值\n// @return 浮点数内容\n//============================================================\n\nTFloat FXmlNode::TextAsFloat(TFloat nvl){\n   return _text.IsEmpty() ? nvl : (TFloat)atof(_text.MemoryC());\n}</Source>
                  </Method>
                  <Method name="GetText" description="获得节点内容。">
                     <Parameters>
                        <Parameter type="TChar*" name="pText"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;获得节点内容。&lt;/T&gt;\n//\n// @param pText 数据指针\n// @param length 数据长度\n//============================================================\n\nvoid FXmlNode::GetText(TChar* pText, TInt length){\n   MO_ASSERT(pText);\n   TInt copyed = MO_MIN(_text.Length(), length - 1);\n   memcpy(pText, _text.MemoryC(), copyed);\n   pText[copyed] = 0;\n}</Source>
                  </Method>
                  <Method name="SetText" description="设置节点内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pText"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置节点内容。&lt;/T&gt;\n//\n// @param text 节点内容\n//============================================================\n\nvoid FXmlNode::SetText(TCharC* pText){\n   _text.Assign(pText);\n}</Source>
                  </Method>
                  <Method name="SetTextBool" description="用布尔值设置节点内容。">
                     <Parameters>
                        <Parameter type="TBool" name="text"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;用布尔值设置节点内容。&lt;/T&gt;\n//\n// @param text 节点内容\n//============================================================\n\nvoid FXmlNode::SetTextBool(TBool text){\n   _text.Assign(RBool::ToString(text));\n}</Source>
                  </Method>
                  <Method name="SetTextInt" description="用整数设置节点内容。">
                     <Parameters>
                        <Parameter type="TInt" name="text"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;用整数设置节点内容。&lt;/T&gt;\n//\n// @param text 节点内容\n//============================================================\n\nvoid FXmlNode::SetTextInt(TInt text){\n   TChar pBuffer[MO_INT_MAXLENGTH];\n   _text.Assign(RInt::ToString(text, pBuffer, MO_INT_MAXLENGTH));\n}</Source>
                  </Method>
                  <Method name="SetTextFloat" description="用浮点数设置节点内容。">
                     <Parameters>
                        <Parameter type="TFloat" name="text"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;用浮点数设置节点内容。&lt;/T&gt;\n//\n// @param text 节点内容\n//============================================================\n\nvoid FXmlNode::SetTextFloat(TFloat text){\n   TChar buffer[MO_FLOAT_MAXLENGTH];\n   _text.Assign(RFloat::ToString(text, buffer, MO_FLOAT_MAXLENGTH));\n}</Source>
                  </Method>
                  <Method name="TextAppend" description="追加文本内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pText"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;追加文本内容。&lt;/T&gt;\n//\n// @param pText 文本内容\n//============================================================\n\nvoid FXmlNode::TextAppend(TCharC* pText){\n   _text.Append(pText);\n}</Source>
                  </Method>
                  <Method name="HasAttribute" description="判断是否存在属性。">
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;存在"/>
                        <L value="value='EFalse'&gt;不存在"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断是否存在属性。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;存在&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;不存在&lt;/L&gt;\n//============================================================\n\nTBool FXmlNode::HasAttribute(){\n   return (NULL != _pAttributes) ? !_pAttributes-&gt;IsEmpty() : EFalse;\n}</Source>
                  </Method>
                  <Method name="Attributes" description="获得属性表。">
                     <Return type="FAttributes*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得属性表。&lt;/T&gt;\n//\n// @return 属性表\n//============================================================\n\nFAttributes* FXmlNode::Attributes(){\n   if(NULL == _pAttributes){\n      _pAttributes = MO_CREATE(FAttributes);\n      //_pAttributes-&gt;Set(_pDocument-&gt;IsCaseName());\n   }\n   return _pAttributes;\n}</Source>
                  </Method>
                  <Method name="Contains" description="是否含有属性。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;含有"/>
                        <L value="value='EFalse'&gt;不含有"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;是否含有属性。&lt;/T&gt;\n//\n// @param pName 属性名称\n// @return\n//    &lt;L value='ETrue'&gt;含有&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;不含有&lt;/L&gt;\n//============================================================\n\nTBool FXmlNode::Contains(TCharC* pName){\n   if(NULL == _pAttributes){\n      return EFalse;\n   }\n   return _pAttributes-&gt;Contains(pName);\n}</Source>
                  </Method>
                  <Method name="Get" description="根据属性名称，获得属性内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;根据属性名称，获得属性内容。&lt;/T&gt;\n//\n// @param pName 属性名称\n// @return 属性内容\n//============================================================\n\nTCharC* FXmlNode::Get(TCharC* pName){\n   if(NULL == _pAttributes){\n      return NULL;\n   }\n   return _pAttributes-&gt;Get(pName);\n}</Source>
                  </Method>
                  <Method name="Get" description="根据属性名称，获得属性内容，如果属性不存在，则返回默认值。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TCharC*" name="pDefault"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;根据属性名称，获得属性内容，如果属性不存在，则返回默认值。&lt;/T&gt;\n//\n// @param pName 属性名称\n// @return 属性内容\n//============================================================\n\nTCharC* FXmlNode::Get(TCharC* pName, TCharC* pDefault){\n   if(NULL == _pAttributes){\n      return NULL;\n   }\n   return _pAttributes-&gt;FindNvl(pName, pDefault);\n}</Source>
                  </Method>
                  <Method name="GetAsBool">
                     <Parameters>
                        <Parameter type="TBool" name="nvl" default="EFalse"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="GetAsInt">
                     <Parameters>
                        <Parameter type="TInt" name="nvl" default="0"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="GetAsFloat">
                     <Parameters>
                        <Parameter type="TFloat" name="nvl" default="0"/>
                     </Parameters>
                     <Return type="TFloat"/>
                  </Method>
                  <Method name="Set" description="根据属性名称，设置属性内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;根据属性名称，设置属性内容。&lt;/T&gt;\n//\n// @param pName 属性名称\n// @param pValue 属性内容\n//============================================================\n\nvoid FXmlNode::Set(TCharC* pName, TCharC* pValue){\n   Attributes()-&gt;Set(pName, pValue);\n}</Source>
                  </Method>
                  <Method name="SetBool" description="根据属性名称，设置属性内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TBool" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;根据属性名称，设置属性内容。&lt;/T&gt;\n//\n// @param pName 属性名称\n// @param value 属性内容\n//============================================================\n\nvoid FXmlNode::SetBool(TCharC* pName, TBool value){\n   Attributes()-&gt;Set(pName, RBool::ToString(value));\n}</Source>
                  </Method>
                  <Method name="SetInt" description="根据属性名称，设置属性内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TInt" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;根据属性名称，设置属性内容。&lt;/T&gt;\n//\n// @param pName 属性名称\n// @param value 属性内容\n//============================================================\n\nvoid FXmlNode::SetInt(TCharC* pName, TInt value){\n   TChar pBuffer[MO_INT_MAXLENGTH];\n   Attributes()-&gt;Set(pName, RInt::ToString(value, pBuffer, MO_INT_MAXLENGTH));\n}</Source>
                  </Method>
                  <Method name="SetFloat" description="根据属性名称，设置属性内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;根据属性名称，设置属性内容。&lt;/T&gt;\n//\n// @param pName 属性名称\n// @param value 属性内容\n//============================================================\n\nvoid FXmlNode::SetFloat(TCharC* pName, TFloat value){\n   TChar buffer[MO_FLOAT_MAXLENGTH];\n   Attributes()-&gt;Set(pName, RFloat::ToString(value, buffer, MO_FLOAT_MAXLENGTH));\n}</Source>
                  </Method>
                  <Method name="HasNode" description="判断是否存在节点。">
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;存在"/>
                        <L value="value='EFalse'&gt;不存在"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断是否存在节点。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;存在&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;不存在&lt;/L&gt;\n//============================================================\n\nTBool FXmlNode::HasNode(){\n   return (NULL != _pNodes) ? !_pNodes-&gt;IsEmpty() : EFalse;\n}</Source>
                  </Method>
                  <Method name="ContainsNode" description="是否含有指定名称的子节点。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;含有"/>
                        <L value="value='EFalse'&gt;不含有"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;是否含有指定名称的子节点。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;含有&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;不含有&lt;/L&gt;\n//============================================================\n\nTBool FXmlNode::ContainsNode(TCharC* pName){\n   return (NULL != FindNode(pName));\n}</Source>
                  </Method>
                  <Method name="ContainsNode" description="是否含有指定属性名称和属性内容的子节点。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pAttrName"/>
                        <Parameter type="TCharC*" name="pAttrValue"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;含有"/>
                        <L value="value='EFalse'&gt;不含有"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;是否含有指定属性名称和属性内容的子节点。&lt;/T&gt;\n//\n// @param pAttrName 属性名称\n// @param pAttrValue 属性内容\n// @return\n//    &lt;L value='ETrue'&gt;含有&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;不含有&lt;/L&gt;\n//============================================================\n\nTBool FXmlNode::ContainsNode(TCharC* pAttrName, TCharC* pAttrValue){\n   return (NULL != FindNode(pAttrName, pAttrValue));\n}</Source>
                  </Method>
                  <Method name="ContainsNode" description="是否含有指定节点名称，并属性名称和属性内容符合的子节点。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TCharC*" name="pAttrName"/>
                        <Parameter type="TCharC*" name="pAttrValue"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;含有"/>
                        <L value="value='EFalse'&gt;不含有"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;是否含有指定节点名称，并属性名称和属性内容符合的子节点。&lt;/T&gt;\n//\n// @param pName 属性名称\n// @param pAttrName 属性名称\n// @param pAttrValue 属性内容\n// @return\n//    &lt;L value='ETrue'&gt;含有&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;不含有&lt;/L&gt;\n//============================================================\n\nTBool FXmlNode::ContainsNode(TCharC* pName, TCharC* pAttrName, TCharC* pAttrValue){\n   return (NULL != FindNode(pName, pAttrName, pAttrValue));\n}</Source>
                  </Method>
                  <Method name="Nodes" description="获得子节点集合。">
                     <Return type="FXmlNodes*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得子节点集合。&lt;/T&gt;\n//\n// @return 子节点集合\n//============================================================\n\nFXmlNodes* FXmlNode::Nodes(){\n   if(NULL == _pNodes){\n      _pNodes = MO_CREATE(FXmlNodes);\n   }\n   return _pNodes;\n}</Source>
                  </Method>
                  <Method name="NodeIteratorC" description="获得子节点的迭代器。">
                     <Return type="TXmlNodeIteratorC"/>
                     <Source>//============================================================\n// &lt;T&gt;获得子节点的迭代器。&lt;/T&gt;\n//\n// @return 子节点迭代器\n//============================================================\n\nTXmlNodeIteratorC FXmlNode::NodeIteratorC(){\n   if(NULL == _pNodes){\n      return TXmlNodeIteratorC();\n   }\n   return _pNodes-&gt;IteratorC();\n}</Source>
                  </Method>
                  <Method name="Node" description="获得指定索引的子节点。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="FXmlNode*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得指定索引的子节点。&lt;/T&gt;\n//\n// @param index 索引位置\n// @return 子节点\n//============================================================\n\nFXmlNode* FXmlNode::Node(TInt index){\n   return HasNode() ? _pNodes-&gt;Get(index) : NULL;\n}</Source>
                  </Method>
                  <Method name="FindNode" description="获得指定名称的子节点。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="FXmlNode*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得指定名称的子节点。&lt;/T&gt;\n//\n// @param pName 子节点名称\n// @return 子节点\n//============================================================\n\nFXmlNode* FXmlNode::FindNode(TCharC* pName){\n   if(NULL != _pNodes){\n      TXmlNodeIteratorC iterator = _pNodes-&gt;IteratorC();\n      while(iterator.Next()){\n         if(iterator-&gt;IsName(pName)){\n            return iterator.Get();\n         }\n      }\n   }\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="FindNode" description="获得指定属性名称和属性内容的子节点。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pAttrName"/>
                        <Parameter type="TCharC*" name="pAttrValue"/>
                     </Parameters>
                     <Return type="FXmlNode*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得指定属性名称和属性内容的子节点。&lt;/T&gt;\n//\n// @param pAttrName 属性名称\n// @param pAttrValue 属性内容\n// @return 子节点\n//============================================================\n\nFXmlNode* FXmlNode::FindNode(TCharC* pAttrName, TCharC* pAttrValue){\n   if(NULL != _pNodes){\n      TXmlNodeIteratorC iterator = _pNodes-&gt;IteratorC();\n      while(iterator.Next()){\n         if(iterator-&gt;IsAttribute(pAttrName, pAttrValue)){\n            return iterator.Get();\n         }\n      }\n   }\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="FindNode" description="获得指定节点名称，并属性名称和属性内容符合的子节点。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TCharC*" name="pAttrName"/>
                        <Parameter type="TCharC*" name="pAttrValue"/>
                     </Parameters>
                     <Return type="FXmlNode*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得指定节点名称，并属性名称和属性内容符合的子节点。&lt;/T&gt;\n//\n// @param pName 节点名称\n// @param pAttrName 属性名称\n// @param pAttrValue 属性内容\n// @return 子节点\n//============================================================\n\nFXmlNode* FXmlNode::FindNode(TCharC* pName, TCharC* pAttrName, TCharC* pAttrValue){\n   if(NULL != _pNodes){\n      TXmlNodeIteratorC iterator = _pNodes-&gt;IteratorC();\n      while(iterator.Next()){\n         if(iterator-&gt;IsName(pName)){\n            if(iterator-&gt;IsAttribute(pAttrName, pAttrValue)){\n               return iterator.Get();\n            }\n         }\n      }\n   }\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="FindText" description="查找指定名称的子节点，获得子节点内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;查找指定名称的子节点，获得子节点内容。&lt;/T&gt;\n//\n// @param pName 子节点名称\n// @return 子节点内容\n//============================================================\n\nTCharC* FXmlNode::FindText(TCharC* pName){\n   FXmlNode* pNode = FindNode(pName);\n   return (NULL == pNode) ? NULL : pNode-&gt;Text();\n}</Source>
                  </Method>
                  <Method name="FindText" description="获得指定属性名称和属性内容的子节点内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pAttrName"/>
                        <Parameter type="TCharC*" name="pAttrValue"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得指定属性名称和属性内容的子节点内容。&lt;/T&gt;\n//\n// @param pAttrName 属性名称\n// @param pAttrValue 属性内容\n// @return 子节点内容\n//============================================================\n\nTCharC* FXmlNode::FindText(TCharC* pAttrName, TCharC* pAttrValue){\n   FXmlNode* pNode = FindNode(pAttrName, pAttrValue);\n   return (NULL == pNode) ? NULL : pNode-&gt;Text();\n}</Source>
                  </Method>
                  <Method name="FindText" description="获得指定节点名称，并属性名称和属性内容符合的子节点内容。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TCharC*" name="pAttrName"/>
                        <Parameter type="TCharC*" name="pAttrValue"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得指定节点名称，并属性名称和属性内容符合的子节点内容。&lt;/T&gt;\n//\n// @param pName 子节点名称\n// @param pAttrName 属性名称\n// @param pAttrValue 属性内容\n// @return 子节点内容\n//============================================================\n\nTCharC* FXmlNode::FindText(TCharC* pName, TCharC* pAttrName, TCharC* pAttrValue){\n   FXmlNode* pNode = FindNode(pName, pAttrName, pAttrValue);\n   return (NULL == pNode) ? NULL : pNode-&gt;Text();\n}</Source>
                  </Method>
                  <Method name="CreateNode" description="创建子节点，并将子节点加入当前节点内。">
                     <Return type="FXmlNode*"/>
                     <Source>//============================================================\n// &lt;T&gt;创建子节点，并将子节点加入当前节点内。&lt;/T&gt;\n//\n// @return 子节点\n//============================================================\n\nFXmlNode* FXmlNode::CreateNode(){\n   FXmlNode* pNode = _pDocument-&gt;CreateNode();\n   Nodes()-&gt;Push(pNode);\n   return pNode;\n}</Source>
                  </Method>
                  <Method name="CreateNode" description="创建子节点，并将子节点加入当前节点内。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="FXmlNode*"/>
                     <Source>//============================================================\n// &lt;T&gt;创建子节点，并将子节点加入当前节点内。&lt;/T&gt;\n//\n// @param pName 节点名称\n// @return 子节点\n//============================================================\n\nFXmlNode* FXmlNode::CreateNode(TCharC* pName){\n   FXmlNode* pNode = _pDocument-&gt;CreateNode();\n   pNode-&gt;SetName(pName);\n   Nodes()-&gt;Push(pNode);\n   return pNode;\n}</Source>
                  </Method>
                  <Method name="CreateNode" description="创建子节点，并将子节点加入当前节点内。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TCharC*" name="pAttributeName"/>
                        <Parameter type="TCharC*" name="pAttributeValue"/>
                     </Parameters>
                     <Return type="FXmlNode*"/>
                     <Source>//============================================================\n// &lt;T&gt;创建子节点，并将子节点加入当前节点内。&lt;/T&gt;\n// &lt;P&gt;创建时，初始化一个属性。&lt;/P&gt;\n//\n// @param pName 节点名称\n// @param pAttributeName 属性名称\n// @param pAttributeValue 属性内容\n// @return 子节点\n//============================================================\n\nFXmlNode* FXmlNode::CreateNode(TCharC* pName, TCharC* pAttributeName, TCharC* pAttributeValue){\n   FXmlNode* pNode = CreateNode(pName);\n   pNode-&gt;Set(pAttributeName, pAttributeValue);\n   return pNode;\n}</Source>
                  </Method>
                  <Method name="Push" description="将子节点加入当前节点内。">
                     <Parameters>
                        <Parameter type="FXmlNode*" name="pNode"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将子节点加入当前节点内。&lt;/T&gt;\n//\n// @param pNode 子节点\n//============================================================\n\nvoid FXmlNode::Push(FXmlNode* pNode){\n   Nodes()-&gt;Push(pNode);\n}</Source>
                  </Method>
                  <Method name="BuildXml" description="建立XML内容。">
                     <Parameters>
                        <Parameter type="TString&amp;" name="xml"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;建立XML内容。&lt;/T&gt;\n//\n// @param pXml XML内容\n//============================================================\n\nvoid FXmlNode::BuildXml(TString&amp; xml){\n   InnerBuildXml(xml, this, 0);\n}</Source>
                  </Method>
                  <Method name="Xml" description="获得配置节点的XML内容。">
                     <Return type="TString"/>
                     <Source>//============================================================\n// &lt;T&gt;获得配置节点的XML内容。&lt;/T&gt;\n//\n// @return XML内容\n//============================================================\n\nTString FXmlNode::Xml(){\n   TString xml;\n   InnerBuildXml(xml, this, 0);\n   return xml;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FXmlDocument*" name="_pDocument"/>
                  <Attribute type="EXmlNodeType" name="_nodeType"/>
                  <Attribute type="TString" name="_name"/>
                  <Attribute type="TString" name="_text"/>
                  <Attribute type="FAttributes*" name="_pAttributes"/>
                  <Attribute type="FXmlNodes*" name="_pNodes"/>
               </Attributes>
            </Class>
            <Class name="FXmlNodes">
               <Inherits name="FXmlNodeList" scope="public"/>
               <Methods>
                  <Method name="IteratorC" description="获得只读迭代器。">
                     <Return type="TXmlNodeIteratorC"/>
                     <Source>//============================================================\n// &lt;T&gt;获得只读迭代器。&lt;/T&gt;\n//\n// @return 只读迭代器\n//============================================================\n\nTXmlNodeIteratorC FXmlNodes::IteratorC(){\n   return TXmlNodeIteratorC(_pFirst);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="IAllocator">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Alloc" flag="virtual">
                     <Parameters>
                        <Parameter type="TUint" name="size" default="0"/>
                     </Parameters>
                     <Return type="TAny*"/>
                  </Method>
                  <Method name="Alloc" flag="virtual">
                     <Parameters>
                        <Parameter type="TCharC*" name="pClassName"/>
                        <Parameter type="TUint" name="size"/>
                        <Parameter type="TChar8C*" name="pFileName"/>
                        <Parameter type="TInt" name="fileLine"/>
                     </Parameters>
                     <Return type="TAny*"/>
                  </Method>
                  <Method name="Free" flag="virtual">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IAtomAllocator">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Alloc" flag="virtual">
                     <Return type="T*"/>
                  </Method>
                  <Method name="Free" flag="virtual">
                     <Parameters>
                        <Parameter type="T*" name="pAtom"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="MultiAlloc" flag="virtual">
                     <Parameters>
                        <Parameter type="TUint" name="count"/>
                     </Parameters>
                     <Return type="T*"/>
                  </Method>
                  <Method name="MultiFree" flag="virtual">
                     <Parameters>
                        <Parameter type="TAny*" name="pAtoms"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="MultiPtrAlloc" flag="virtual">
                     <Parameters>
                        <Parameter type="TUint" name="count"/>
                     </Parameters>
                     <Return type="T**"/>
                  </Method>
                  <Method name="MultiPtrFree" flag="virtual">
                     <Parameters>
                        <Parameter type="T**" name="ppAtomss"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IClass"/>
            <Class name="IComparable">
               <Methods>
                  <Method name="Compare" flag="virtual">
                     <Parameters>
                        <Parameter type="IComparable&lt;T&gt;&amp;" name="source"/>
                     </Parameters>
                     <Return type="TResult"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IComparer">
               <Methods>
                  <Method name="Compare" flag="virtual">
                     <Parameters>
                        <Parameter type="T" name="source"/>
                        <Parameter type="T" name="target"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IConfig">
               <Methods>
                  <Method name="LoadConfig" flag="virtual">
                     <Parameters>
                        <Parameter type="FXmlNode*" name="pConfig"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IConfiguration">
               <Inherits>
                  <Inherit name="IConfig" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Name" flag="virtual">
                     <Return type="TCharC*"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IConsole">
               <Methods>
                  <Method name="OnSerialize" flag="virtual">
                     <Return type="void"/>
                  </Method>
                  <Method name="OnUnserialize" flag="virtual">
                     <Return type="void"/>
                  </Method>
                  <Method name="Suspend" flag="virtual">
                     <Return type="void"/>
                  </Method>
                  <Method name="Resume" flag="virtual">
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IDataInput">
               <Inherits>
                  <Inherit name="IInput" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="ReadBoolean" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="ReadInt" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="ReadInt8" flag="virtual">
                     <Return type="TInt8"/>
                  </Method>
                  <Method name="ReadInt16" flag="virtual">
                     <Return type="TInt16"/>
                  </Method>
                  <Method name="ReadInt32" flag="virtual">
                     <Return type="TInt32"/>
                  </Method>
                  <Method name="ReadInt64" flag="virtual">
                     <Return type="TInt64"/>
                  </Method>
                  <Method name="ReadUint" flag="virtual">
                     <Return type="TUint"/>
                  </Method>
                  <Method name="ReadUint8" flag="virtual">
                     <Return type="TUint8"/>
                  </Method>
                  <Method name="ReadUint16" flag="virtual">
                     <Return type="TUint16"/>
                  </Method>
                  <Method name="ReadUint32" flag="virtual">
                     <Return type="TUint32"/>
                  </Method>
                  <Method name="ReadUint64" flag="virtual">
                     <Return type="TUint64"/>
                  </Method>
                  <Method name="ReadFloat" flag="virtual">
                     <Return type="TFloat"/>
                  </Method>
                  <Method name="ReadDouble" flag="virtual">
                     <Return type="TDouble"/>
                  </Method>
                  <Method name="ReadString" flag="virtual">
                     <Parameters>
                        <Parameter type="TChar8*" name="pMemory"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="ReadString" flag="virtual">
                     <Parameters>
                        <Parameter type="TChar16*" name="pMemory"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="ReadString" flag="virtual">
                     <Return type="TString"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IDataOutput">
               <Inherits>
                  <Inherit name="IOutput" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="WriteBoolean" flag="virtual">
                     <Parameters>
                        <Parameter type="TBool" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteInt" flag="virtual">
                     <Parameters>
                        <Parameter type="TInt" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteInt8" flag="virtual">
                     <Parameters>
                        <Parameter type="TInt8" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteInt16" flag="virtual">
                     <Parameters>
                        <Parameter type="TInt16" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteInt32" flag="virtual">
                     <Parameters>
                        <Parameter type="TInt32" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteInt64" flag="virtual">
                     <Parameters>
                        <Parameter type="TInt64" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteUint" flag="virtual">
                     <Parameters>
                        <Parameter type="TUint" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteUint8" flag="virtual">
                     <Parameters>
                        <Parameter type="TUint8" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteUint16" flag="virtual">
                     <Parameters>
                        <Parameter type="TUint16" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteUint32" flag="virtual">
                     <Parameters>
                        <Parameter type="TUint32" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteUint64" flag="virtual">
                     <Parameters>
                        <Parameter type="TUint64" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteFloat" flag="virtual">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteDouble" flag="virtual">
                     <Parameters>
                        <Parameter type="TDouble" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteString" flag="virtual">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pMemory"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteString" flag="virtual">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pMemory"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="WriteString" flag="virtual">
                     <Parameters>
                        <Parameter type="MStringC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IDataReader">
               <Inherits>
                  <Inherit name="IReader" scope="public"/>
               </Inherits>
            </Class>
            <Class name="IDataWriter">
               <Inherits>
                  <Inherit name="IWriter" scope="public"/>
               </Inherits>
            </Class>
            <Class name="IDispose"/>
            <Class name="IDump"/>
            <Class name="IEntityStore">
               <Methods>
                  <Method name="WriteEntry" flag="virtual">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IInitialize">
               <Methods>
                  <Method name="Initialize" flag="virtual">
                     <Return type="TResult"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IInput">
               <Methods>
                  <Method name="Read" flag="virtual">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IListener">
               <Methods>
                  <Method name="Owner" flag="virtual">
                     <Return type="FObject*"/>
                  </Method>
                  <Method name="Sender" flag="virtual">
                     <Return type="FObject*"/>
                  </Method>
                  <Method name="Process" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="ILoggerConsole">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Output" flag="virtual">
                     <Parameters>
                        <Parameter type="TInt" name="type"/>
                        <Parameter type="TLoggerLevel" name="level"/>
                        <Parameter type="TAny*" name="pSender"/>
                        <Parameter type="TCharC*" name="pMethod"/>
                        <Parameter type="TDateTime" name="start"/>
                        <Parameter type="TCharC*" name="pMessage"/>
                        <Parameter type="va_list" name="params"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="ILoggerWriter">
               <Methods>
                  <Method name="Open" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Create" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Code" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Write" flag="virtual">
                     <Parameters>
                        <Parameter type="TCharC*" name="pMessage"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Close" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IMonitor">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="IsName" flag="virtual">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Name" flag="virtual">
                     <Return type="TCharC*"/>
                  </Method>
                  <Method name="Total" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Count" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Delay" flag="virtual">
                     <Return type="TTimeSpan"/>
                  </Method>
                  <Method name="Interval" flag="virtual">
                     <Return type="TTimeSpan"/>
                  </Method>
                  <Method name="Test" flag="virtual">
                     <Parameters>
                        <Parameter type="TTimeSpan" name="interval"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="LoadConfig" flag="virtual">
                     <Parameters>
                        <Parameter type="FXmlNode*" name="pConfig"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Process" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="INetConnection">
               <Inherits>
                  <Inherit name="INetObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Start" flag="virtual">
                     <Return type="void"/>
                  </Method>
                  <Method name="Stop" flag="virtual">
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="INetObject">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
            </Class>
            <Class name="INetSocket">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Connection" flag="virtual">
                     <Return type="INetConnection*"/>
                  </Method>
                  <Method name="Handle" flag="virtual">
                     <Return type="TSocket"/>
                  </Method>
                  <Method name="Host" flag="virtual">
                     <Return type="TCharC*"/>
                  </Method>
                  <Method name="Port" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="IsConnected" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="SetReuseAddress" flag="virtual">
                     <Parameters>
                        <Parameter type="TBool" name="flag"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="SetDontLinger" flag="virtual">
                     <Parameters>
                        <Parameter type="TBool" name="flag"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="SetLinger" flag="virtual">
                     <Parameters>
                        <Parameter type="TInt" name="time" default="0"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="SetSendTimeout" flag="virtual">
                     <Parameters>
                        <Parameter type="TInt" name="timeout"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="SetReceiveTimeout" flag="virtual">
                     <Parameters>
                        <Parameter type="TInt" name="timeout"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="SetSendBufferSize" flag="virtual">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="SetReceiveBufferSize" flag="virtual">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="SetNonBlock" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Receive" flag="virtual">
                     <Parameters>
                        <Parameter type="TByte*" name="pBuffer"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Send" flag="virtual">
                     <Parameters>
                        <Parameter type="TByteC*" name="pBuffer"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Close" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="INetSocketPool">
               <Inherits>
                  <Inherit name="INetObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Handle" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Add" flag="virtual">
                     <Parameters>
                        <Parameter type="INetSocket*" name="pSocket"/>
                        <Parameter type="TUint" name="flag"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Modify" flag="virtual">
                     <Parameters>
                        <Parameter type="INetSocket*" name="pSocket"/>
                        <Parameter type="TUint" name="flag"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Remove" flag="virtual">
                     <Parameters>
                        <Parameter type="INetSocket*" name="pSocket"/>
                        <Parameter type="TUint" name="flag"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IOutput">
               <Methods>
                  <Method name="Write" flag="virtual">
                     <Parameters>
                        <Parameter type="TAnyC*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IPipe">
               <Methods>
                  <Method name="IsEmpty" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Length" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Reamin" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Peek" flag="virtual">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="TryRead" flag="virtual">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="TryWrite" flag="virtual">
                     <Parameters>
                        <Parameter type="TAnyC*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Close" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IReader">
               <Methods>
                  <Method name="Read" flag="virtual">
                     <Parameters>
                        <Parameter type="TChar*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IReleasable">
               <Methods>
                  <Method name="AddRefer" flag="virtual">
                     <Return type="TResult"/>
                  </Method>
                  <Method name="Release" flag="virtual">
                     <Return type="TResult"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="ISerialize">
               <Methods>
                  <Method name="Serialize" flag="virtual">
                     <Parameters>
                        <Parameter type="IDataOutput*" name="pOutput"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Unserialize" flag="virtual">
                     <Parameters>
                        <Parameter type="IDataInput*" name="pInput"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IShareAllocator">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="IsLinked" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Create" flag="virtual">
                     <Parameters>
                        <Parameter type="TShareKey" name="key"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="TryCreate" flag="virtual">
                     <Parameters>
                        <Parameter type="TShareKey" name="key"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Connect" flag="virtual">
                     <Parameters>
                        <Parameter type="TShareKey" name="key"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="MemoryC" flag="virtual">
                     <Return type="TAny*"/>
                  </Method>
                  <Method name="Alloc" flag="virtual">
                     <Parameters>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TAny*"/>
                  </Method>
                  <Method name="Skip" flag="virtual">
                     <Parameters>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="CreateSegment" flag="virtual">
                     <Parameters>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TShareSegment"/>
                  </Method>
                  <Method name="Free" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="ISingleton">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="SingletonType" flag="virtual">
                     <Return type="ESingleton"/>
                  </Method>
                  <Method name="Code" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Name" flag="virtual">
                     <Return type="TCharC*"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="ISqlConnection">
               <Methods>
                  <Method name="Id" flag="virtual">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Host" flag="virtual">
                     <Return type="TCharC*"/>
                  </Method>
                  <Method name="Port" flag="virtual">
                     <Return type="TUint16"/>
                  </Method>
                  <Method name="UserName" flag="virtual">
                     <Return type="TCharC*"/>
                  </Method>
                  <Method name="Password" flag="virtual">
                     <Return type="TCharC*"/>
                  </Method>
                  <Method name="Database" flag="virtual">
                     <Return type="TCharC*"/>
                  </Method>
                  <Method name="Connect" flag="virtual">
                     <Return type="void"/>
                  </Method>
                  <Method name="Commit" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Rollback" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Close" flag="virtual">
                     <Return type="void"/>
                  </Method>
                  <Method name="ExecuteInsertSql" flag="virtual">
                     <Parameters>
                        <Parameter type="TCharC*" name="sql"/>
                        <Parameter type="TInt&amp;" name="lastId"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="ExecuteSql" flag="virtual">
                     <Parameters>
                        <Parameter type="TCharC*" name="sql"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Find" flag="virtual">
                     <Parameters>
                        <Parameter type="TCharC*" name="sql"/>
                        <Parameter type="ISqlRowFill*" name="pFill"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Fetch" flag="virtual">
                     <Parameters>
                        <Parameter type="TCharC*" name="sql"/>
                        <Parameter type="ISqlRowFill**" name="ppFills"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Find" flag="virtual">
                     <Parameters>
                        <Parameter type="TCharC*" name="sql"/>
                        <Parameter type="ISqlRowFiller*" name="pFiller"/>
                        <Parameter type="TAny*" name="pRow"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Fetch" flag="virtual">
                     <Parameters>
                        <Parameter type="TCharC*" name="sql"/>
                        <Parameter type="ISqlRowFiller*" name="pFiller"/>
                        <Parameter type="TAny**" name="ppRows"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="ISqlRowFill">
               <Methods>
                  <Method name="Fill" flag="virtual">
                     <Parameters>
                        <Parameter type="TChar**" name="ppValues"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="ISqlRowFiller">
               <Methods>
                  <Method name="Fill" flag="virtual">
                     <Parameters>
                        <Parameter type="TAny*" name="pRow"/>
                        <Parameter type="TChar**" name="ppValues"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IStatic">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Initialize" flag="virtual">
                     <Return type="void"/>
                  </Method>
                  <Method name="Release" flag="virtual">
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IStreamInput">
               <Inherits>
                  <Inherit name="IInput" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Flip" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Close" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IStreamOutput">
               <Inherits>
                  <Inherit name="IOutput" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Flush" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Close" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IStreamReader">
               <Inherits>
                  <Inherit name="IReader" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Flip" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Close" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IStreamWriter">
               <Inherits>
                  <Inherit name="IWriter" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Flush" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Close" flag="virtual">
                     <Return type="TBool"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IThread">
               <Methods>
                  <Method name="Handle" flag="virtual">
                     <Return type="TThreadHandle"/>
                  </Method>
                  <Method name="ThreadId" flag="virtual">
                     <Return type="TThreadId"/>
                  </Method>
                  <Method name="Priority" flag="virtual">
                     <Return type="EThreadPriority"/>
                  </Method>
                  <Method name="Start" flag="virtual">
                     <Return type="void"/>
                  </Method>
                  <Method name="Suspend" flag="virtual">
                     <Return type="void"/>
                  </Method>
                  <Method name="Resume" flag="virtual">
                     <Return type="void"/>
                  </Method>
                  <Method name="Join" flag="virtual">
                     <Parameters>
                        <Parameter type="IThread*" name="pThread"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Wait" flag="virtual">
                     <Return type="TAny*"/>
                  </Method>
                  <Method name="Stop" flag="virtual">
                     <Return type="void"/>
                  </Method>
                  <Method name="Terminate" flag="virtual">
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IThreadConsole">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Register" flag="virtual">
                     <Parameters>
                        <Parameter type="FThread*" name="pThread"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Unregister" flag="virtual">
                     <Parameters>
                        <Parameter type="FThread*" name="pThread"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Current" flag="virtual">
                     <Return type="FThread*"/>
                  </Method>
                  <Method name="Get" flag="virtual">
                     <Parameters>
                        <Parameter type="TThreadId" name="threadId"/>
                     </Parameters>
                     <Return type="FThread*"/>
                  </Method>
                  <Method name="Find" flag="virtual">
                     <Parameters>
                        <Parameter type="TThreadId" name="threadId" default="0"/>
                     </Parameters>
                     <Return type="FThread*"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="IThreadPool">
               <Inherits>
                  <Inherit name="IDispose" scope="public"/>
               </Inherits>
            </Class>
            <Class name="IWriter">
               <Methods>
                  <Method name="Write" flag="virtual">
                     <Parameters>
                        <Parameter type="TCharC*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="MArray">
               <Inherits>
                  <Inherit name="MArrayC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerCast" type="inline" description="获得内部类型指针。">
                     <Return type="A*"/>
                     <Source>\ninline A* InnerCast(){\n      return static_cast&lt;A*&gt;(this);\n   }</Source>
                  </Method>
                  <Method name="operator[]" description="设置指定位置的数据内容。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T&amp;"/>
                     <Source>\nT&amp; operator[](TInt index){\n      MO_ASSERT_RANGE(index, 0, this-&gt;_length);\n      return this-&gt;_pMemory[index];\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="追加一个数据到当前数组尾部。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(T value){\n      Push(value);\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="追加一个数组到当前数组尾部。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(const MPtrC&lt;T&gt;&amp; ptr){\n      Append(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="T*" description="获得数据指针">
                     <Return type="operator"/>
                     <Source>\noperator T*(){\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="Memory" description="获得数据指针。">
                     <Return type="T*"/>
                     <Source>\nT* Memory(){\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="Ptr" description="获取当前数组的指针对象。">
                     <Return type="TPtr&lt;T&gt;"/>
                     <Source>\nTPtr&lt;T&gt; Ptr() const{\n      return TPtr&lt;T&gt;(this-&gt;_pMemory, this-&gt;_length, this-&gt;_size);\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接受一个变长数组到当前数组尾部。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const T* pValues, TInt length){\n      InnerCast()-&gt;A::EnsureSize(length);\n      this-&gt;_length = length;\n      RTypes&lt;T&gt;::Copy(this-&gt;_pMemory, pValues, length);\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接受一个变长数组到当前数组尾部。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MPtrC&lt;T&gt;&amp; ptr){\n      Assign(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个数组指针到当前数组尾部。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const T* pValues, TInt length){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + length);\n      RTypes&lt;T&gt;::Copy(this-&gt;_pMemory + this-&gt;_length, pValues, length);\n      this-&gt;_length += length;\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个变长数组对象到当前数组尾部。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MPtrC&lt;T&gt;&amp; ptr){\n      Append(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="Shift" description="从首部弹出一个数据。">
                     <Return type="T"/>
                     <Source>\nT Shift(){\n      MO_ASSERT(this-&gt;_length);\n      T value = this-&gt;_pMemory[0];\n      this-&gt;_length--;\n      if(this-&gt;_length &gt; 0){\n         RTypes&lt;T&gt;::Move(this-&gt;_pMemory, this-&gt;_pMemory + 1, this-&gt;_length);\n      }\n      return value;\n   }</Source>
                  </Method>
                  <Method name="Unshift" description="从首部压入一个数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Unshift(T value){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      if(this-&gt;_length &gt; 0){\n         RTypes&lt;T&gt;::Move(this-&gt;_pMemory + 1, this-&gt;_pMemory, this-&gt;_length);\n      }\n      this-&gt;_pMemory[0] = value;\n      this-&gt;_length++;\n   }</Source>
                  </Method>
                  <Method name="Pop" description="从尾部弹出一个数据。">
                     <Return type="T"/>
                     <Source>\nT Pop(){\n      MO_ASSERT(this-&gt;_length);\n      return this-&gt;_pMemory[--this-&gt;_length];\n   }</Source>
                  </Method>
                  <Method name="Push" description="追加一个数据到当前数组尾部。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Push(T value){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      this-&gt;_pMemory[this-&gt;_length++] = value;\n   }</Source>
                  </Method>
                  <Method name="Insert" description="插入一个数据在指定位置。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Insert(TInt index, T value){\n      MO_ASSERT_BETWEEN(index, 0, this-&gt;_length);\n	   InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      RTypes&lt;T&gt;::Move(this-&gt;_pMemory + index + 1, this-&gt;_pMemory + index, this-&gt;_length - index);\n      this-&gt;_pMemory[index] = value;\n	   this-&gt;_length++;\n   }</Source>
                  </Method>
                  <Method name="Insert" description="插入一个数据指针在指定位置。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Insert(TInt index, const T* pValues, TInt length){\n      MO_ASSERT_BETWEEN(index, 0, this-&gt;_length);\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + length);\n      RTypes&lt;T&gt;::Move(this-&gt;_pMemory + index + length, this-&gt;_pMemory + index, this-&gt;_length - index);\n      RTypes&lt;T&gt;::Copy(this-&gt;_pMemory + index, pValues, length);\n      this-&gt;_length += length;\n   }</Source>
                  </Method>
                  <Method name="Insert" description="插入一个数组在指定位置。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Insert(TInt index, const MPtrC&lt;T&gt;&amp; ptr){\n      Insert(index, ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="Fill" description="使用指定内容填充当前数组。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Fill(T value){\n      RTypes&lt;T&gt;::Fill(this-&gt;_pMemory, this-&gt;_length, value);\n   }</Source>
                  </Method>
                  <Method name="Fill" description="使用指定内容和指定个数填充当前数组。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Fill(T value, TInt length){\n      MO_ASSERT_RANGE(length, 0, length)\n      RTypes&lt;T&gt;::Fill(this-&gt;_pMemory, length, value);\n   }</Source>
                  </Method>
                  <Method name="Fill" description="使用指定内容和指定个数从指定位置填充当前数组。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                        <Parameter type="TInt" name="offset"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Fill(T value, TInt offset, TInt length){\n      MO_ASSERT_RANGE(length, 0, this-&gt;_length - offset)\n      RTypes&lt;T&gt;::Fill(this-&gt;_pMemory + offset, length, value);\n   }</Source>
                  </Method>
                  <Method name="Replace" description="从源内容替换为目标内容。">
                     <Parameters>
                        <Parameter type="T" name="source"/>
                        <Parameter type="T" name="target"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Replace(T source, T target){\n      RTypes&lt;T&gt;::Replace(this-&gt;_pMemory, this-&gt;_length, source, target);\n   }</Source>
                  </Method>
                  <Method name="Replace" description="从源数组替换为目标数组。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="source"/>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="target"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Replace(const MPtrC&lt;T&gt;&amp; source, const MPtrC&lt;T&gt;&amp; target){\n      TInt position = 0;\n      TInt pos = RTypes&lt;T&gt;::Find(this-&gt;_pMemory, this-&gt;_length, source.MemoryC(), source.Length());\n      if(ENotFound != pos){\n         TInt n = target.Length() - source.Length();\n         TInt max = MO_MAX(target.Length(), source.Length());\n         while(ENotFound != pos){\n            if(n &lt; 0){\n               position += pos + max;\n               RTypes&lt;T&gt;::Copy(this-&gt;_pMemory + position, target.MemoryC(), target.Length());\n               RTypes&lt;T&gt;::Move(this-&gt;_pMemory + position + source.Length(), this-&gt;_pMemory + position + target.Length(), this-&gt;_length - position - source.Length());\n            }else if(n &gt; 0){\n               InnerCast()-&gt;A::EnsureSize(this-&gt;_length + n);\n               RTypes&lt;T&gt;::Move(this-&gt;_pMemory + position + source.Length(), this-&gt;_pMemory + position + target.Length(), this-&gt;_length - position - source.Length());\n               RTypes&lt;T&gt;::Copy(this-&gt;_pMemory + position, target.MemoryC(), target.Length());\n            }\n            this-&gt;_length += n;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Swap" description="交换当前数组中两个位置的值。">
                     <Parameters>
                        <Parameter type="TInt" name="from"/>
                        <Parameter type="TInt" name="to"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Swap(TInt from, TInt to){\n      MO_ASSERT_RANGE(from, 0, this-&gt;_length);\n      MO_ASSERT_RANGE(to, 0, this-&gt;_length);\n      if(from != to){\n         T value = this-&gt;_pMemory[from];\n   	   this-&gt;_pMemory[from] = this-&gt;_pMemory[to];\n         this-&gt;_pMemory[to] = value;\n      }\n   }</Source>
                  </Method>
                  <Method name="Delete" description="删除指定位置的数据。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Delete(TInt index){\n      MO_ASSERT_RANGE(index, 0, this-&gt;_length);\n      T value = this-&gt;_pMemory[index];\n      if(index != this-&gt;_length - 1){\n         RTypes&lt;T&gt;::Move(this-&gt;_pMemory + index, this-&gt;_pMemory + index + 1, this-&gt;_length - index);\n      }\n      this-&gt;_length--;\n      return value;\n   }</Source>
                  </Method>
                  <Method name="Delete" description="删除指定位置起的长度的数据。" note="如果长度超过，则删除指定位置到结束位置之间的数据">
                     <Parameters>
                        <Parameter type="TInt" name="offset"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Delete(TInt offset, TInt length){\n      MO_ASSERT_RANGE(offset, 0, this-&gt;_length);\n      MO_ASSERT_RANGE(length, 0, this-&gt;_length - offset);\n      TInt count = this-&gt;_length - offset - length;\n      if(count &gt; 0){\n         RTypes&lt;T&gt;::Move(this-&gt;_pMemory + offset, this-&gt;_pMemory + offset + length, MO_MIN(count, length));\n      }\n      this-&gt;_length -= length;\n   }</Source>
                  </Method>
                  <Method name="Remove" description="移除指定数据。" note="可能会移除多个相同的数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Remove(T value){\n      TInt position = 0;\n      TInt n = -1;\n      while(++n &lt; this-&gt;_length){\n         if(this-&gt;_pMemory[n] != value){\n            this-&gt;_pMemory[position++] = this-&gt;_pMemory[n];\n         }\n      }\n      this-&gt;_length = position;\n   }</Source>
                  </Method>
                  <Method name="Set" description="设置指定索引位置的数据。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(TInt index, T value){\n      MO_ASSERT_RANGE(index, 0, this-&gt;_length);\n      this-&gt;_pMemory[index] = value;\n   }</Source>
                  </Method>
                  <Method name="SetLength" description="设置数据长度。">
                     <Parameters>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid SetLength(TInt length){\n      InnerCast()-&gt;A::EnsureSize(length);\n      if(length &gt; this-&gt;_length){\n         for(TInt n=this-&gt;_length; n&lt;length; n++){\n            this-&gt;_pMemory[n] = RType&lt;T&gt;::Default();\n         }\n      }\n      this-&gt;_length = length;\n   }</Source>
                  </Method>
                  <Method name="Sort" description="使用排序器对集合对象进行排序。">
                     <Parameters>
                        <Parameter type="IComparer&lt;T&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Sort(IComparer&lt;T&gt;* pComparer){\n      MO_ASSERT(pComparer)\n      if(this-&gt;_pMemory &amp;&amp; this-&gt;_length &gt; 1){\n         if(MO_COMPARRAY_THRESHOLD &gt; this-&gt;_length) {\n            RComparerSort&lt;T&gt;::InsertSort(this-&gt;_pMemory, 0, this-&gt;_length-1, pComparer);\n         } else {\n            RComparerSort&lt;T&gt;::QuickSort(this-&gt;_pMemory, 0, this-&gt;_length-1, pComparer);\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="BinarySearch" description="此函数只可在排序后调用。返回指定元素的位置。">
                     <Parameters>
                        <Parameter type="T" name="data"/>
                        <Parameter type="IComparer&lt;T&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt BinarySearch(T data, IComparer&lt;T&gt;* pComparer) {\n      MO_ASSERT(pComparer)\n      if(this-&gt;_pMemory &amp;&amp; this-&gt;_length &gt; 0) {\n         return RBinarySearch&lt;T&gt;::BinarySearch(\n               this-&gt;_pMemory, 0, this-&gt;_length-1, data, pComparer);\n      }\n      return ENotFound;\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清除所有数据。" note="注意本操作对数据不做任何处理，如果存储指针，一定要先自己释放。只是将长度置为空，可以重新放数据。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;_length = 0;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MArrayC">
               <Inherits>
                  <Inherit name="MPtrC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="operator==">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator==(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return RTypes&lt;T&gt;::Equals(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="operator!=">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator!=(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return !RTypes&lt;T&gt;::Equals(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="operator&lt;">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator&lt;(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return RTypes&lt;T&gt;::Compare(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length()) &lt; 0;\n   }</Source>
                  </Method>
                  <Method name="operator&gt;">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator&gt;(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return RTypes&lt;T&gt;::Compare(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length()) &gt; 0;\n   }</Source>
                  </Method>
                  <Method name="operator&lt;=">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator&lt;=(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return RTypes&lt;T&gt;::Compare(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length()) &lt;= 0;\n   }</Source>
                  </Method>
                  <Method name="operator&gt;=">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator&gt;=(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return RTypes&lt;T&gt;::Compare(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length()) &gt;= 0;\n   }</Source>
                  </Method>
                  <Method name="T*" description="获得数据只读指针">
                     <Return type="const"/>
                     <Source>\noperator const T*() const{\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="operator[]">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nconst T operator[](TInt index) const{\n      MO_ASSERT(this-&gt;_pMemory);\n      MO_ASSERT_RANGE(index, 0, this-&gt;_length);\n      return this-&gt;_pMemory[index];\n   }</Source>
                  </Method>
                  <Method name="Equals">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Equals(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return RTypes&lt;T&gt;::Equals(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="StartsWith">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool StartsWith(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return RTypes&lt;T&gt;::StartsWith(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="EndsWith">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool EndsWith(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return RTypes&lt;T&gt;::EndsWith(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="Contains" description="从当前数组中是否含有指定数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Contains(T value) const{\n      TInt result = RTypes&lt;T&gt;::IndexOf(this-&gt;_pMemory, this-&gt;_length, value);\n      return (ENotFound != result);\n   }</Source>
                  </Method>
                  <Method name="Compare">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt Compare(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return RTypes&lt;T&gt;::Compare(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="IndexOf">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt IndexOf(T value) const{\n      return RTypes&lt;T&gt;::IndexOf(this-&gt;_pMemory, this-&gt;_length, value);\n   }</Source>
                  </Method>
                  <Method name="IndexOf">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                        <Parameter type="TInt" name="offset"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt IndexOf(T value, TInt offset) const{\n      MO_ASSERT_RANGE(offset, 0, this-&gt;_length);\n      TInt find = RTypes&lt;T&gt;::IndexOf(this-&gt;_pMemory + offset, this-&gt;_length - offset, value);\n      return offset + find;\n   }</Source>
                  </Method>
                  <Method name="LastIndexOf">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt LastIndexOf(T value) const{\n      return RTypes&lt;T&gt;::LastIndexOf(this-&gt;_pMemory, this-&gt;_length, value);\n   }</Source>
                  </Method>
                  <Method name="LastIndexOf">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                        <Parameter type="TInt" name="offset"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt LastIndexOf(T value, TInt offset) const{\n      MO_ASSERT_RANGE(offset, 0, this-&gt;_length);\n      return RTypes&lt;T&gt;::LastIndexOf(this-&gt;_pMemory, offset, value);\n   }</Source>
                  </Method>
                  <Method name="IteratorC" description="获取只读迭代器。">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC IteratorC(){\n      return TIteratorC(this-&gt;_pMemory, this-&gt;_length);\n   }</Source>
                  </Method>
                  <Method name="IteratorC" description="获取只读迭代器。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC IteratorC(TInt index){\n      MO_ASSERT_RANGE(index, 0, this-&gt;_length);\n      return TIteratorC(this-&gt;_pMemory + index, this-&gt;_length - index);\n   }</Source>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Get(TInt index) const{\n      MO_ASSERT_RANGE(index, 0, this-&gt;_length);\n      return this-&gt;_pMemory[index];\n   }</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="T*" name="pValue"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt Find(const T* pValue, TInt length) const{\n      return RTypes&lt;T&gt;::Find(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n   }</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt Find(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return RTypes&lt;T&gt;::Find(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="LastFind">
                     <Parameters>
                        <Parameter type="T*" name="pValue"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt LastFind(const T* pValue, TInt length) const{\n      return RTypes&lt;T&gt;::LastFind(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n   }</Source>
                  </Method>
                  <Method name="LastFind">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt LastFind(const MPtrC&lt;T&gt;&amp; ptr) const{\n      return RTypes&lt;T&gt;::LastFind(this-&gt;_pMemory, this-&gt;_length, ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="LeftPtrC">
                     <Parameters>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TPtrC&lt;T&gt;"/>
                     <Source>\nTPtrC&lt;T&gt; LeftPtrC(TInt length) const{\n      MO_ASSERT_BETWEEN(length, 0, this-&gt;_length);\n      return TPtr&lt;T&gt;(this-&gt;_pMemory, length);\n   }</Source>
                  </Method>
                  <Method name="MidPtrC">
                     <Parameters>
                        <Parameter type="TInt" name="offset"/>
                     </Parameters>
                     <Return type="TPtrC&lt;T&gt;"/>
                     <Source>\nTPtrC&lt;T&gt; MidPtrC(TInt offset) const{\n      MO_ASSERT_BETWEEN(offset, 0, this-&gt;_length);\n      return TPtr&lt;T&gt;(this-&gt;_pMemory + offset, this-&gt;_length - offset);\n   }</Source>
                  </Method>
                  <Method name="MidPtrC">
                     <Parameters>
                        <Parameter type="TInt" name="offset"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TPtrC&lt;T&gt;"/>
                     <Source>\nTPtrC&lt;T&gt; MidPtrC(TInt offset, TInt length) const{\n      MO_ASSERT_BETWEEN(offset, 0, this-&gt;_length);\n      MO_ASSERT_BETWEEN(length, 0, this-&gt;_length - offset);\n      return TPtr&lt;T&gt;(this-&gt;_pMemory + offset, length);\n   }</Source>
                  </Method>
                  <Method name="RightPtrC">
                     <Parameters>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TPtrC&lt;T&gt;"/>
                     <Source>\nTPtrC&lt;T&gt; RightPtrC(TInt length) const{\n      MO_ASSERT_BETWEEN(length, 0, this-&gt;_length);\n      return TPtr&lt;T&gt;(this-&gt;_pMemory + (this-&gt;_length - length), length);\n   }</Source>
                  </Method>
                  <Method name="SubPtrC">
                     <Parameters>
                        <Parameter type="TInt" name="begin"/>
                        <Parameter type="TInt" name="end"/>
                     </Parameters>
                     <Return type="TPtrC&lt;T&gt;"/>
                     <Source>\nTPtrC&lt;T&gt; SubPtrC(TInt begin, TInt end) const{\n      MO_ASSERT_BETWEEN(begin, 0, this-&gt;_length);\n      MO_ASSERT_BETWEEN(end, 0, this-&gt;_length);\n      MO_ASSERT(begin &lt;= end);\n      return TPtr&lt;T&gt;(this-&gt;_pMemory + begin, end - begin);\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MAtomAllocator">
               <Inherits>
                  <Inherit name="IAtomAllocator" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="MAtomAllocator"/>
                  <Destructor name="~MAtomAllocator"/>
                  <Method name="Alloc" flag="abstract">
                     <Return type="T*"/>
                     <Source>\nMO_ABSTRACT( T* Alloc() ){\n      return MO_MEM_CREATE(T);\n   };</Source>
                  </Method>
                  <Method name="Free" flag="abstract">
                     <Parameters>
                        <Parameter type="T*" name="pAtom"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nMO_ABSTRACT( void Free(T* pAtom) ){\n      MO_MEM_DELETE(pAtom);\n   }</Source>
                  </Method>
                  <Method name="MultiAlloc" flag="abstract">
                     <Parameters>
                        <Parameter type="TUint" name="count"/>
                     </Parameters>
                     <Return type="T*"/>
                     <Source>\nMO_ABSTRACT( T* MultiAlloc(TUint count) ){\n      T* pAlloc = RTypeMemory&lt;T&gt;::Alloc(count);\n      //printf(&quot;Alloc 0x%08X - %d\n&quot;, pAlloc, count);\n      return pAlloc;\n   }</Source>
                  </Method>
                  <Method name="MultiFree" flag="abstract">
                     <Parameters>
                        <Parameter type="TAny*" name="pAtoms"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nMO_ABSTRACT( void MultiFree(TAny* pAtoms) ){\n      //printf(&quot;Free  0x%08X\n&quot;, pAtoms);\n      RTypeMemory&lt;T&gt;::Free(pAtoms);\n   }</Source>
                  </Method>
                  <Method name="MultiPtrAlloc" flag="abstract">
                     <Parameters>
                        <Parameter type="TUint" name="count"/>
                     </Parameters>
                     <Return type="T**"/>
                     <Source>\nMO_ABSTRACT( T** MultiPtrAlloc(TUint count) ){\n      return RTypeMemory&lt;T*&gt;::Alloc(count, (T*)NULL);\n   }</Source>
                  </Method>
                  <Method name="MultiPtrFree" flag="abstract">
                     <Parameters>
                        <Parameter type="T**" name="pAtoms"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nMO_ABSTRACT( void MultiPtrFree(T** pAtoms) ){\n      RTypeMemory&lt;T*&gt;::Free(pAtoms);\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MAttributes">
               <Inherits>
                  <Inherit name="MAttributesC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      MAttributesC::InnerInitialize();\n      _pUnused = NULL;\n      EnsureSize(size);\n   }</Source>
                  </Method>
                  <Method name="InnerRelease" type="inline" description="内部释放。">
                     <Return type="void"/>
                     <Source>\ninline void InnerRelease(){\n      // 释放节点\n      if(this-&gt;_count &gt; 0){\n         // 将所有节点设置为未使用\n         this-&gt;_pLast-&gt;pNext = this-&gt;_pUnused;\n         this-&gt;_pUnused = this-&gt;_pFirst;\n         // 删除所有节点\n         SEntry* pFind = this-&gt;_pUnused;\n         while(NULL != pFind){\n            SEntry* pNext = pFind;\n            MO_DELETE(pFind);\n            pFind = pNext;\n         }\n      }\n      // 释放节点数组\n      RTypeMemory&lt;SEntry*&gt;::Free(this-&gt;_ppEntries);\n   }</Source>
                  </Method>
                  <Method name="EnsureSize">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Assign">
                     <Parameters>
                        <Parameter type="MAttributesC&amp;" name="attributes"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="MAttributesC&amp;" name="attributes"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TString"/>
                  </Method>
                  <Method name="Clear">
                     <Return type="void"/>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SEntry*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="MAttributesC">
               <Inherits>
                  <Inherit name="MEntriesC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      MEntriesC&lt;SEntry&gt;::InnerInitialize();\n      _entryCount = 0;\n      _ppEntries = NULL;\n   }</Source>
                  </Method>
                  <Method name="operator[]">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* MAttributesC::operator[](TCharC* pName){\n   SAttributesEntry* pEntry = EntryFind(pName);\n   MO_ASSERT(pEntry);\n   return pEntry-&gt;Value();\n}</Source>
                  </Method>
                  <Method name="EntryFind" description="查找指定名称的索引位置。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="SAttributesEntry*"/>
                     <Source>//============================================================\n// &lt;T&gt;查找指定名称的索引位置。&lt;/T&gt;\n//============================================================\n\nSAttributesEntry* MAttributesC::EntryFind(TCharC* pName) const{\n   // 数据存在时\n   if(_count &gt; 0){\n      THashCode hash = RString::MakeHashCode(pName);\n      // 查找名称的索引位置\n      SAttributesEntry* pEntry = _ppEntries[hash % _entryCount];\n      while(NULL != pEntry){\n         if(pEntry-&gt;hash == hash){\n            if(pEntry-&gt;IsName(pName)){\n               return pEntry;\n            }\n         }\n         pEntry = pEntry-&gt;pLink;\n      }\n   }\n   // 未找到时返回结果\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="EntryFindValue" description="查找指定名称的索引位置。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="SAttributesEntry*"/>
                     <Source>//============================================================\n// &lt;T&gt;查找指定名称的索引位置。&lt;/T&gt;\n//============================================================\n\nSAttributesEntry* MAttributesC::EntryFindValue(TCharC* pValue) const{\n   // 数据存在时\n   if(_count &gt; 0){\n      SAttributesEntry* pEntry = _pFirst;\n      while(NULL != pEntry){\n         if(pEntry-&gt;pValue-&gt;Equals(pValue)){\n            return pEntry;\n         }\n         pEntry = pEntry-&gt;pNext;\n      }\n   }\n   // 未找到时返回结果\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="IsEmpty" description="当前哈希集合对象是否为空。">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;当前哈希集合对象是否为空。&lt;/T&gt;\n//============================================================\n\nTBool MAttributesC::IsEmpty() const{\n   return (0 == _count);\n}</Source>
                  </Method>
                  <Method name="Count" description="获得数据个数。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得数据个数。&lt;/T&gt;\n//============================================================\n\nTInt MAttributesC::Count() const{\n   return _count;\n}</Source>
                  </Method>
                  <Method name="Contains" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;判断指定名称是否存在。&lt;/T&gt;\n//============================================================\n\nTBool MAttributesC::Contains(TCharC* pName) const{\n   return (NULL != EntryFind(pName));\n}</Source>
                  </Method>
                  <Method name="ContainsValue" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;判断指定名称是否存在。&lt;/T&gt;\n//============================================================\n\nTBool MAttributesC::ContainsValue(TCharC* pValue) const{\n   return (NULL != EntryFindValue(pValue));\n}</Source>
                  </Method>
                  <Method name="Get" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得指定名称的数据。&lt;/T&gt;\n//============================================================\n\nTCharC* MAttributesC::Get(TCharC* pName) const{\n   SAttributesEntry* pEntry = EntryFind(pName);\n   MO_ASSERT(pEntry);\n   return pEntry-&gt;pValue-&gt;MemoryC();\n}</Source>
                  </Method>
                  <Method name="Find" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得指定名称的数据。&lt;/T&gt;\n//============================================================\n\nTCharC* MAttributesC::Find(TCharC* pName) const{\n   SAttributesEntry* pEntry = EntryFind(pName);\n   if(NULL != pEntry){\n      return pEntry-&gt;pValue-&gt;MemoryC();\n   }\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="FindNvl" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TCharC*" name="pDefault"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得指定名称的数据。&lt;/T&gt;\n//============================================================\n\nTCharC* MAttributesC::FindNvl(TCharC* pName, TCharC* pDefault) const{\n   SAttributesEntry* pEntry = EntryFind(pName);\n   if(NULL != pEntry){\n      return pEntry-&gt;pValue-&gt;MemoryC();\n   }\n   return pDefault;\n}</Source>
                  </Method>
                  <Method name="Search" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得指定名称的数据。&lt;/T&gt;\n//============================================================\n\nTCharC* MAttributesC::Search(TCharC* pValue) const{\n   SAttributesEntry* pEntry = EntryFindValue(pValue);\n   if(NULL != pEntry){\n      return pEntry-&gt;pName-&gt;MemoryC();\n   }\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="IteratorC" description="获得属性表只读迭代器。">
                     <Return type="TAttributesIteratorC"/>
                     <Source>//============================================================\n// &lt;T&gt;获得属性表只读迭代器。&lt;/T&gt;\n//\n// @return 只读迭代器\n//============================================================\n\nTAttributesIteratorC MAttributesC::IteratorC() const{\n   return TAttributesIteratorC(_pFirst);\n}</Source>
                  </Method>
                  <Method name="Dump" description="获得对象运行时信息。">
                     <Return type="TString"/>
                     <Source>//============================================================\n// &lt;T&gt;获得对象运行时信息。&lt;/T&gt;\n//\n// @return 运行时信息\n//============================================================\n\nTString MAttributesC::Dump() const{\n   TString dump = &quot;MAttributesC{&quot;;\n   dump.AppendInt(_count);\n   if(_count &gt; 0){\n      SAttributesEntry* pEntry = _pFirst;\n      while(NULL != pEntry){\n         dump.Append(*pEntry-&gt;pName);\n         dump.Append(&quot;=&quot;);\n         dump.Append(*pEntry-&gt;pValue);\n         // 查找下一个\n         pEntry = pEntry-&gt;pNext;\n         if(NULL != pEntry){\n            dump.Append(',');\n         }\n      }\n   }\n   return dump;\n}\n\n//============================================================\n// &lt;T&gt;确保当前对象可以容纳指定大小的数据。&lt;/T&gt;\n// 当哈希表是旧表的8倍时开始扩充，扩大2倍。&lt;/P&gt;\n//============================================================\nvoid MAttributes::EnsureSize(TInt size){\n   if(NULL == this-&gt;_ppEntries) {\n      this-&gt;_entryCount = MO_MAX(size, MO_OBJECT_CAPACITY);\n      // 第一次新建时，生成哈希表\n      this-&gt;_ppEntries = RTypeMemory&lt;SEntry*&gt;::Alloc(this-&gt;_entryCount, NULL);\n   } else if (size &gt; (this-&gt;_entryCount &lt;&lt; 3)) {\n      // 扩充内存时处理\n      size = this-&gt;_entryCount + ((MO_MAX(this-&gt;_entryCount, size)) &gt;&gt; 1);\n      // 当总数大于节点列表长度8倍时，重新扩充节点列表\n      SAttributesEntry** ppEntries = RTypeMemory&lt;SEntry*&gt;::Alloc(size, NULL);\n      // 循环取出旧的节点列表内容，移到新的节点列表上\n      SAttributesEntry* pEntry = this-&gt;_pFirst;\n      while(NULL == pEntry){\n         // 将当前节点存储到新建的节点列表上去\n         TInt index = pEntry-&gt;hash % size;\n         pEntry-&gt;pLink = ppEntries[index];\n         ppEntries[index] = pEntry;\n            // 获得保存的下一个节点指针\n         pEntry = pEntry-&gt;pLink;\n      }\n      // 释放旧节点内存\n      RTypeMemory&lt;SEntry*&gt;::Free(this-&gt;_ppEntries);\n      // 保存新的节点列表\n      this-&gt;_ppEntries = ppEntries;\n      this-&gt;_entryCount = size;\n   }\n}\n\n//============================================================\n// &lt;T&gt;接收源哈希表内的全部数据。&lt;/T&gt;\n//============================================================\nvoid MAttributes::Assign(const MAttributesC&amp; attributes){\n   Clear();\n   Append(attributes);\n}\n\n//============================================================\n// &lt;T&gt;追加源哈希表内的全部数据。&lt;/T&gt;\n//============================================================\nvoid MAttributes::Append(const MAttributesC&amp; attributes){\n   TAttributesIterator iterator = attributes.IteratorC();\n   while(iterator.Next()){\n      Set(iterator.Name(), iterator.Value());\n   }\n}\n\n//============================================================\n// &lt;T&gt;根据名称设置数据。&lt;/T&gt;\n//============================================================\nvoid MAttributes::Set(TCharC* pName, TCharC* pValue){\n   THashCode hash = RString::MakeHashCode(pName);\n   TInt index = hash % this-&gt;_entryCount;\n   // 查找数据出现的位置\n   SEntry* pEntry = this-&gt;_ppEntries[index];\n   while(NULL != pEntry) {\n      if(pEntry-&gt;hash == hash){\n         if(pEntry-&gt;IsName(pName)){\n            pEntry-&gt;pValue-&gt;Assign(pValue);\n            return;\n         }\n      }\n      pEntry = pEntry-&gt;pLink;\n   }\n   // 如果名称不存在，为新建节点检查内存\n   pEntry = MO_CREATE(SEntry);\n   pEntry-&gt;hash = hash;\n   pEntry-&gt;pLink = this-&gt;_ppEntries[index];\n   pEntry-&gt;pName-&gt;Assign(pName);\n   pEntry-&gt;pValue-&gt;Assign(pValue);\n   this-&gt;_count++;\n   this-&gt;_ppEntries[index] = pEntry;\n   // 追加到链表尾部\n   EntryPush(pEntry);\n}\n\n//============================================================\n// &lt;T&gt;移除指定名称的数据。&lt;/T&gt;\n//============================================================\nTString MAttributes::Remove(TCharC* pName){\n   THashCode hash = RString::MakeHashCode(pName);\n   TInt index = hash % this-&gt;_entryCount;\n   // 查找数据出现的位置\n   TString value;\n   SAttributesEntry* pPrior = this-&gt;_ppEntries[index];\n   SAttributesEntry* pEntry = pPrior;\n   while(NULL != pEntry){\n      if(pEntry-&gt;hash == hash){\n         if(pEntry-&gt;IsName(pName)){\n            value = *pEntry-&gt;pValue;\n            if(pEntry == pPrior){\n               // 当前对象是第一个对象时\n               this-&gt;_ppEntries[index] = pEntry-&gt;pLink;\n            }else{\n               // 当前对象不是第一个对象时\n               pPrior-&gt;pLink = pEntry-&gt;pLink;\n            }\n            // 删除当前节点\n            EntryRemove(pEntry);\n            break;\n         }\n      }\n      pPrior = pEntry;\n      pEntry = pEntry-&gt;pLink;\n   }\n   return value;\n}\n\n//============================================================\n// &lt;T&gt;清空当前哈希表全部数据，是哈希表可以再次被利用。&lt;/T&gt;\n//============================================================\nvoid MAttributes::Clear(){\n   this-&gt;EntryClear();\n}\n\n//============================================================\nTCharC* MNcAttributesC::operator[](TCharC* pName){\n   SAttributesEntry* pEntry = EntryFind(pName);\n   MO_ASSERT(pEntry);\n   return pEntry-&gt;Value();\n}\n\n//============================================================\n// &lt;T&gt;查找指定名称的索引位置。&lt;/T&gt;\n//============================================================\nSAttributesEntry* MNcAttributesC::EntryFind(TCharC* pName) const{\n   // 数据存在时\n   if(_count &gt; 0){\n      THashCode hash = RString::MakeNocaseHashCode(pName);\n      // 查找名称的索引位置\n      SAttributesEntry* pEntry = _ppEntries[hash % _entryCount];\n      while(NULL != pEntry){\n         if(pEntry-&gt;hash == hash){\n            if(pEntry-&gt;IsNameIgnoreCase(pName)){\n               return pEntry;\n            }\n         }\n         pEntry = pEntry-&gt;pLink;\n      }\n   }\n   // 未找到时返回结果\n   return NULL;\n}\n\n//============================================================\n// &lt;T&gt;查找指定名称的索引位置。&lt;/T&gt;\n//============================================================\nSAttributesEntry* MNcAttributesC::EntryFindValue(TCharC* pValue) const{\n   // 数据存在时\n   if(_count &gt; 0){\n      SAttributesEntry* pEntry = _pFirst;\n      while(NULL != pEntry){\n         if(pEntry-&gt;pValue-&gt;Equals(pValue)){\n            return pEntry;\n         }\n         pEntry = pEntry-&gt;pNext;\n      }\n   }\n   // 未找到时返回结果\n   return NULL;\n}\n\n//============================================================\n// &lt;T&gt;当前哈希集合对象是否为空。&lt;/T&gt;\n//============================================================\nTBool MNcAttributesC::IsEmpty() const{\n   return (0 == _count);\n}\n\n//============================================================\n// &lt;T&gt;获得数据个数。&lt;/T&gt;\n//============================================================\nTInt MNcAttributesC::Count() const{\n   return _count;\n}\n\n//============================================================\n// &lt;T&gt;判断指定名称是否存在。&lt;/T&gt;\n//============================================================\nTBool MNcAttributesC::Contains(TCharC* pName) const{\n   return (NULL != EntryFind(pName));\n}\n\n//============================================================\n// &lt;T&gt;判断指定名称是否存在。&lt;/T&gt;\n//============================================================\nTBool MNcAttributesC::ContainsValue(TCharC* pValue) const{\n   return (NULL != EntryFindValue(pValue));\n}\n\n//============================================================\n// &lt;T&gt;获得指定名称的数据。&lt;/T&gt;\n//============================================================\nTCharC* MNcAttributesC::Get(TCharC* pName) const{\n   SAttributesEntry* pEntry = EntryFind(pName);\n   MO_ASSERT(pEntry);\n   return pEntry-&gt;pValue-&gt;MemoryC();\n}\n\n//============================================================\n// &lt;T&gt;获得指定名称的数据。&lt;/T&gt;\n//============================================================\nTCharC* MNcAttributesC::Find(TCharC* pName) const{\n   SAttributesEntry* pEntry = EntryFind(pName);\n   if(NULL != pEntry){\n      return pEntry-&gt;pValue-&gt;MemoryC();\n   }\n   return NULL;\n}\n\n//============================================================\n// &lt;T&gt;获得指定名称的数据。&lt;/T&gt;\n//============================================================\nTCharC* MNcAttributesC::FindNvl(TCharC* pName, TCharC* pDefault) const{\n   SAttributesEntry* pEntry = EntryFind(pName);\n   if(NULL != pEntry){\n      return pEntry-&gt;pValue-&gt;MemoryC();\n   }\n   return pDefault;\n}\n\n//============================================================\n// &lt;T&gt;获得指定名称的数据。&lt;/T&gt;\n//============================================================\nTCharC* MNcAttributesC::Search(TCharC* pValue) const{\n   SAttributesEntry* pEntry = EntryFindValue(pValue);\n   if(NULL != pEntry){\n      return pEntry-&gt;pName-&gt;MemoryC();\n   }\n   return NULL;\n}\n\n//============================================================\n// &lt;T&gt;获得属性表只读迭代器。&lt;/T&gt;\n//\n// @return 只读迭代器\n//============================================================\nTAttributesIteratorC MNcAttributesC::IteratorC() const{\n   return TAttributesIteratorC(_pFirst);\n}\n\n//============================================================\n// &lt;T&gt;获得对象运行时信息。&lt;/T&gt;\n//\n// @return 运行时信息\n//============================================================\nTString MNcAttributesC::Dump() const{\n   TString dump = &quot;MNcAttributesC{&quot;;\n   dump.AppendInt(_count);\n   if(_count &gt; 0){\n      SAttributesEntry* pEntry = _pFirst;\n      while(NULL != pEntry){\n         dump.Append(*pEntry-&gt;pName);\n         dump.Append(&quot;=&quot;);\n         dump.Append(*pEntry-&gt;pValue);\n         // 查找下一个\n         pEntry = pEntry-&gt;pNext;\n         if(NULL != pEntry){\n            dump.Append(',');\n         }\n      }\n   }\n   return dump;\n}\n\n//============================================================\n// &lt;T&gt;确保当前对象可以容纳指定大小的数据。&lt;/T&gt;\n// 当哈希表是旧表的8倍时开始扩充，扩大2倍。&lt;/P&gt;\n//============================================================\nvoid MNcAttributes::EnsureSize(TInt size){\n   if(NULL == this-&gt;_ppEntries) {\n      this-&gt;_entryCount = MO_MAX(size, MO_OBJECT_CAPACITY);\n      // 第一次新建时，生成哈希表\n      this-&gt;_ppEntries = RTypeMemory&lt;SEntry*&gt;::Alloc(this-&gt;_entryCount, NULL);\n   } else if (size &gt; (this-&gt;_entryCount &lt;&lt; 3)) {\n      // 扩充内存时处理\n      size = this-&gt;_entryCount + ((MO_MAX(this-&gt;_entryCount, size)) &gt;&gt; 1);\n      // 当总数大于节点列表长度8倍时，重新扩充节点列表\n      SAttributesEntry** ppEntries = RTypeMemory&lt;SEntry*&gt;::Alloc(size, NULL);\n      // 循环取出旧的节点列表内容，移到新的节点列表上\n      SAttributesEntry* pEntry = this-&gt;_pFirst;\n      while(NULL == pEntry){\n         // 将当前节点存储到新建的节点列表上去\n         TInt index = pEntry-&gt;hash % size;\n         pEntry-&gt;pLink = ppEntries[index];\n         ppEntries[index] = pEntry;\n            // 获得保存的下一个节点指针\n         pEntry = pEntry-&gt;pLink;\n      }\n      // 释放旧节点内存\n      RTypeMemory&lt;SEntry*&gt;::Free(this-&gt;_ppEntries);\n      // 保存新的节点列表\n      this-&gt;_ppEntries = ppEntries;\n      this-&gt;_entryCount = size;\n   }\n}\n\n//============================================================\n// &lt;T&gt;接收源哈希表内的全部数据。&lt;/T&gt;\n//============================================================\nvoid MNcAttributes::Assign(const MNcAttributesC&amp; attributes){\n   Clear();\n   Append(attributes);\n}\n\n//============================================================\n// &lt;T&gt;追加源哈希表内的全部数据。&lt;/T&gt;\n//============================================================\nvoid MNcAttributes::Append(const MNcAttributesC&amp; attributes){\n   TAttributesIterator iterator = attributes.IteratorC();\n   while(iterator.Next()){\n      Set(iterator.Name(), iterator.Value());\n   }\n}\n\n//============================================================\n// &lt;T&gt;根据名称设置数据。&lt;/T&gt;\n//============================================================\nvoid MNcAttributes::Set(TCharC* pName, TCharC* pValue){\n   THashCode hash = RString::MakeNocaseHashCode(pName);\n   TInt index = hash % this-&gt;_entryCount;\n   // 查找数据出现的位置\n   SEntry* pEntry = this-&gt;_ppEntries[index];\n   while(NULL != pEntry) {\n      if(pEntry-&gt;hash == hash){\n         if(pEntry-&gt;IsNameIgnoreCase(pName)){\n            pEntry-&gt;pValue-&gt;Assign(pValue);\n            return;\n         }\n      }\n      pEntry = pEntry-&gt;pLink;\n   }\n   // 如果名称不存在，为新建节点检查内存\n   pEntry = MO_CREATE(SEntry);\n   pEntry-&gt;hash = hash;\n   pEntry-&gt;pLink = this-&gt;_ppEntries[index];\n   pEntry-&gt;pName-&gt;Assign(pName);\n   pEntry-&gt;pValue-&gt;Assign(pValue);\n   this-&gt;_count++;\n   this-&gt;_ppEntries[index] = pEntry;\n   // 追加到链表尾部\n   EntryPush(pEntry);\n}\n\n//============================================================\n// &lt;T&gt;移除指定名称的数据。&lt;/T&gt;\n//============================================================\nTString MNcAttributes::Remove(TCharC* pName){\n   THashCode hash = RString::MakeNocaseHashCode(pName);\n   TInt index = hash % this-&gt;_entryCount;\n   // 查找数据出现的位置\n   TString value;\n   SAttributesEntry* pPrior = this-&gt;_ppEntries[index];\n   SAttributesEntry* pEntry = pPrior;\n   while(NULL != pEntry){\n      if(pEntry-&gt;hash == hash){\n         if(pEntry-&gt;IsNameIgnoreCase(pName)){\n            value = *pEntry-&gt;pValue;\n            if(pEntry == pPrior){\n               // 当前对象是第一个对象时\n               this-&gt;_ppEntries[index] = pEntry-&gt;pLink;\n            }else{\n               // 当前对象不是第一个对象时\n               pPrior-&gt;pLink = pEntry-&gt;pLink;\n            }\n            // 删除当前节点\n            EntryRemove(pEntry);\n            break;\n         }\n      }\n      pPrior = pEntry;\n      pEntry = pEntry-&gt;pLink;\n   }\n   return value;\n}\n\n//============================================================\n// &lt;T&gt;清空当前哈希表全部数据，是哈希表可以再次被利用。&lt;/T&gt;\n//============================================================\nvoid MNcAttributes::Clear(){\n   this-&gt;EntryClear();\n}\n\nMO_NAMESPACE_END\n</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_entryCount"/>
                  <Attribute type="SAttributesEntry**" name="_ppEntries"/>
               </Attributes>
            </Class>
            <Class name="MClone">
               <Methods>
                  <Method name="Clone" flag="virtual">
                     <Return type="T*"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="MConsole">
               <Methods>
                  <Constructor name="MConsole" description="构造唯一对象的实例。"/>
                  <Destructor name="~MConsole" description="析构唯一对象的实例。"/>
                  <Method name="OnSerialize" flag="override" description="序列化管理器。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;序列化管理器。&lt;/T&gt;\n//============================================================\n\nvoid MConsole::OnSerialize(){\n}</Source>
                  </Method>
                  <Method name="OnUnserialize" flag="override" description="反序列化管理器。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;反序列化管理器。&lt;/T&gt;\n//============================================================\n\nvoid MConsole::OnUnserialize(){\n}</Source>
                  </Method>
                  <Method name="SingletonType" flag="override" description="获得唯一对象的类型。">
                     <Return type="ESingleton"/>
                     <Source>//============================================================\n// &lt;T&gt;获得唯一对象的类型。&lt;/T&gt;\n//\n// @return 类型\n//============================================================\n\nESingleton MConsole::SingletonType(){\n   return ESingleton_Manager;\n}</Source>
                  </Method>
                  <Method name="Code" flag="override" description="获得唯一对象的代码。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得唯一对象的代码。&lt;/T&gt;\n//\n// @return 代码\n//============================================================\n\nTInt MConsole::Code(){\n   return _code;\n}</Source>
                  </Method>
                  <Method name="Name" flag="override" description="获得唯一对象的名称。">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得唯一对象的名称。&lt;/T&gt;\n//\n// @return 名称\n//============================================================\n\nTCharC* MConsole::Name(){\n   return _name.MemoryC();\n}</Source>
                  </Method>
                  <Method name="LoadConfig" flag="override" description="获得唯一对象的名称。">
                     <Parameters>
                        <Parameter type="FXmlNode*" name="pConfig"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;获得唯一对象的名称。&lt;/T&gt;\n//\n// @param pConfig 设置信息\n// @return 是否成功\n//============================================================\n\nTBool MConsole::LoadConfig(FXmlNode* pConfig){\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Suspend" flag="override" description="挂起管理器。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;挂起管理器。&lt;/T&gt;\n//============================================================\n\nvoid MConsole::Suspend(){\n   OnSerialize();\n}</Source>
                  </Method>
                  <Method name="Resume" flag="override" description="唤醒管理器。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;唤醒管理器。&lt;/T&gt;\n//============================================================\n\nvoid MConsole::Resume(){\n   OnUnserialize();\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_code"/>
                  <Attribute type="TFsName" name="_name"/>
               </Attributes>
            </Class>
            <Class name="MDictionary">
               <Inherits>
                  <Inherit name="MDictionaryC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerCast" type="inline" description="获得内部类型指针。">
                     <Return type="A*"/>
                     <Source>\ninline A* InnerCast(){\n      return static_cast&lt;A*&gt;(this);\n   }</Source>
                  </Method>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      MDictionaryC&lt;T&gt;::InnerInitialize();\n      _pUnused = NULL;\n      InnerCast()-&gt;A::EnsureSize(size);\n   }</Source>
                  </Method>
                  <Method name="InnerRelease" description="释放哈希表对象。">
                     <Return type="void"/>
                     <Source>\nvoid InnerRelease(){\n      A* pInstance = InnerCast();\n      // 释放节点\n      if(this-&gt;_count &gt; 0){\n         // 将所有节点设置为未使用\n         this-&gt;_pLast-&gt;pNext = this-&gt;_pUnused;\n         this-&gt;_pUnused = this-&gt;_pFirst;\n         // 删除所有节点\n         SEntry* pFind = this-&gt;_pUnused;\n         while(NULL != pFind){\n            SEntry* pNext = pFind-&gt;pNext;\n            pInstance-&gt;EntryRelease(pFind);\n            pFind = pNext;\n         }\n      }\n      // 释放节点数组\n      pInstance-&gt;EntryFlatRelease(this-&gt;_ppEntries);\n   }</Source>
                  </Method>
                  <Method name="EntryAlloc" type="inline" description="收集一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryAlloc(){\n      SEntry* pEntry = NULL;\n      // 查看未使用节点中是否有自由节点\n      if(NULL != this-&gt;_pUnused){\n         // 收集未使用的节点\n         pEntry = this-&gt;_pUnused;\n         this-&gt;_pUnused = this-&gt;_pUnused-&gt;pNext;\n      }else{\n         // 收集新节点\n         pEntry = InnerCast()-&gt;A::EntryCreate();\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryFree" type="inline" description="释放一个被使用的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFree(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      pEntry-&gt;pNext = this-&gt;_pUnused;\n      this-&gt;_pUnused = pEntry;\n   }</Source>
                  </Method>
                  <Method name="operator[]" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="T&amp;"/>
                     <Source>\nT&amp; operator[](TCharC* pName){\n      MO_ASSERT(pName);\n      SEntry* pEntry = this-&gt;EntryFind(pName);\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="operator[]" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="T&amp;"/>
                     <Source>\nT&amp; operator[](const MStringPtrC&amp; name){\n      SEntry* pEntry = this-&gt;EntryFind(name.MemoryC());\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="EntriesResize" type="inline" description="扩充当前对象的哈希值数组。">
                     <Parameters>
                        <Parameter type="SEntry**" name="ppEntries"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntriesResize(SEntry** ppEntries, TInt size){\n      // 循环取出旧的节点列表内容，移到新的节点列表上\n      TInt n = 0;\n      while(++n &lt; this-&gt;_entryCount){\n         SEntry* pEntry = this-&gt;_ppEntries[n];\n         while(NULL != pEntry){\n            // 保存当前节点的下一个节点指针\n            SEntry* pLink = pEntry-&gt;pLink;\n            // 将当前节点存储到新建的节点列表上去\n            TInt index = pEntry-&gt;Hash() % size;\n            pEntry-&gt;pLink = ppEntries[index];\n            ppEntries[index] = pEntry;\n            // 获得保存的下一个节点指针\n            pEntry = pLink;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Iterator" description="获得可写迭代器。">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC Iterator(){\n      return TIterator(this-&gt;_pFirst);\n   }</Source>
                  </Method>
                  <Method name="LastIterator" description="获得结尾可写迭代器。">
                     <Return type="TIterator"/>
                     <Source>\nTIterator LastIterator(){\n      return TIterator(this-&gt;_pLast);\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接收源哈希表内的全部数据。">
                     <Parameters>
                        <Parameter type="MDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MDictionaryC&lt;T&gt;&amp; dictionary){\n      Clear();\n      Append(dictionary);\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加源哈希表内的全部数据。">
                     <Parameters>
                        <Parameter type="MDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MDictionaryC&lt;T&gt;&amp; dictionary){\n      TDictionaryIteratorC&lt;T&gt; iterator = dictionary.IteratorC();\n      while(iterator.Next()){\n         Set(iterator.Name(), iterator.Value());\n      }\n   }</Source>
                  </Method>
                  <Method name="Set" description="根据名称设置数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(TCharC* pName, T value){\n      THashCode hash = RString::MakeHashCode(pName);\n      TInt index = hash % this-&gt;_entryCount;\n      // 查找数据出现的位置\n      SEntry* pEntry = this-&gt;_ppEntries[index];\n      while(NULL != pEntry) {\n         if(pEntry-&gt;hash == hash){\n            if(pEntry-&gt;IsName(pName)){\n               pEntry-&gt;value = value;\n               return;\n            }\n         }\n         pEntry = pEntry-&gt;pNext;\n      }\n      // 如果名称不存在，为新建节点检查内存\n      pEntry = EntryAlloc();\n      pEntry-&gt;pLink = this-&gt;_ppEntries[index];\n      pEntry-&gt;hash = hash;\n      pEntry-&gt;SetName(pName);\n      pEntry-&gt;value = value;\n      this-&gt;_ppEntries[index] = pEntry;\n      // 追加到链表尾部\n      EntryPush(pEntry);\n   }</Source>
                  </Method>
                  <Method name="Set" description="根据名称设置数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(const MStringPtrC&amp; name, T value){\n      Set(name.MemoryC(), value);\n   }</Source>
                  </Method>
                  <Method name="Remove" description="移除指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Remove(TCharC* pName){\n      THashCode hash = RString::MakeHashCode(pName);\n      TInt index = hash % this-&gt;_entryCount;\n      // 查找数据出现的位置\n      T value = NULL;\n      SEntry* pPrior = this-&gt;_ppEntries[index];\n      SEntry* pEntry = pPrior;\n      while(NULL != pEntry){\n         if(pEntry-&gt;hash == hash){\n            if(pEntry-&gt;IsName(pName)){\n               value = pEntry-&gt;value;\n               if(pEntry == pPrior){\n                  // 当前对象是第一个对象时\n                  this-&gt;_ppEntries[index] = pEntry-&gt;pNext;\n               }else{\n                  // 当前对象不是第一个对象时\n                  pPrior-&gt;pNext = pEntry-&gt;pNext;\n               }\n               // 删除当前节点\n               EntryRemove(pEntry);\n               break;\n            }\n         }\n         pPrior = pEntry;\n         pEntry = pEntry-&gt;pNext;\n      }\n      return value;\n   }</Source>
                  </Method>
                  <Method name="Remove" description="移除指定名称的数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Remove(const MStringPtrC&amp; name){\n      return Remove(name.MemoryC());\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清空当前哈希表全部数据，是哈希表可以再次被利用。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;EntryClear();\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SEntry*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="MDictionaryC">
               <Inherits>
                  <Inherit name="MEntriesC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      MEntriesC&lt;SEntry&gt;::InnerInitialize();\n      _entryCount = 0;\n      _ppEntries = NULL;\n   }</Source>
                  </Method>
                  <Method name="operator==" description="判断当前哈希集合和指定哈希集合中所有数据内容是否相等。">
                     <Parameters>
                        <Parameter type="MDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator==(const MDictionaryC&lt;T&gt;&amp; dictionary) const{\n		return Equals(&amp;dictionary);\n	}</Source>
                  </Method>
                  <Method name="operator!=" description="判断当前哈希集合和指定哈希集合中所有数据内容是否不相等。">
                     <Parameters>
                        <Parameter type="MDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator!=(const MDictionaryC&lt;T&gt;&amp; dictionary) const{\n		return !Equals(&amp;dictionary);\n	}</Source>
                  </Method>
                  <Method name="operator[]" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nconst T operator[](TCharC* pName) const{\n      MO_ASSERT(pName);\n      SEntry* pEntry = EntryFind(pName);\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="operator[]" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nconst T operator[](const MStringPtrC&amp; name) const{\n      SEntry* pEntry = EntryFind(name.MemoryC());\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="EntryFind" type="inline" description="查找指定名称的索引位置。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryFind(TCharC* pName) const{\n      // 数据存在时\n      if(this-&gt;_count &gt; 0){\n         THashCode hash = RString::MakeHashCode(pName);\n         // 查找名称的索引位置\n         SEntry* pEntry = _ppEntries[hash % _entryCount];\n         while(NULL != pEntry){\n            if(pEntry-&gt;hash == hash){\n               if(pEntry-&gt;IsName(pName)){\n                  return pEntry;\n               }\n            }\n            pEntry = pEntry-&gt;pLink;\n         }\n      }\n      // 未找到时返回结果\n      return NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryFindValue" type="inline" description="查找指定名称的索引位置。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryFindValue(T value) const{\n      // 数据存在时\n      if(this-&gt;_count &gt; 0){\n         SEntry* pEntry = this-&gt;_pFirst;\n         while(NULL != pEntry){\n            if(pEntry-&gt;value == value){\n               return pEntry;\n            }\n            pEntry = pEntry-&gt;pNext;\n         }\n      }\n      // 未找到时返回结果\n      return NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryClear" type="inline">
                     <Return type="void"/>
                     <Source>\ninline void EntryClear(){\n      // 清除表格\n      for(TInt n=0; n&lt;_entryCount; n++){\n         _ppEntries[n] = NULL;\n      }\n      // 清除链表\n      MEntriesC&lt;SEntry&gt;::EntryClear();\n   }</Source>
                  </Method>
                  <Method name="IsEmpty" description="当前哈希集合对象是否为空。">
                     <Return type="TBool"/>
                     <Source>\nTBool IsEmpty() const{\n      return (0 == this-&gt;_count);\n   }</Source>
                  </Method>
                  <Method name="Count" description="获得数据个数。">
                     <Return type="TInt"/>
                     <Source>\nTInt Count() const{\n      return this-&gt;_count;\n   }</Source>
                  </Method>
                  <Method name="Contains" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Contains(TCharC* pName) const{\n      MO_ASSERT(pName);\n      return (NULL != EntryFind(pName));\n   }</Source>
                  </Method>
                  <Method name="Contains" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Contains(const MStringPtrC&amp; name) const{\n      return (NULL != EntryFind(name.MemoryC()));\n   }</Source>
                  </Method>
                  <Method name="ContainsValue" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool ContainsValue(T value) const{\n      return (NULL != EntryFindValue(value));\n   }</Source>
                  </Method>
                  <Method name="Equals" description="判断当前哈希集合和指定哈希集合内容是否相等。">
                     <Parameters>
                        <Parameter type="MDictionaryC&lt;T&gt;*" name="pDictionary"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Equals(const MDictionaryC&lt;T&gt;* pDictionary) const{\n      MO_ASSERT(pDictionary);\n      // 比较数量\n      if(this-&gt;_count != pDictionary-&gt;_count){\n         return EFalse;\n      }\n      // 比较所有项目\n      TIteratorC iterator = pDictionary-&gt;IteratorC();\n      while(iterator.Next()){\n         SEntry* pEntry = this-&gt;EntryFind(iterator.Name());\n         if(NULL == pEntry){\n            return EFalse;\n         }\n         if(!iterator.IsValue(pEntry-&gt;value)){\n            return EFalse;\n         }\n      }\n      return ETrue;\n	}</Source>
                  </Method>
                  <Method name="IteratorC" description="获得只读迭代器。">
                     <Return type="TDictionaryIteratorC&lt;T&gt;"/>
                     <Source>\nconst TDictionaryIteratorC&lt;T&gt; IteratorC() const{\n      return TDictionaryIteratorC&lt;T&gt;(this-&gt;_pFirst);\n   }</Source>
                  </Method>
                  <Method name="LastIteratorC" description="获得只读迭代器。">
                     <Return type="TDictionaryIteratorC&lt;T&gt;"/>
                     <Source>\nconst TDictionaryIteratorC&lt;T&gt; LastIteratorC() const{\n      return TDictionaryIteratorC&lt;T&gt;(this-&gt;_pLast);\n   }</Source>
                  </Method>
                  <Method name="Get" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Get(TCharC* pName) const{\n      MO_ASSERT(pName);\n      SEntry* pEntry = EntryFind(pName);\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="Get" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Get(const MStringPtrC&amp; name) const{\n      SEntry* pEntry = EntryFind(name.MemoryC());\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="Find" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Find(TCharC* pName) const{\n      if(NULL != pName){\n         SEntry* pEntry = EntryFind(pName);\n         if(NULL != pEntry){\n            return pEntry-&gt;value;\n         }\n      }\n      return NULL;\n   }</Source>
                  </Method>
                  <Method name="Find" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Find(const MStringPtrC&amp; name) const{\n      SEntry* pEntry = EntryFind(name);\n      return (NULL != pEntry) ? pEntry-&gt;value : NULL;\n   }</Source>
                  </Method>
                  <Method name="Search" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>\nTCharC* Search(T value) const{\n      SEntry* pEntry = EntryFindValue(value);\n      return (NULL != pEntry) ? pEntry-&gt;pName-&gt;MemoryC() : NULL;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_entryCount"/>
                  <Attribute type="SEntry**" name="_ppEntries"/>
               </Attributes>
            </Class>
            <Class name="MEntriesC">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      _count = 0;\n      _pFirst = NULL;\n      _pLast = NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryGet" type="inline" description="将链表节点压入首位置。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="E*"/>
                     <Source>\ninline E* EntryGet(TInt index) const{\n      MO_ASSERT_RANGE(index, 0, this-&gt;_count);\n      // 获得第一个\n      if(0 == index){\n         return this-&gt;_pFirst;\n      }\n      // 获得指定位置数据\n      E* pEntry = this-&gt;_pFirst;\n      while(--index &gt;= 0){\n         pEntry = pEntry-&gt;pNext;\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryUnshift" type="inline" description="将链表节点压入首位置。">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryUnshift(E* pEntry){\n      MO_ASSERT(pEntry);\n      if(NULL == _pFirst){\n         _pLast = pEntry;\n      }else{\n         _pFirst-&gt;pPrior = pEntry;\n      }\n      pEntry-&gt;pPrior = NULL;\n      pEntry-&gt;pNext = _pFirst;\n      _pFirst = pEntry;\n      _count++;\n   }</Source>
                  </Method>
                  <Method name="EntryShift" type="inline" description="弹出链表的首节点。">
                     <Return type="E*"/>
                     <Source>\ninline E* EntryShift(){\n      E* pEntry = _pFirst;\n      if(NULL != pEntry){\n         // 读指针指向下一个位置\n         _pFirst = _pFirst-&gt;pNext;\n         if(NULL == _pFirst){\n            _pLast = NULL;\n         }else{\n            _pFirst-&gt;pPrior = NULL;\n         }\n         // 设置内容\n         _count--;\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryPush" type="inline" description="将链表节点压入尾位置。">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryPush(E* pEntry){\n      MO_ASSERT(pEntry);\n      if(NULL == _pLast){\n         _pFirst = pEntry;\n      }else{\n         _pLast-&gt;pNext = pEntry;\n      }\n      pEntry-&gt;pPrior = _pLast;\n      pEntry-&gt;pNext = NULL;\n      _pLast = pEntry;\n      _count++;\n   }</Source>
                  </Method>
                  <Method name="EntryPop" type="inline" description="弹出链表的尾节点。">
                     <Return type="E*"/>
                     <Source>\ninline E* EntryPop(){\n      E* pEntry = _pLast;\n      if(NULL != pEntry){\n         _pLast = _pLast-&gt;pPrior;\n         if(NULL == _pLast){\n            _pFirst = NULL;\n         }else{\n            _pLast-&gt;pNext = NULL;\n         }\n         // 设置内容\n         _count--;\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryInsert" type="inline" description="在指定链表节点后插入一个新链表节点。">
                     <Parameters>
                        <Parameter type="E*" name="pPrior"/>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryInsert(E* pPrior, E* pEntry){\n      MO_ASSERT(pPrior);\n      MO_ASSERT(pEntry);\n      E* pNext = pPrior-&gt;pNext;\n      pPrior-&gt;pNext = pEntry;\n      pEntry-&gt;pPrior = pPrior;\n      if(NULL == pNext){\n         pEntry-&gt;pNext = NULL;\n         _pLast = pEntry;\n      }else{\n         pNext-&gt;pPrior = pEntry;\n         pEntry-&gt;pNext = pNext;\n      }\n	}</Source>
                  </Method>
                  <Method name="EntryRemove" type="inline" description="从链表上删除链表节点。">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRemove(E* pEntry){\n      MO_ASSERT(pEntry);\n      E* pPrior = pEntry-&gt;pPrior;\n      E* pNext = pEntry-&gt;pNext;\n      // 处理前节点\n      if(NULL == pPrior){\n         _pFirst = pNext;\n      }else{\n         pPrior-&gt;pNext = pNext;\n      }\n      // 处理后节点\n      if(NULL == pNext){\n         _pLast = pPrior;\n      }else{\n         pNext-&gt;pPrior = pPrior;\n      }\n      // 设置内容\n      _count--;\n   }</Source>
                  </Method>
                  <Method name="EntryClear" type="inline" description="清空所有使用中的节点。">
                     <Return type="void"/>
                     <Source>\ninline void EntryClear(){\n      if(_count &gt; 0){\n         // 清空内容\n         _count = 0;\n         _pFirst = NULL;\n         _pLast = NULL;\n      }\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="E*" name="_pFirst"/>
                  <Attribute type="E*" name="_pLast"/>
               </Attributes>
            </Class>
            <Class name="MEntryIteratorC">
               <Methods>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(E* pEntry){\n      _pStart = pEntry;\n      _pEntry = NULL;\n   }</Source>
                  </Method>
                  <Method name="IsEmpty" type="inline" description="当前节点是否含有数据。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsEmpty(){\n      return (NULL == _pEntry);\n   }</Source>
                  </Method>
                  <Method name="HasNext" type="inline" description="判断是否存在下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool HasNext(){\n      return (NULL == _pEntry) ? (NULL != _pStart) : (NULL != _pEntry-&gt;pNext);\n   }</Source>
                  </Method>
                  <Method name="Next" type="inline" description="移动到下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Next(){\n      _pEntry = (NULL == _pEntry) ? _pStart : _pEntry-&gt;pNext;\n      return (NULL != _pEntry);\n   }</Source>
                  </Method>
                  <Method name="HasPrior" type="inline" description="判断是否存在下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool HasPrior(){\n      return (NULL == _pEntry) ? (NULL != _pStart) : (NULL != _pEntry-&gt;pPrior);\n   }</Source>
                  </Method>
                  <Method name="Prior" type="inline" description="移动到上一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Prior(){\n      _pEntry = (NULL == _pEntry) ? _pStart : _pEntry-&gt;pPrior;\n      return (NULL != _pEntry);\n   }</Source>
                  </Method>
                  <Method name="Reset" type="inline" description="重置位置。">
                     <Return type="void"/>
                     <Source>\ninline void Reset(){\n      _pEntry = NULL;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="E*" name="_pStart"/>
                  <Attribute type="E*" name="_pEntry"/>
               </Attributes>
            </Class>
            <Class name="MEntryList">
               <Inherits>
                  <Inherit name="MEntryListC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="MEntryList"/>
                  <Destructor name="~MEntryList"/>
                  <Method name="Assign">
                     <Parameters>
                        <Parameter type="MEntryList&lt;E&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MEntryList&lt;E&gt;&amp; list){\n		Clear();\n      Append(list);\n	}</Source>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="MEntryListC&lt;E&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MEntryListC&lt;E&gt;&amp; list){\n		TIteratorC iterator = list.IteratorC();\n		while(iterator.Next()){\n			Push(iterator.Get());\n		}\n	}</Source>
                  </Method>
                  <Method name="Unshift">
                     <Parameters>
                        <Parameter type="E" name="entry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Unshift(E entry){\n      EntryUnshift(entry);\n   }</Source>
                  </Method>
                  <Method name="Shift">
                     <Return type="E"/>
                     <Source>\nE Shift(){\n      return MEntryListC&lt;E&gt;::EntryShift();\n   }</Source>
                  </Method>
                  <Method name="Push">
                     <Parameters>
                        <Parameter type="E" name="entry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Push(E entry){\n      EntryPush(entry);\n   }</Source>
                  </Method>
                  <Method name="Pop">
                     <Return type="E"/>
                     <Source>\nE Pop(){\n      return MEntryListC&lt;E&gt;::EntryPop();\n   }</Source>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="E" name="entry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Remove(E entry){\n      EntryRemove(entry);\n   }</Source>
                  </Method>
                  <Method name="Clear">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      MEntryListC&lt;E&gt;::EntryClear();\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MEntryListC">
               <Inherits>
                  <Inherit name="MLinkedEntryC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="operator==">
                     <Parameters>
                        <Parameter type="MEntryListC&lt;E&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator==(const MEntryListC&lt;E&gt;&amp; list) const{\n		return Equals(list);\n	}</Source>
                  </Method>
                  <Method name="operator!=">
                     <Parameters>
                        <Parameter type="MEntryListC&lt;E&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator!=(const MEntryListC&lt;E&gt;&amp; list) const{\n		return !Equals(list);\n	}</Source>
                  </Method>
                  <Method name="IsEmpty">
                     <Return type="TBool"/>
                     <Source>\nTBool IsEmpty() const{\n      return (0 == this-&gt;_count);\n   }</Source>
                  </Method>
                  <Method name="Count">
                     <Return type="TInt"/>
                     <Source>\nTInt Count() const{\n      return this-&gt;_count;\n   }</Source>
                  </Method>
                  <Method name="Equals">
                     <Parameters>
                        <Parameter type="MEntryListC&lt;E&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Equals(const MEntryListC&lt;E&gt;&amp; list) const{\n      // 比较数量\n      if(this-&gt;_count != list._count){\n         return EFalse;\n      }\n      // 比较所有项目\n      E pEntry = this-&gt;_pFirst;\n      TIteratorC iterator = list.IteratorC();\n      while(iterator.Next()){\n         if(pEntry != iterator.Get()){\n            return EFalse;\n         }\n         pEntry = pEntry-&gt;pNext;\n      }\n      return ETrue;\n	}</Source>
                  </Method>
                  <Method name="First">
                     <Return type="E"/>
                     <Source>\nE First() const{\n      return this-&gt;_pFirst;\n   }</Source>
                  </Method>
                  <Method name="Last">
                     <Return type="E"/>
                     <Source>\nE Last() const{\n      return this-&gt;_pLast;\n   }</Source>
                  </Method>
                  <Method name="IteratorC">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC IteratorC() const{\n		return TIteratorC(this-&gt;_pFirst);\n	}</Source>
                  </Method>
                  <Method name="LastIteratorC">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC LastIteratorC() const{\n		return TIteratorC(this-&gt;_pLast);\n	}</Source>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="E"/>
                     <Source>\nE Get(TInt index) const{\n      MO_ASSERT_RANGE(index, 0, this-&gt;_count);\n      // 获得第一个\n      if(0 == index){\n         return this-&gt;_pFirst;\n      }\n      // 获得指定位置数据\n      E pEntry = this-&gt;_pFirst;\n      while(--index &gt;= 0){\n         pEntry = pEntry-&gt;pNext;\n      }\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TIteratorC&amp;" name="iterator"/>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Find(const TIteratorC&amp; iterator, E pEntry) const{\n      while(iterator.Next()){\n         if(iterator.Equals(pEntry)){\n            return ETrue;\n         }\n      }\n		return EFalse;\n	}</Source>
                  </Method>
                  <Method name="FindC">
                     <Parameters>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC FindC(E pEntry) const{\n      TIteratorC&amp; iterator = IteratorC();\n      if(Find(iterator, pEntry)){\n         return iterator;\n      }\n		return LastIteratorC();\n	}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MLinkedEntryC">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Initialize" type="inline">
                     <Return type="void"/>
                     <Source>\ninline void Initialize(){\n      _count = 0;\n      _pFirst = NULL;\n      _pLast = NULL;\n      _pUnused = NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryUnshift" type="inline">
                     <Parameters>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryUnshift(E pEntry){\n      MO_ASSERT(pEntry);\n      // 压入首位置\n      if(NULL == _pFirst){\n         _pLast = pEntry;\n      }else{\n         _pFirst-&gt;pPrior = pEntry;\n      }\n      pEntry-&gt;pNext = _pFirst;\n      _pFirst = pEntry;\n      // 设置内容\n      _count++;\n      pEntry-&gt;pPrior = NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryShift" type="inline">
                     <Return type="E"/>
                     <Source>\ninline E EntryShift(){\n      E pEntry = _pFirst;\n      if(NULL != _pFirst){\n         // 读指针指向下一个位置\n         _pFirst = _pFirst-&gt;pNext;\n         if(NULL == _pFirst){\n            _pLast = NULL;\n         }else{\n            _pFirst-&gt;pPrior = NULL;\n         }\n         // 设置内容\n         _count--;\n         EntryFree(pEntry);\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryPush" type="inline">
                     <Parameters>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryPush(E pEntry){\n      MO_ASSERT(pEntry);\n      if(NULL == _pLast){\n         _pFirst = pEntry;\n      }else{\n         _pLast-&gt;pNext = pEntry;\n      }\n      pEntry-&gt;pPrior = _pLast;\n      _pLast = pEntry;\n      // 设置内容\n      _count++;\n      pEntry-&gt;pNext = NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryPop" type="inline">
                     <Return type="E"/>
                     <Source>\ninline E EntryPop(){\n      E pEntry = _pLast;\n      if(NULL != _pLast){\n         _pLast = _pLast-&gt;pPrior;\n         if(NULL == _pLast){\n            _pFirst = NULL;\n         }else{\n            _pLast-&gt;pNext = NULL;\n         }\n         // 设置内容\n         _count--;\n         EntryFree(pEntry);\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryInsert" type="inline">
                     <Parameters>
                        <Parameter type="E" name="pPrior"/>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryInsert(E pPrior, E pEntry){\n      MO_ASSERT(pPrior);\n      MO_ASSERT(pEntry);\n      E pNext = pPrior-&gt;pNext;\n      pPrior-&gt;pNext = pEntry;\n      pEntry-&gt;pPrior = pPrior;\n      if(NULL == pNext){\n         pEntry-&gt;pNext = NULL;\n         _pLast = pEntry;\n      }else{\n         pNext-&gt;pPrior = pEntry;\n         pEntry-&gt;pNext = pNext;\n      }\n	}</Source>
                  </Method>
                  <Method name="EntryRemove" type="inline">
                     <Parameters>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRemove(E pEntry){\n      MO_ASSERT(pEntry);\n      E pPrior = pEntry-&gt;pPrior;\n      E pNext = pEntry-&gt;pNext;\n      // 处理前节点\n      if(NULL == pPrior){\n         _pFirst = pNext;\n      }else{\n         pPrior-&gt;pNext = pNext;\n      }\n      // 处理后节点\n      if(NULL == pNext){\n         _pLast = pPrior;\n      }else{\n         pNext-&gt;pPrior = pPrior;\n      }\n      // 设置内容\n      _count--;\n      EntryFree(pEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryFree" type="inline">
                     <Parameters>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFree(E pEntry){\n      MO_ASSERT(pEntry);\n      pEntry-&gt;pNext = _pUnused;\n      _pUnused = pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryClear" type="inline">
                     <Return type="void"/>
                     <Source>\ninline void EntryClear(){\n      if(_count &gt; 0){\n         // 将使用节点全部放入回收节点\n         _pLast-&gt;pNext = _pUnused;\n         _pUnused = _pFirst;\n         // 清空内所有内容\n         _count = 0;\n         _pFirst = NULL;\n         _pLast = NULL;\n      }\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="E" name="_pFirst"/>
                  <Attribute type="E" name="_pLast"/>
                  <Attribute type="E" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="MLinkedIteratorC">
               <Methods>
                  <Method name="Initialize" type="inline">
                     <Parameters>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void Initialize(E pEntry){\n      _pStart = pEntry;\n      _pEntry = NULL;\n   }</Source>
                  </Method>
                  <Method name="*" type="inline">
                     <Return type="operator"/>
                     <Source>\ninline E&amp; operator *() const{\n      return this-&gt;_pEntry;\n   }</Source>
                  </Method>
                  <Method name="-&gt;" type="inline">
                     <Return type="operator"/>
                     <Source>\ninline E operator -&gt;() const{\n      return this-&gt;_pEntry;\n   }</Source>
                  </Method>
                  <Method name="Reset" type="inline">
                     <Return type="void"/>
                     <Source>\ninline void Reset(){\n      _pEntry = NULL;\n   }</Source>
                  </Method>
                  <Method name="HasNext" type="inline">
                     <Return type="TBool"/>
                     <Source>\ninline TBool HasNext(){\n      return (NULL == _pEntry) ? (NULL != _pStart) : (NULL == _pEntry-&gt;pNext);\n   }</Source>
                  </Method>
                  <Method name="Next" type="inline">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Next(){\n      _pEntry = (NULL == _pEntry) ? _pStart : _pEntry-&gt;pNext;\n      return (NULL != _pEntry);\n   }</Source>
                  </Method>
                  <Method name="HasPrior" type="inline">
                     <Return type="TBool"/>
                     <Source>\ninline TBool HasPrior(){\n      return (NULL == _pEntry) ? (NULL != _pStart) : (NULL == _pEntry-&gt;pPrior);\n   }</Source>
                  </Method>
                  <Method name="Prior" type="inline">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Prior(){\n      _pEntry = (NULL == _pEntry) ? _pStart : _pEntry-&gt;pPrior;\n      return (NULL != _pEntry);\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="E" name="_pStart"/>
                  <Attribute type="E" name="_pEntry"/>
               </Attributes>
            </Class>
            <Class name="MList">
               <Inherits>
                  <Inherit name="MListC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerCast" type="inline" description="获得内部类型指针。">
                     <Return type="A*"/>
                     <Source>\ninline A* InnerCast(){\n      return static_cast&lt;A*&gt;(this);\n   }</Source>
                  </Method>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      MListC&lt;T&gt;::InnerInitialize();\n      _pUnused = NULL;\n   }</Source>
                  </Method>
                  <Method name="InnerRelease" type="inline" description="内部释放。">
                     <Return type="void"/>
                     <Source>\ninline void InnerRelease(){\n      if(this-&gt;_count &gt; 0){\n         // 将所有节点设置为未使用\n         this-&gt;_pLast-&gt;pNext = this-&gt;_pUnused;\n         this-&gt;_pUnused = this-&gt;_pFirst;\n         // 删除所有节点\n         A* pInstance = InnerCast();\n         SEntry* pFind = this-&gt;_pUnused;\n         while(NULL != pFind){\n            SEntry* pNext = pFind-&gt;pNext;\n            pInstance-&gt;EntryRelease(pFind);\n            pFind = pNext;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="EntryAlloc" type="inline" description="收集一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryAlloc(){\n      SEntry* pEntry = NULL;\n      // 查看未使用节点中是否有自由节点\n      if(NULL != this-&gt;_pUnused){\n         // 收集未使用的节点\n         pEntry = this-&gt;_pUnused;\n         this-&gt;_pUnused = this-&gt;_pUnused-&gt;pNext;\n      }else{\n         // 收集新节点\n         pEntry = InnerCast()-&gt;A::EntryCreate();\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryFree" type="inline" description="释放一个被使用的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFree(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      pEntry-&gt;pNext = this-&gt;_pUnused;\n      this-&gt;_pUnused = pEntry;\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="追加一个内容到当前链表中。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(T value){\n		Push(value);\n	}</Source>
                  </Method>
                  <Method name="operator-=" description="从当前链表中删除一个内容。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator-=(T value){\n      Remove(value);\n	}</Source>
                  </Method>
                  <Method name="operator+=" description="追加一个链表到当前链表中。">
                     <Parameters>
                        <Parameter type="MListC&lt;T&gt;*" name="pList"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(const MListC&lt;T&gt;* pList){\n		Append(pList);\n	}</Source>
                  </Method>
                  <Method name="Iterator" description="获得首位置的只读数据迭代器。">
                     <Return type="TIterator"/>
                     <Source>\nTIterator Iterator(){\n		return TIterator(this-&gt;_pFirst);\n	}</Source>
                  </Method>
                  <Method name="LastIterator" description="获得尾位置的只读数据迭代器。">
                     <Return type="TIterator"/>
                     <Source>\nTIterator LastIterator(){\n		return TIterator(this-&gt;_pLast);\n	}</Source>
                  </Method>
                  <Method name="Find" description="在当前链表中查找指定数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TIterator"/>
                     <Source>\nTIterator Find(T value){\n      if(this-&gt;_count &gt; 0){\n         SEntry* pFind = this-&gt;_pFirst;\n         while(NULL != pFind){\n            if(pFind-&gt;value == value){\n		         return TIterator(pFind);\n            }\n            pFind = pFind-&gt;pNext;\n         }\n      }\n      return TIterator();\n	}</Source>
                  </Method>
                  <Method name="Assign" description="接受一个链表到当前链表中。">
                     <Parameters>
                        <Parameter type="MListC&lt;T&gt;*" name="pList"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MListC&lt;T&gt;* pList){\n      MO_ASSERT(pList);\n		Clear();\n      Append(pList);\n	}</Source>
                  </Method>
                  <Method name="Assign" description="接受一个链表到当前链表中。">
                     <Parameters>
                        <Parameter type="TIteratorC&amp;" name="iterator"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(TIteratorC&amp; iterator){\n		Clear();\n      Append(iterator);\n	}</Source>
                  </Method>
                  <Method name="Append" description="追加一个链表到当前链表中。">
                     <Parameters>
                        <Parameter type="MListC&lt;T&gt;*" name="pList"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MListC&lt;T&gt;* pList){\n      MO_ASSERT(pList);\n		TIteratorC iterator = pList-&gt;IteratorC();\n		while(iterator.Next()){\n			Push(*iterator);\n		}\n	}</Source>
                  </Method>
                  <Method name="Append" description="追加一个链表到当前链表中。">
                     <Parameters>
                        <Parameter type="TIteratorC&amp;" name="iterator"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(TIteratorC&amp; iterator){\n		while(iterator.Next()){\n			Push(*iterator);\n		}\n	}</Source>
                  </Method>
                  <Method name="Unshift" description="将数据压入首位置。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Unshift(T value){\n      // 收集一个未使用得节点\n      SEntry* pEntry = InnerCast()-&gt;A::EntryAlloc();\n      // 将节点压入尾部\n      pEntry-&gt;value = value;\n      EntryUnshift(pEntry);\n   }</Source>
                  </Method>
                  <Method name="Shift" description="弹出链表的首数据。">
                     <Return type="T"/>
                     <Source>\nT Shift(){\n      SEntry* pEntry = this-&gt;EntryShift();\n      MO_ASSERT(pEntry);\n      T value = pEntry-&gt;value;\n      EntryFree(pEntry);\n      return value;\n   }</Source>
                  </Method>
                  <Method name="Push" description="将数据压入尾位置。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Push(T value){\n      // 收集一个未使用得节点\n      SEntry* pEntry = InnerCast()-&gt;A::EntryAlloc();\n      // 将节点压入尾部\n      pEntry-&gt;value = value;\n      EntryPush(pEntry);\n   }</Source>
                  </Method>
                  <Method name="Pop" description="弹出链表的尾数据。">
                     <Return type="T"/>
                     <Source>\nT Pop(){\n      SEntry* pEntry = this-&gt;EntryPop();\n      MO_ASSERT(pEntry);\n      T value = pEntry-&gt;value;\n      EntryFree(pEntry);\n      return value;\n   }</Source>
                  </Method>
                  <Method name="Remove" description="从链表上删除数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Remove(T value){\n      SEntry* pEntry = this-&gt;_pFirst;\n      while(NULL != pEntry){\n         SEntry* pNext = pEntry-&gt;pNext;\n         if(pEntry-&gt;value == value){\n            EntryRemove(pEntry);\n            EntryFree(pEntry);\n         }\n         pEntry = pNext;\n      }\n   }</Source>
                  </Method>
                  <Method name="Sort" description="使用排序器对集合对象进行排序">
                     <Parameters>
                        <Parameter type="IComparer&lt;T&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Sort(IComparer&lt;T&gt;* pComparer){\n      MO_ASSERT(pComparer);\n      if(this-&gt;_pFirst &amp;&amp; this-&gt;_pLast &amp;&amp; this-&gt;_count &gt; 1) {\n         if(MO_COMPLIST_THRESHOLD &gt; this-&gt;_count){\n            RComparerSort&lt;T&gt;::ListInsertSort(this-&gt;_pFirst, this-&gt;_pLast, pComparer);\n         } else{\n            RComparerSort&lt;T&gt;::ListQuickSort(this-&gt;_pFirst, this-&gt;_pLast, pComparer);\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清空所有数据。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      if(this-&gt;_count){\n         // 重用节点\n         this-&gt;_pLast-&gt;pNext = _pUnused;\n         _pUnused = this-&gt;_pFirst;\n         // 重置内容\n         this-&gt;EntryClear();\n      }\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SEntry*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="MListC">
               <Inherits>
                  <Inherit name="MEntriesC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="operator==" description="判断当前链表和指定链表中所有数据内容是否相等。">
                     <Parameters>
                        <Parameter type="MListC&lt;T&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator==(const MListC&lt;T&gt;&amp; list) const{\n		return Equals(&amp;list);\n	}</Source>
                  </Method>
                  <Method name="operator!=" description="判断当前链表和指定链表中所有数据内容是否不相等。">
                     <Parameters>
                        <Parameter type="MListC&lt;T&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator!=(const MListC&lt;T&gt;&amp; list) const{\n		return !Equals(&amp;list);\n	}</Source>
                  </Method>
                  <Method name="IsEmpty" description="获得是否为空。">
                     <Return type="TBool"/>
                     <Source>\nTBool IsEmpty() const{\n      return (0 == this-&gt;_count);\n   }</Source>
                  </Method>
                  <Method name="Count" description="获得总数。">
                     <Return type="TInt"/>
                     <Source>\nTInt Count() const{\n      return this-&gt;_count;\n   }</Source>
                  </Method>
                  <Method name="Equals" description="判断当前链表和指定链表是否相等。">
                     <Parameters>
                        <Parameter type="MListC&lt;T&gt;*" name="pList"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Equals(const MListC&lt;T&gt;* pList) const{\n      MO_ASSERT(pList);\n      // 比较数量\n      if(this-&gt;_count != pList-&gt;Count()){\n         return EFalse;\n      }\n      // 比较所有项目\n      SEntry* pEntry = this-&gt;_pFirst;\n      TIteratorC iterator = pList-&gt;IteratorC();\n      while((NULL != pEntry) &amp;&amp; iterator.Next()){\n         if(!iterator.Equals(pEntry-&gt;value)){\n            return EFalse;\n         }\n         pEntry = pEntry-&gt;pNext;\n      }\n      return ETrue;\n	}</Source>
                  </Method>
                  <Method name="First" description="获得首位置的数据。">
                     <Return type="T"/>
                     <Source>\nT First() const{\n      return (NULL != this-&gt;_pFirst) ? this-&gt;_pFirst-&gt;value : NULL;\n   }</Source>
                  </Method>
                  <Method name="Last" description="获得尾位置的数据。">
                     <Return type="T"/>
                     <Source>\nT Last() const{\n      return (NULL != this-&gt;_pLast) ? this-&gt;_pLast-&gt;value : NULL;\n   }</Source>
                  </Method>
                  <Method name="IteratorC" description="获得首位置的只读数据迭代器。">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC IteratorC() const{\n		return TIteratorC(this-&gt;_pFirst);\n	}</Source>
                  </Method>
                  <Method name="LastIteratorC" description="获得尾位置的只读数据迭代器。">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC LastIteratorC() const{\n		return TIteratorC(this-&gt;_pLast);\n	}</Source>
                  </Method>
                  <Method name="Get" description="获得指定位置的数据。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Get(TInt index) const{\n      SEntry* pEntry = this-&gt;EntryGet(index);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="FindC" description="在当前链表中查找指定数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC FindC(T value) const{\n      if(this-&gt;_count &gt; 0){\n         // 比较所有项目\n         SEntry* pEntry = this-&gt;_pFirst;\n         while(NULL != pEntry){\n            if(pEntry-&gt;value == value){\n               return TIteratorC(pEntry);\n            }\n            pEntry = pEntry-&gt;pNext;\n         }\n      }\n		return TIteratorC();\n	}</Source>
                  </Method>
                  <Method name="FindC" description="在指定链表迭代器中查找指定数据。">
                     <Parameters>
                        <Parameter type="TIteratorC&amp;" name="iterator"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool FindC(TIteratorC&amp; iterator, T value) const{\n      while(iterator.Next()){\n         if(iterator.Equals(value)){\n            return ETrue;\n         }\n      }\n		return EFalse;\n	}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MMap">
               <Inherits>
                  <Inherit name="MMapC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerCast" type="inline" description="获得内部类型指针。">
                     <Return type="A*"/>
                     <Source>\ninline A* InnerCast(){\n      return static_cast&lt;A*&gt;(this);\n   }</Source>
                  </Method>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      MMapC&lt;N, V&gt;::InnerInitialize();\n      _pUnused = NULL;\n      InnerCast()-&gt;A::EnsureSize(size);\n   }</Source>
                  </Method>
                  <Method name="InnerRelease" type="inline" description="内部释放。">
                     <Return type="void"/>
                     <Source>\ninline void InnerRelease(){\n      A* pInstance = InnerCast();\n      // 释放节点\n      if(this-&gt;_count &gt; 0){\n         // 将所有节点设置为未使用\n         this-&gt;_pLast-&gt;pNext = this-&gt;_pUnused;\n         this-&gt;_pUnused = this-&gt;_pFirst;\n         // 删除所有节点\n         SEntry* pFind = this-&gt;_pUnused;\n         while(NULL != pFind){\n            SEntry* pNext = pFind;\n            pInstance-&gt;EntryRelease(pFind);\n            pFind = pNext;\n         }\n      }\n      // 释放节点数组\n      pInstance-&gt;EntryFlatFree(this-&gt;_ppEntries);\n   }</Source>
                  </Method>
                  <Method name="EntryAlloc" type="inline" description="收集一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryAlloc(){\n      SEntry* pEntry = NULL;\n      // 查看未使用节点中是否有自由节点\n      if(NULL != this-&gt;_pUnused){\n         // 收集未使用的节点\n         pEntry = this-&gt;_pUnused;\n         this-&gt;_pUnused = this-&gt;_pUnused-&gt;pNext;\n      }else{\n         // 收集新节点\n         pEntry = InnerCast()-&gt;A::EntryCreate();\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryFree" type="inline" description="释放一个被使用的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFree(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      pEntry-&gt;pNext = this-&gt;_pUnused;\n      this-&gt;_pUnused = pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntriesResize" type="inline" description="扩充当前对象的哈希值数组。">
                     <Parameters>
                        <Parameter type="SEntry**" name="ppEntries"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntriesResize(SEntry** ppEntries, TInt size){\n      // 循环取出旧的节点列表内容，移到新的节点列表上\n      TInt n = 0;\n      while(++n &lt; this-&gt;_entryCount){\n         SEntry* pEntry = this-&gt;_ppEntries[n];\n         while(NULL != pEntry){\n            // 保存当前节点的下一个节点指针\n            SEntry* pLink = pEntry-&gt;pLink;\n            // 将当前节点存储到新建的节点列表上去\n            TInt index = pEntry-&gt;code % size;\n            pEntry-&gt;pLink = ppEntries[index];\n            ppEntries[index] = pEntry;\n            // 获得保存的下一个节点指针\n            pEntry = pLink;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Iterator" description="获得可写迭代器。">
                     <Return type="TIterator"/>
                     <Source>\nTIterator Iterator(){\n      return TIterator(this-&gt;_pFirst);\n   }</Source>
                  </Method>
                  <Method name="LastIterator" description="获得结尾可写迭代器。">
                     <Return type="TIterator"/>
                     <Source>\nTIterator LastIterator(){\n      return TIterator(this-&gt;_pLast);\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接收源哈希表内的全部数据。">
                     <Parameters>
                        <Parameter type="MMapC&lt;N, V&gt;*" name="pMap"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MMapC&lt;N, V&gt;* pMap){\n      MO_ASSERT(pMap);\n      Clear();\n      Append(pMap);\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加源哈希表内的全部数据。">
                     <Parameters>
                        <Parameter type="MMapC&lt;N, V&gt;*" name="pMap"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MMapC&lt;N, V&gt;* pMap){\n      MO_ASSERT(pMap);\n      TIteratorC iterator = pMap-&gt;IteratorC();\n      while(iterator.Next()){\n         Set(iterator.Name(), iterator.Value());\n      }\n   }</Source>
                  </Method>
                  <Method name="Set" description="根据名称设置数据。">
                     <Parameters>
                        <Parameter type="N" name="name"/>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(N name, V value){\n      THashCode hash = MakeHashCode(name);\n      TInt index = hash % this-&gt;_entryCount;\n      // 查找数据出现的位置\n      SEntry* pEntry = this-&gt;_ppEntries[index];\n      while(NULL != pEntry) {\n         if(pEntry-&gt;Hash == hash){\n            if(name-&gt;Equals(pEntry-&gt;name)){\n               pEntry-&gt;value = value;\n               return;\n            }\n         }\n         pEntry = pEntry-&gt;Next;\n      }\n      // 如果名称不存在，为新建节点检查内存\n      pEntry = InnerCast()-&gt;A::EntryAlloc();\n      pEntry-&gt;pLink = this-&gt;_ppEntries[index];\n      pEntry-&gt;hash = hash;\n      pEntry-&gt;name = name;\n      pEntry-&gt;value = value;\n      this-&gt;_ppEntries[index] = pEntry;\n      // 追加到链表尾部\n      EntryPush(pEntry);\n   }</Source>
                  </Method>
                  <Method name="Remove" description="移除指定名称的数据。">
                     <Parameters>
                        <Parameter type="N" name="name"/>
                     </Parameters>
                     <Return type="V"/>
                     <Source>\nV Remove(N name){\n      THashCode hash = MakeHashCode(name);\n      TInt index = hash % this-&gt;_entryCount;\n      // 查找数据出现的位置\n      V value = NULL;\n      SEntry* pPrior = this-&gt;_ppEntries[index];\n      SEntry* pEntry = pPrior;\n      while(NULL != pEntry){\n         if(pEntry-&gt;hash == hash){\n            if(name-&gt;Equals(pEntry-&gt;name)){\n               value = pEntry-&gt;value;\n               if(pEntry == pPrior){\n                  // 当前对象是第一个对象时\n                  this-&gt;_ppEntries[index] = pEntry-&gt;Next;\n               }else{\n                  // 当前对象不是第一个对象时\n                  pPrior-&gt;Next = pEntry-&gt;Next;\n               }\n               // 删除当前节点\n               EntryRemove(pEntry);\n               break;\n            }\n         }\n         pPrior = pEntry;\n         pEntry = pEntry-&gt;Next;\n      }\n      return value;\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清空当前哈希表全部数据。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;EntryClear();\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SEntry*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="MMapC">
               <Inherits>
                  <Inherit name="MEntriesC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      MEntriesC&lt;SEntry&gt;::InnerInitialize();\n      _entryCount = 0;\n      _ppEntries = NULL;\n   }</Source>
                  </Method>
                  <Method name="operator==" description="判断当前哈希表和指定哈希表中所有数据内容是否相等。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="set"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator==(const MSetC&lt;N, V&gt;&amp; set) const{\n		return Equals(&amp;set);\n	}</Source>
                  </Method>
                  <Method name="operator!=" description="判断当前哈希表和指定哈希表中所有数据内容是否不相等。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="set"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator!=(const MSetC&lt;N, V&gt;&amp; set) const{\n		return !Equals(&amp;set);\n	}</Source>
                  </Method>
                  <Method name="operator[]" description="获得指定名称的数据内容。">
                     <Parameters>
                        <Parameter type="N" name="name"/>
                     </Parameters>
                     <Return type="V"/>
                     <Source>\nV operator[](N name){\n      SEntry* pEntry = EntryFind(name);\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n	}</Source>
                  </Method>
                  <Method name="EntryFind" type="inline" description="查找指定名称的索引位置。">
                     <Parameters>
                        <Parameter type="N" name="name"/>
                     </Parameters>
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryFind(N name) const{\n      // 数据存在时\n      if(this-&gt;_count &gt; 0){\n         THashCode hash = MakeHashCode(name);\n         // 查找名称的索引位置\n         SEntry* pEntry = _ppEntries[hash % _entryCount];\n         while(NULL != pEntry){\n            if(pEntry-&gt;hash == hash){\n               if(name == pEntry-&gt;name){\n                  return pEntry;\n               }\n            }\n            pEntry = pEntry-&gt;pNext;\n         }\n      }\n      // 未找到时返回结果\n      return NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryFindValue" type="inline" description="查找指定名称的索引位置。">
                     <Parameters>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryFindValue(V value) const{\n      // 数据存在时\n      if(this-&gt;_count &gt; 0){\n         TInt n = 0;\n         while(++n &lt; _entryCount){\n            SEntry* pEntry = _ppEntries[n];\n            while(NULL != pEntry){\n               if(pEntry-&gt;value == value){\n                  return pEntry;\n               }\n               pEntry = pEntry-&gt;pNext;\n            }\n         }\n      }\n      // 未找到时返回结果\n      return NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryClear" type="inline">
                     <Return type="void"/>
                     <Source>\ninline void EntryClear(){\n      // 清除表格\n      TInt n = -1;\n      while(++n &lt; _entryCount){\n         _ppEntries[n] = NULL;\n      }\n      // 清除链表\n      MEntriesC&lt;SEntry&gt;::EntryClear();\n   }</Source>
                  </Method>
                  <Method name="IsEmpty" description="当前哈希集合对象是否为空。">
                     <Return type="EBoolean"/>
                     <Source>\nEBoolean IsEmpty() const{\n      return (0 == this-&gt;_count);\n   }</Source>
                  </Method>
                  <Method name="Count" description="获得数据个数。">
                     <Return type="TInt"/>
                     <Source>\nTInt Count() const{\n      return this-&gt;_count;\n   }</Source>
                  </Method>
                  <Method name="Contains" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="N" name="name"/>
                     </Parameters>
                     <Return type="EBoolean"/>
                     <Source>\nEBoolean Contains(N name) const{\n      return (NULL != EntryFind(name));\n   }</Source>
                  </Method>
                  <Method name="ContainsValue" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="EBoolean"/>
                     <Source>\nEBoolean ContainsValue(V value) const{\n      return (NULL != EntryFindValue(value));\n   }</Source>
                  </Method>
                  <Method name="Equals" description="判断当前哈希表和指定哈希集合表是否相等。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;*" name="pMap"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Equals(const MSetC&lt;N, V&gt;* pMap) const{\n      MO_ASSERT(pMap);\n      // 比较数量\n      if(this-&gt;_count != pMap-&gt;_count){\n         return EFalse;\n      }\n      // 比较所有项目\n      SEntry* pEntry = this-&gt;_pFirst;\n      TIteratorC iterator = pMap-&gt;IteratorC();\n      while(iterator.Next()){\n         N&amp; name = iterator.Name();\n         SEntry* pEntry = this-&gt;EntryFind(name);\n         if(NULL == pEntry){\n            return EFalse;\n         }\n         if(!iterator.IsValue(pEntry-&gt;value)){\n            return EFalse;\n         }\n      }\n      return ETrue;\n	}</Source>
                  </Method>
                  <Method name="First" description="获得首位置的数据。">
                     <Return type="V"/>
                     <Source>\nV First() const{\n      return (NULL != this-&gt;_pFirst) ? this-&gt;_pFirst-&gt;value : NULL;\n   }</Source>
                  </Method>
                  <Method name="Last" description="获得尾位置的数据。">
                     <Return type="V"/>
                     <Source>\nV Last() const{\n      return (NULL != this-&gt;_pLast) ? this-&gt;_pLast-&gt;value : NULL;\n   }</Source>
                  </Method>
                  <Method name="IteratorC" description="获得只读迭代器。">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC IteratorC(){\n      return TIteratorC(this-&gt;_pFirst);\n   }</Source>
                  </Method>
                  <Method name="LastIteratorC" description="获得结尾只读迭代器。">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC LastIteratorC(){\n      return TIteratorC(this-&gt;_pLast);\n   }</Source>
                  </Method>
                  <Method name="Get" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="N" name="name"/>
                     </Parameters>
                     <Return type="V"/>
                     <Source>\nV Get(N name) const{\n      SEntry* pEntry = EntryFind(name);\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="Find" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="N" name="name"/>
                     </Parameters>
                     <Return type="V"/>
                     <Source>\nV Find(N name) const{\n      SEntry* pEntry = EntryFind(name);\n      return (NULL != pEntry) ? pEntry-&gt;value : (V)NULL;\n   }</Source>
                  </Method>
                  <Method name="Search" description="获得指定数据的名称。">
                     <Parameters>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="N"/>
                     <Source>\nN Search(V value) const{\n      SEntry* pEntry = EntryFindValue(value);\n      return (NULL != pEntry) ? pEntry-&gt;name : (N)NULL;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_entryCount"/>
                  <Attribute type="SEntry**" name="_ppEntries"/>
               </Attributes>
            </Class>
            <Class name="MMonitor">
               <Methods>
                  <Constructor name="MMonitor" description="。"/>
                  <Destructor name="~MMonitor"/>
                  <Method name="IsName" flag="override">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool MMonitor::IsName(TCharC* pName) const{\n   return _name.Equals(pName);\n}</Source>
                  </Method>
                  <Method name="Name" flag="override">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* MMonitor::Name() const{\n   return _name.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Total" flag="override">
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MMonitor::Total() const{\n   return _total;\n}</Source>
                  </Method>
                  <Method name="Count" flag="override">
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MMonitor::Count() const{\n   return _count;\n}</Source>
                  </Method>
                  <Method name="Delay" flag="override">
                     <Return type="TTimeSpan"/>
                     <Source>//============================================================\n\nTTimeSpan MMonitor::Delay() const {\n   return _delay;\n}</Source>
                  </Method>
                  <Method name="Interval" flag="override">
                     <Return type="TTimeSpan"/>
                     <Source>//============================================================\n\nTTimeSpan MMonitor::Interval() const {\n   return _interval;\n}</Source>
                  </Method>
                  <Method name="Test" flag="override">
                     <Parameters>
                        <Parameter type="TTimeSpan" name="interval"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool MMonitor::Test(TTimeSpan interval){\n   TBool result = EFalse;\n   if(_total &lt; 0 ||  _count  &gt; 0){ // 无限循环或者循环次数还有\n       _current -= interval;\n       if( _current &lt; 0 ){\n          _current = _interval; // 重置时间\n          --_count;\n          result = ETrue;\n       }\n\n   }\n   return result;\n}</Source>
                  </Method>
                  <Method name="SetTotal">
                     <Parameters>
                        <Parameter type="TInt" name="total"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MMonitor::SetTotal(TInt total){\n   _total = total;\n   _count = total;\n}</Source>
                  </Method>
                  <Method name="SetDelay">
                     <Parameters>
                        <Parameter type="TTimeSpan" name="delay"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MMonitor::SetDelay(TTimeSpan delay){\n   _delay = delay;\n   _current = delay;\n}</Source>
                  </Method>
                  <Method name="SetInterval">
                     <Parameters>
                        <Parameter type="TTimeSpan" name="interval"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MMonitor::SetInterval(TTimeSpan interval){\n   _interval = interval;\n   _current = interval;\n}</Source>
                  </Method>
                  <Method name="LoadConfig" flag="override">
                     <Parameters>
                        <Parameter type="FXmlNode*" name="pConfig"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool MMonitor::LoadConfig(FXmlNode* pConfig){\n   TXmlNodeIteratorC iterator = pConfig-&gt;NodeIteratorC();\n   while(iterator.Next()){\n      if(iterator-&gt;IsName(MO_TAG_PROPERTY)){\n         if(iterator-&gt;IsAttribute(MO_PTY_NAME, &quot;delay&quot;)){\n            // 读取延迟\n            TInt delay = iterator-&gt;TextAsInt();\n            MO_DEBUG(&quot;Load monitor(%s) property. (delay=%dms)&quot;, (TCharC*)_name, delay);\n            _delay = delay * 1000;\n         }else if(iterator-&gt;IsAttribute(MO_PTY_NAME, &quot;interval&quot;)){\n            // 读取延迟\n            TInt interval = iterator-&gt;TextAsInt(MO_MONITOR_INTERVAL);\n            MO_DEBUG(&quot;Load monitor(%s) property. (interval=%dms)&quot;, (TCharC*)_name, interval);\n            _interval = interval * 1000;\n         }else if(iterator-&gt;IsAttribute(MO_PTY_NAME, &quot;total&quot;)){\n            // 读取延迟\n            TInt total = iterator-&gt;TextAsInt();\n            MO_DEBUG(&quot;Load monitor(%s) property. (total=%d)&quot;, (TCharC*)_name, total);\n            SetTotal(total);\n         }\n      }\n   }\n   _current = (_delay &gt; 0) ? _delay : _interval;\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsName" name="_name"/>
                  <Attribute type="TTimeSpan" name="_delay"/>
                  <Attribute type="TTimeSpan" name="_interval"/>
                  <Attribute type="TTimeSpan" name="_current"/>
                  <Attribute type="TInt" name="_total"/>
                  <Attribute type="TInt" name="_count"/>
               </Attributes>
            </Class>
            <Class name="MNamed">
               <Methods>
                  <Method name="Name" description="获得名称。">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得名称。&lt;/T&gt;\n//\n// @return 名称\n//============================================================\n\nTCharC* MNamed::Name() const{\n   return _name.MemoryC();\n}</Source>
                  </Method>
                  <Method name="SetName" description="设置名称。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置名称。&lt;/T&gt;\n//\n// @param pName 名称\n//============================================================\n\nvoid MNamed::SetName(TCharC* pName){\n      _name.Assign(pName);\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsName" name="_name"/>
               </Attributes>
            </Class>
            <Class name="MNcAttributes">
               <Inherits>
                  <Inherit name="MNcAttributesC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      MNcAttributesC::InnerInitialize();\n      _pUnused = NULL;\n      EnsureSize(size);\n   }</Source>
                  </Method>
                  <Method name="InnerRelease" type="inline" description="内部释放。">
                     <Return type="void"/>
                     <Source>\ninline void InnerRelease(){\n      // 释放节点\n      if(this-&gt;_count &gt; 0){\n         // 将所有节点设置为未使用\n         this-&gt;_pLast-&gt;pNext = this-&gt;_pUnused;\n         this-&gt;_pUnused = this-&gt;_pFirst;\n         // 删除所有节点\n         SEntry* pFind = this-&gt;_pUnused;\n         while(NULL != pFind){\n            SEntry* pNext = pFind;\n            MO_DELETE(pFind);\n            pFind = pNext;\n         }\n      }\n      // 释放节点数组\n      RTypeMemory&lt;SEntry*&gt;::Free(this-&gt;_ppEntries);\n   }</Source>
                  </Method>
                  <Method name="EnsureSize">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Assign">
                     <Parameters>
                        <Parameter type="MNcAttributesC&amp;" name="attributes"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="MNcAttributesC&amp;" name="attributes"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TString"/>
                  </Method>
                  <Method name="Clear">
                     <Return type="void"/>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SEntry*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="MNcAttributesC">
               <Inherits>
                  <Inherit name="MEntriesC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      MEntriesC&lt;SEntry&gt;::InnerInitialize();\n      _entryCount = 0;\n      _ppEntries = NULL;\n   }</Source>
                  </Method>
                  <Method name="operator[]">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                  </Method>
                  <Method name="EntryFind">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="SAttributesEntry*"/>
                  </Method>
                  <Method name="EntryFindValue">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="SAttributesEntry*"/>
                  </Method>
                  <Method name="IsEmpty">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Count">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Contains">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="ContainsValue">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                  </Method>
                  <Method name="FindNvl">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="TCharC*" name="pDefault"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                  </Method>
                  <Method name="Search">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                  </Method>
                  <Method name="IteratorC">
                     <Return type="TAttributesIteratorC"/>
                  </Method>
                  <Method name="Dump">
                     <Return type="TString"/>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_entryCount"/>
                  <Attribute type="SAttributesEntry**" name="_ppEntries"/>
               </Attributes>
            </Class>
            <Class name="MNcDictionary">
               <Inherits>
                  <Inherit name="MNcDictionaryC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerCast" type="inline" description="获得内部类型指针。">
                     <Return type="A*"/>
                     <Source>\ninline A* InnerCast(){\n      return static_cast&lt;A*&gt;(this);\n   }</Source>
                  </Method>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      MNcDictionaryC&lt;T&gt;::InnerInitialize();\n      _pUnused = NULL;\n      InnerCast()-&gt;A::EnsureSize(size);\n   }</Source>
                  </Method>
                  <Method name="InnerRelease" description="释放哈希表对象。">
                     <Return type="void"/>
                     <Source>\nvoid InnerRelease(){\n      A* pInstance = InnerCast();\n      // 释放节点\n      if(this-&gt;_count &gt; 0){\n         // 将所有节点设置为未使用\n         this-&gt;_pLast-&gt;pNext = this-&gt;_pUnused;\n         this-&gt;_pUnused = this-&gt;_pFirst;\n         // 删除所有节点\n         SEntry* pFind = this-&gt;_pUnused;\n         while(NULL != pFind){\n            SEntry* pNext = pFind-&gt;pNext;\n            pInstance-&gt;EntryRelease(pFind);\n            pFind = pNext;\n         }\n      }\n      // 释放节点数组\n      pInstance-&gt;EntryFlatRelease(this-&gt;_ppEntries);\n   }</Source>
                  </Method>
                  <Method name="EntryAlloc" type="inline" description="收集一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryAlloc(){\n      SEntry* pEntry = NULL;\n      // 查看未使用节点中是否有自由节点\n      if(NULL != this-&gt;_pUnused){\n         // 收集未使用的节点\n         pEntry = this-&gt;_pUnused;\n         this-&gt;_pUnused = this-&gt;_pUnused-&gt;pNext;\n      }else{\n         // 收集新节点\n         pEntry = InnerCast()-&gt;A::EntryCreate();\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryFree" type="inline" description="释放一个被使用的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFree(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      pEntry-&gt;pNext = this-&gt;_pUnused;\n      this-&gt;_pUnused = pEntry;\n   }</Source>
                  </Method>
                  <Method name="operator[]" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="T&amp;"/>
                     <Source>\nT&amp; operator[](TCharC* pName){\n      MO_ASSERT(pName);\n      SEntry* pEntry = this-&gt;EntryFind(pName);\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="operator[]" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="T&amp;"/>
                     <Source>\nT&amp; operator[](const MStringPtrC&amp; name){\n      SEntry* pEntry = this-&gt;EntryFind(name.MemoryC());\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="EntriesResize" type="inline" description="扩充当前对象的哈希值数组。">
                     <Parameters>
                        <Parameter type="SEntry**" name="ppEntries"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntriesResize(SEntry** ppEntries, TInt size){\n      // 循环取出旧的节点列表内容，移到新的节点列表上\n      TInt n = 0;\n      while(++n &lt; this-&gt;_entryCount){\n         SEntry* pEntry = this-&gt;_ppEntries[n];\n         while(NULL != pEntry){\n            // 保存当前节点的下一个节点指针\n            SEntry* pLink = pEntry-&gt;pLink;\n            // 将当前节点存储到新建的节点列表上去\n            TInt index = pEntry-&gt;Hash() % size;\n            pEntry-&gt;pLink = ppEntries[index];\n            ppEntries[index] = pEntry;\n            // 获得保存的下一个节点指针\n            pEntry = pLink;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Iterator" description="获得可写迭代器。">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC Iterator(){\n      return TIterator(this-&gt;_pFirst);\n   }</Source>
                  </Method>
                  <Method name="LastIterator" description="获得结尾可写迭代器。">
                     <Return type="TIterator"/>
                     <Source>\nTIterator LastIterator(){\n      return TIterator(this-&gt;_pLast);\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接收源哈希表内的全部数据。">
                     <Parameters>
                        <Parameter type="MNcDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MNcDictionaryC&lt;T&gt;&amp; dictionary){\n      Clear();\n      Append(dictionary);\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加源哈希表内的全部数据。">
                     <Parameters>
                        <Parameter type="MNcDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MNcDictionaryC&lt;T&gt;&amp; dictionary){\n      TDictionaryIteratorC&lt;T&gt; iterator = dictionary.IteratorC();\n      while(iterator.Next()){\n         Set(iterator.Name(), iterator.Value());\n      }\n   }</Source>
                  </Method>
                  <Method name="Set" description="根据名称设置数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(TCharC* pName, T value){\n      THashCode hash = RString::MakeNocaseHashCode(pName);\n      TInt index = hash % this-&gt;_entryCount;\n      // 查找数据出现的位置\n      SEntry* pEntry = this-&gt;_ppEntries[index];\n      while(NULL != pEntry) {\n         if(pEntry-&gt;hash == hash){\n            if(pEntry-&gt;IsNameIgnoreCase(pName)){\n               pEntry-&gt;value = value;\n               return;\n            }\n         }\n         pEntry = pEntry-&gt;pNext;\n      }\n      // 如果名称不存在，为新建节点检查内存\n      pEntry = EntryAlloc();\n      pEntry-&gt;pLink = this-&gt;_ppEntries[index];\n      pEntry-&gt;hash = hash;\n      pEntry-&gt;SetName(pName);\n      pEntry-&gt;value = value;\n      this-&gt;_ppEntries[index] = pEntry;\n      // 追加到链表尾部\n      EntryPush(pEntry);\n   }</Source>
                  </Method>
                  <Method name="Set" description="根据名称设置数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(const MStringPtrC&amp; name, T value){\n      Set(name.MemoryC(), value);\n   }</Source>
                  </Method>
                  <Method name="Remove" description="移除指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Remove(TCharC* pName){\n      THashCode hash = RString::MakeNocaseHashCode(pName);\n      TInt index = hash % this-&gt;_entryCount;\n      // 查找数据出现的位置\n      T value = NULL;\n      SEntry* pPrior = this-&gt;_ppEntries[index];\n      SEntry* pEntry = pPrior;\n      while(NULL != pEntry){\n         if(pEntry-&gt;hash == hash){\n            if(pEntry-&gt;IsNameIgnoreCase(pName)){\n               value = pEntry-&gt;value;\n               if(pEntry == pPrior){\n                  // 当前对象是第一个对象时\n                  this-&gt;_ppEntries[index] = pEntry-&gt;pNext;\n               }else{\n                  // 当前对象不是第一个对象时\n                  pPrior-&gt;pNext = pEntry-&gt;pNext;\n               }\n               // 删除当前节点\n               EntryRemove(pEntry);\n               break;\n            }\n         }\n         pPrior = pEntry;\n         pEntry = pEntry-&gt;pNext;\n      }\n      return value;\n   }</Source>
                  </Method>
                  <Method name="Remove" description="移除指定名称的数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Remove(const MStringPtrC&amp; name){\n      return Remove(name.MemoryC());\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清空当前哈希表全部数据，是哈希表可以再次被利用。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;EntryClear();\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SEntry*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="MNcDictionaryC">
               <Inherits>
                  <Inherit name="MEntriesC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      MEntriesC&lt;SEntry&gt;::InnerInitialize();\n      _entryCount = 0;\n      _ppEntries = NULL;\n   }</Source>
                  </Method>
                  <Method name="operator==" description="判断当前哈希集合和指定哈希集合中所有数据内容是否相等。">
                     <Parameters>
                        <Parameter type="MNcDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator==(const MNcDictionaryC&lt;T&gt;&amp; dictionary) const{\n		return Equals(&amp;dictionary);\n	}</Source>
                  </Method>
                  <Method name="operator!=" description="判断当前哈希集合和指定哈希集合中所有数据内容是否不相等。">
                     <Parameters>
                        <Parameter type="MNcDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator!=(const MNcDictionaryC&lt;T&gt;&amp; dictionary) const{\n		return !Equals(&amp;dictionary);\n	}</Source>
                  </Method>
                  <Method name="operator[]" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nconst T operator[](TCharC* pName) const{\n      MO_ASSERT(pName);\n      SEntry* pEntry = EntryFind(pName);\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="operator[]" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nconst T operator[](const MStringPtrC&amp; name) const{\n      SEntry* pEntry = EntryFind(name.MemoryC());\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="EntryFind" type="inline" description="查找指定名称的索引位置。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryFind(TCharC* pName) const{\n      // 数据存在时\n      if(this-&gt;_count &gt; 0){\n         THashCode hash = RString::MakeNocaseHashCode(pName);\n         // 查找名称的索引位置\n         SEntry* pEntry = _ppEntries[hash % _entryCount];\n         while(NULL != pEntry){\n            if(pEntry-&gt;hash == hash){\n               if(pEntry-&gt;IsNameIgnoreCase(pName)){\n                  return pEntry;\n               }\n            }\n            pEntry = pEntry-&gt;pLink;\n         }\n      }\n      // 未找到时返回结果\n      return NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryFindValue" type="inline" description="查找指定名称的索引位置。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryFindValue(T value) const{\n      // 数据存在时\n      if(this-&gt;_count &gt; 0){\n         SEntry* pEntry = this-&gt;_pFirst;\n         while(NULL != pEntry){\n            if(pEntry-&gt;value == value){\n               return pEntry;\n            }\n            pEntry = pEntry-&gt;pNext;\n         }\n      }\n      // 未找到时返回结果\n      return NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryClear" type="inline">
                     <Return type="void"/>
                     <Source>\ninline void EntryClear(){\n      // 清除表格\n      for(TInt n=0; n&lt;_entryCount; n++){\n         _ppEntries[n] = NULL;\n      }\n      // 清除链表\n      MEntriesC&lt;SEntry&gt;::EntryClear();\n   }</Source>
                  </Method>
                  <Method name="IsEmpty" description="当前哈希集合对象是否为空。">
                     <Return type="TBool"/>
                     <Source>\nTBool IsEmpty() const{\n      return (0 == this-&gt;_count);\n   }</Source>
                  </Method>
                  <Method name="Count" description="获得数据个数。">
                     <Return type="TInt"/>
                     <Source>\nTInt Count() const{\n      return this-&gt;_count;\n   }</Source>
                  </Method>
                  <Method name="Contains" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Contains(TCharC* pName) const{\n      MO_ASSERT(pName);\n      return (NULL != EntryFind(pName));\n   }</Source>
                  </Method>
                  <Method name="Contains" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Contains(const MStringPtrC&amp; name) const{\n      return (NULL != EntryFind(name.MemoryC()));\n   }</Source>
                  </Method>
                  <Method name="ContainsValue" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool ContainsValue(T value) const{\n      return (NULL != EntryFindValue(value));\n   }</Source>
                  </Method>
                  <Method name="Equals" description="判断当前哈希集合和指定哈希集合内容是否相等。">
                     <Parameters>
                        <Parameter type="MNcDictionaryC&lt;T&gt;*" name="pDictionary"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Equals(const MNcDictionaryC&lt;T&gt;* pDictionary) const{\n      MO_ASSERT(pDictionary);\n      // 比较数量\n      if(this-&gt;_count != pDictionary-&gt;_count){\n         return EFalse;\n      }\n      // 比较所有项目\n      TIteratorC iterator = pDictionary-&gt;IteratorC();\n      while(iterator.Next()){\n         SEntry* pEntry = this-&gt;EntryFind(iterator.Name());\n         if(NULL == pEntry){\n            return EFalse;\n         }\n         if(!iterator.IsValue(pEntry-&gt;value)){\n            return EFalse;\n         }\n      }\n      return ETrue;\n	}</Source>
                  </Method>
                  <Method name="IteratorC" description="获得只读迭代器。">
                     <Return type="TDictionaryIteratorC&lt;T&gt;"/>
                     <Source>\nconst TDictionaryIteratorC&lt;T&gt; IteratorC() const{\n      return TDictionaryIteratorC&lt;T&gt;(this-&gt;_pFirst);\n   }</Source>
                  </Method>
                  <Method name="LastIteratorC" description="获得只读迭代器。">
                     <Return type="TDictionaryIteratorC&lt;T&gt;"/>
                     <Source>\nconst TDictionaryIteratorC&lt;T&gt; LastIteratorC() const{\n      return TDictionaryIteratorC&lt;T&gt;(this-&gt;_pLast);\n   }</Source>
                  </Method>
                  <Method name="Get" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Get(TCharC* pName) const{\n      MO_ASSERT(pName);\n      SEntry* pEntry = EntryFind(pName);\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="Get" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Get(const MStringPtrC&amp; name) const{\n      SEntry* pEntry = EntryFind(name.MemoryC());\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="Find" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Find(TCharC* pName) const{\n      if(NULL != pName){\n         SEntry* pEntry = EntryFind(pName);\n         if(NULL != pEntry){\n            return pEntry-&gt;value;\n         }\n      }\n      return NULL;\n   }</Source>
                  </Method>
                  <Method name="Find" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="name"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Find(const MStringPtrC&amp; name) const{\n      SEntry* pEntry = EntryFind(name);\n      return (NULL != pEntry) ? pEntry-&gt;value : NULL;\n   }</Source>
                  </Method>
                  <Method name="Search" description="获得指定名称的数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>\nTCharC* Search(T value) const{\n      SEntry* pEntry = EntryFindValue(value);\n      return (NULL != pEntry) ? pEntry-&gt;pName-&gt;MemoryC() : NULL;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_entryCount"/>
                  <Attribute type="SEntry**" name="_ppEntries"/>
               </Attributes>
            </Class>
            <Class name="MNetSocket">
               <Methods>
                  <Constructor name="MNetSocket" description="初始化网路端口。"/>
                  <Destructor name="~MNetSocket" description="析构网路端口。"/>
                  <Method name="SetLinger" description="设置数据允许逗留数据。">
                     <Parameters>
                        <Parameter type="TBool" name="flag" description="允许逗留"/>
                        <Parameter type="TInt" name="timeout"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;设置数据允许逗留数据。&lt;/T&gt;\n//\n// @param flag 允许逗留\n// @param time 逗留时间\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool MNetSocket::SetLinger(TBool flag, TInt timeout){\n   struct linger value;\n   value.l_onoff = flag;\n   value.l_linger = timeout;\n   TSocket handle = Handle();\n   if(EError == setsockopt(handle, SOL_SOCKET, SO_LINGER, (PChar8)&amp;value, sizeof(struct linger))){\n      MO_PERROR(setsockopt);\n      return EFalse;\n   }\n   MO_NET_DEBUG(&quot;Set linger. (handle=%d, flag=%d, timeout=%d)&quot;, handle, flag, timeout);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Info" flag="virtual">
                     <Return type="SNetSocketInfo*"/>
                  </Method>
                  <Method name="Connection" flag="override" description="获得网路链接。">
                     <Return type="INetConnection*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得网路链接。&lt;/T&gt;\n//\n// @return 网路链接\n//============================================================\n\nINetConnection* MNetSocket::Connection(){\n   return _pConnection;\n}</Source>
                  </Method>
                  <Method name="Handle" flag="override" description="获得网路端口句柄。">
                     <Return type="TSocket"/>
                     <Source>//============================================================\n// &lt;T&gt;获得网路端口句柄。&lt;/T&gt;\n//\n// @return 端口句柄\n//============================================================\n\nTSocket MNetSocket::Handle(){\n   return Info()-&gt;handle;\n}</Source>
                  </Method>
                  <Method name="Host" flag="override" description="获得网路主机名称。">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n// &lt;T&gt;获得网路主机名称。&lt;/T&gt;\n//\n// @return 主机名称\n//============================================================\n\nTCharC* MNetSocket::Host(){\n   return _host.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Port" flag="override" description="获得链接端口。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;获得链接端口。&lt;/T&gt;\n//\n// @return 链接端口\n//============================================================\n\nTInt MNetSocket::Port(){\n   return Info()-&gt;port;\n}</Source>
                  </Method>
                  <Method name="IsConnected" flag="override">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool MNetSocket::IsConnected(){\n   return _isConnected;\n}</Source>
                  </Method>
                  <Method name="SetReuseAddress" flag="override" description="设置允许重用句柄。">
                     <Parameters>
                        <Parameter type="TBool" name="flag"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;设置允许重用句柄。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool MNetSocket::SetReuseAddress(TBool flag){\n   TSocket handle = Handle();\n   TUint32 value = flag;\n   if(EError == setsockopt(handle, SOL_SOCKET, SO_REUSEADDR, (PChar8)&amp;value, sizeof(TUint32))){\n      MO_PERROR(setsockopt);\n      return EFalse;\n   }\n   MO_NET_DEBUG(&quot;Set reuse address. (handle=%d, flag=%d)&quot;, handle, flag);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="SetDontLinger" flag="override" description="设置立刻结束。">
                     <Parameters>
                        <Parameter type="TBool" name="flag"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;设置立刻结束。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool MNetSocket::SetDontLinger(TBool flag){\n   struct linger value;\n   value.l_onoff = EFalse;\n   value.l_linger = 0;\n   TSocket handle = Handle();\n   if(EError == setsockopt(handle, SOL_SOCKET, SO_LINGER, (PChar8)&amp;value, sizeof(struct linger))){\n      MO_PERROR(setsockopt);\n      return EFalse;\n   }\n   MO_NET_DEBUG(&quot;Set don't linger. (handle=%d, flag=%d)&quot;, handle, flag);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="SetLinger" flag="override">
                     <Parameters>
                        <Parameter type="TInt" name="timeout" default="0"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="SetSendTimeout" flag="override" description="设置发送超时。">
                     <Parameters>
                        <Parameter type="TInt" name="timeout"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;设置发送超时。&lt;/T&gt;\n//\n// @param timeout 超时(微秒数：1/1000000秒)\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool MNetSocket::SetSendTimeout(TInt timeout){\n   struct timeval value;\n   value.tv_sec = timeout / 1000000;\n   value.tv_usec = timeout % 1000000;\n   TSocket handle = Handle();\n   if(EError == setsockopt(handle, SOL_SOCKET, SO_SNDTIMEO, (PChar8)&amp;value, sizeof(struct timeval))){\n      MO_PERROR(setsockopt);\n      return EFalse;\n   }\n   MO_NET_DEBUG(&quot;Set send timeout. (handle=%d, timeout=%d)&quot;, handle, timeout);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="SetReceiveTimeout" flag="override" description="设置接收超时。">
                     <Parameters>
                        <Parameter type="TInt" name="timeout"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;设置接收超时。&lt;/T&gt;\n//\n// @param timeout 超时(1/1000秒)\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool MNetSocket::SetReceiveTimeout(TInt timeout){\n   struct timeval value;\n   value.tv_sec = timeout / 1000000;\n   value.tv_usec = timeout % 1000000;\n   TSocket handle = Handle();\n   if(EError == setsockopt(handle, SOL_SOCKET, SO_RCVTIMEO, (PChar8)&amp;value, sizeof(struct timeval))){\n      MO_PERROR(setsockopt);\n      return EFalse;\n   }\n   MO_NET_DEBUG(&quot;Set receive timeout. (handle=%d, timeout=%d)&quot;, handle, timeout);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="SetSendBufferSize" flag="override" description="设置发送缓冲区大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;设置发送缓冲区大小。&lt;/T&gt;\n//\n// @param size 缓冲区大小\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool MNetSocket::SetSendBufferSize(TInt size){\n   TUint32 value = size;\n   TSocket handle = Handle();\n   if(EError == setsockopt(handle, SOL_SOCKET, SO_SNDBUF, (PChar8)&amp;value, sizeof(TUint32))){\n      MO_PERROR(setsockopt);\n      return EFalse;\n   }\n   MO_NET_DEBUG(&quot;Set send buffer size. (handle=%d, size=%d)&quot;, handle, size);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="SetReceiveBufferSize" flag="override" description="设置接收缓冲区大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;设置接收缓冲区大小。&lt;/T&gt;\n//\n// @param size 缓冲区大小\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool MNetSocket::SetReceiveBufferSize(TInt size){\n   TUint32 value = size;\n   TSocket handle = Handle();\n   if(EError == setsockopt(handle, SOL_SOCKET, SO_RCVBUF, (PChar8)&amp;value, sizeof(TUint32))){\n      MO_PERROR(setsockopt);\n      return EFalse;\n   }\n   MO_NET_DEBUG(&quot;Set receive buffer size. (handle=%d, size=%d)&quot;, handle, size);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="SetNonBlock" flag="override" description="设置非堵塞方式。">
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;设置非堵塞方式。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool MNetSocket::SetNonBlock(){\n   TSocket handle = Handle();\n#ifdef _WINDOWS\n   TUint32 argp = 1;\n   ioctlsocket(handle, FIONBIO, &amp;argp);\n#else\n   fcntl(handle, F_SETFL, O_NONBLOCK);\n#endif\n   MO_NET_DEBUG(&quot;Set none block. (handle=%d)&quot;, handle);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Receive" flag="override" description="接收数据。">
                     <Parameters>
                        <Parameter type="TByte*" name="pBuffer"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;接收数据。&lt;/T&gt;\n//\n// @param pBuffer 数据指针\n// @param length 数据长度\n// @return 接收长度\n//============================================================\n\nTInt MNetSocket::Receive(TByte* pBuffer, TInt length){\n   TSocket handle = Handle();\n   TInt result = recv(handle, pBuffer, length, 0);\n   if(EError == result){\n      if(0 != errno){\n         MO_PERROR(recv);\n      }\n   }\n   return result;\n}</Source>
                  </Method>
                  <Method name="Send" flag="override" description="发送数据。">
                     <Parameters>
                        <Parameter type="TByteC*" name="pBuffer"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;发送数据。&lt;/T&gt;\n//\n// @param pBuffer 数据指针\n// @param length 数据长度\n// @return 发送长度\n//============================================================\n\nTInt MNetSocket::Send(TByteC* pBuffer, TInt length){\n   TSocket handle = Handle();\n   TInt result = send(handle, pBuffer, length, 0);\n   if(EError == result){\n      MO_PERROR(send);\n   }\n   return result;\n}</Source>
                  </Method>
                  <Method name="Close" flag="override" description="关闭链接。">
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;成功"/>
                        <L value="value='EFalse'&gt;失败"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;关闭链接。&lt;/T&gt;\n//\n// @return\n//    &lt;L value='ETrue'&gt;成功&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;失败&lt;/L&gt;\n//============================================================\n\nTBool MNetSocket::Close(){\n   _isConnected = EFalse;\n   TSocket handle = Handle();\n   if(INVALID_SOCKET == handle){\n#ifdef _WINDOWS\n      closesocket(handle);\n#else\n      close(handle);\n#endif\n      handle = INVALID_SOCKET;\n      return ETrue;\n   }\n   return EFalse;\n}</Source>
                  </Method>
                  <Method name="SetConnection" description="设置链接。">
                     <Parameters>
                        <Parameter type="INetConnection*" name="pConnection"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置链接。&lt;/T&gt;\n//\n// @param pConnection 链接\n//============================================================\n\nvoid MNetSocket::SetConnection(INetConnection* pConnection){\n   _pConnection = pConnection;\n}</Source>
                  </Method>
                  <Method name="SetHandle" description="设置句柄。">
                     <Parameters>
                        <Parameter type="TSocket" name="handle"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置句柄。&lt;/T&gt;\n//\n// @param handle 句柄\n//============================================================\n\nvoid MNetSocket::SetHandle(TSocket handle){\n   Info()-&gt;handle = handle;\n   _isConnected = ETrue;\n}</Source>
                  </Method>
                  <Method name="SetHost" description="设置主机名称。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pHost"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置主机名称。&lt;/T&gt;\n//\n// @param host 主机名称\n//============================================================\n\nvoid MNetSocket::SetHost(TCharC* pHost){\n   _host.Assign(pHost);\n}</Source>
                  </Method>
                  <Method name="SetPort" description="设置端口。">
                     <Parameters>
                        <Parameter type="TUint16" name="port"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置端口。&lt;/T&gt;\n//\n// @param port 端口\n//============================================================\n\nvoid MNetSocket::SetPort(TUint16 port){\n   Info()-&gt;port = port;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="INetConnection*" name="_pConnection"/>
                  <Attribute type="TFsNetHost" name="_host"/>
                  <Attribute type="TBool" name="_isConnected"/>
               </Attributes>
            </Class>
            <Class name="MObject">
               <Methods>
                  <Method name="new">
                     <Parameters>
                        <Parameter type="TUint" name="size"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>//============================================================\n\nTAny* MObject::operator new(TUint size){\n   return RAllocator::TypeAlloc(size);\n}</Source>
                  </Method>
                  <Method name="new">
                     <Parameters>
                        <Parameter type="TUint" name="size"/>
                        <Parameter type="TCharC*" name="pClassName"/>
                        <Parameter type="TCharC*" name="pFileName"/>
                        <Parameter type="TInt" name="line"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>//============================================================\n\nTAny* MObject::operator new(TUint size, TCharC* pClassName, TCharC* pFileName, TInt line){\n   return RAllocator::TypeAlloc(pClassName, size, pFileName, line);\n}</Source>
                  </Method>
                  <Method name="delete">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>//============================================================\n\nvoid MObject::operator delete(TAny* pMemory){\n   RAllocator::Free(pMemory);\n}</Source>
                  </Method>
                  <Method name="delete">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                        <Parameter type="TCharC*" name="pClassName"/>
                        <Parameter type="TCharC*" name="pFileName"/>
                        <Parameter type="TInt" name="line"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>//============================================================\n\nvoid MObject::operator delete(TAny* pMemory, TCharC* pClassName, TCharC* pFileName, TInt line){\n   RAllocator::Free(pMemory);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MObjects">
               <Methods>
                  <Constructor name="MObjects"/>
                  <Method name="T*">
                     <Return type="operator"/>
                     <Source>\noperator T*() const{\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="Memory">
                     <Return type="T*"/>
                     <Source>\nT* Memory() const{\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="EnsureSize">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if(NULL == this-&gt;_pMemory){\n         // 当第一次使用的时候，收集不小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n         this-&gt;_count = 0;\n         this-&gt;_total = MO_MAX(size, MO_MEMORY_CAPACITY);\n         this-&gt;_pMemory = RTypeMemory&lt;T&gt;::Alloc(_total, 0);\n      }else if(size &gt; _total){\n         // 当内存不足时，扩大1.5倍内存，但收集量不得小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n         TInt total = MO_MAX(this-&gt;_total, size);\n         this-&gt;_total = total + (total &gt;&gt; 1);\n         T* pMemory = RTypeMemory&lt;T&gt;::Alloc(_total);\n         if(this-&gt;_count &gt; 0){\n            RTypes&lt;T&gt;::Copy(this-&gt;_pMemory, pMemory, this-&gt;_count);\n         }\n         RTypeMemory&lt;T&gt;::Free(this-&gt;_pMemory);\n         this-&gt;_pMemory = pMemory;\n      }\n   }</Source>
                  </Method>
                  <Method name="Assign">
                     <Parameters>
                        <Parameter type="MObjectsC&lt;T&gt;&amp;" name="source"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(MObjectsC&lt;T&gt;&amp; source){\n      EnsureSize(source.Count());\n      this-&gt;_count = source.Count();\n      RTypeMemory&lt;T&gt;::Copy(source.MemoryC(), this-&gt;_pMemory, this-&gt;_count);\n   }</Source>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="T*" name="pSource"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const T* pSource, TInt count){\n      EnsureSize(this-&gt;_count + count);\n      RTypeMemory&lt;T&gt;::Copy(pSource, this-&gt;_pMemory + this-&gt;_count, count);\n      this-&gt;_count += count;\n   }</Source>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="MObjectsC&lt;T&gt;&amp;" name="source"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(MObjectsC&lt;T&gt;&amp; source){\n      Append(source.MemoryC(), source.Count());\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(TInt index, T value){\n      if(index &gt;= 0 &amp;&amp; index &lt; this-&gt;_count){\n         this-&gt;_pMemory[index] = value;\n      }\n   }</Source>
                  </Method>
                  <Method name="SetCount" description="设置数据长度。">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid SetCount(TInt count){\n      EnsureSize(count);\n      if(count &gt; this-&gt;_count){\n         for(TInt n=this-&gt;_count; n&lt;count; n++){\n            this-&gt;_pMemory[n] = RType&lt;T&gt;::Default();\n         }\n      }\n      this-&gt;_count = count;\n   }</Source>
                  </Method>
                  <Method name="Ptr">
                     <Return type="TPtr&lt;T&gt;"/>
                     <Source>\nTPtr&lt;T&gt; Ptr() const{\n      return TPtr&lt;T&gt;(this-&gt;_pMemory, this-&gt;_count);\n   }</Source>
                  </Method>
                  <Method name="Insert" description="插入一个数据在指定位置。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Insert(TInt index, T value){\n      MO_ASSERT_RANGE(index, 0, this-&gt;_count + 1);\n	   EnsureSize(this-&gt;_count + 1);\n      RTypeMemory&lt;T&gt;::Copy(this-&gt;_pMemory + index, this-&gt;_pMemory + index + 1, this-&gt;_count - index);\n      this-&gt;_pMemory[index] = value;\n	   this-&gt;_count++;\n   }</Source>
                  </Method>
                  <Method name="Insert" description="插入一个数据指针在指定位置。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="T*" name="pSource"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Insert(TInt index, const T* pSource, TInt length){\n	   MO_ASSERT_RANGE(index, 0, this-&gt;_count + 1);\n      EnsureSize(this-&gt;_count + length);\n      RTypeMemory&lt;T&gt;::Copy(this-&gt;_pMemory + index, this-&gt;_pMemory + index + length, this-&gt;_count - index);\n      RTypeMemory&lt;T&gt;::Copy(pSource, this-&gt;_pMemory + index, length);\n      this-&gt;_count += length;\n   }</Source>
                  </Method>
                  <Method name="Insert" description="插入一个数组在指定位置。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="MArrayC&lt;T&gt;&amp;" name="source"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Insert(TInt index, MArrayC&lt;T&gt;&amp; source){\n	   MO_ASSERT_RANGE(index, 0, this-&gt;_count + 1);\n      TInt length = source.Length();\n      EnsureSize(this-&gt;_count + length);\n      RTypeMemory&lt;T&gt;::Copy(this-&gt;_pMemory + index, this-&gt;_pMemory + index + length, this-&gt;_count - index);\n      RTypeMemory&lt;T&gt;::Copy(source.MemoryC(), this-&gt;_pMemory + index, length);\n      this-&gt;_count += length;\n   }</Source>
                  </Method>
                  <Method name="Push">
                     <Parameters>
                        <Parameter type="T" name="source"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Push(T source){\n      EnsureSize(this-&gt;_count + 1);\n      this-&gt;_pMemory[this-&gt;_count++] = source;\n   }</Source>
                  </Method>
                  <Method name="Swap">
                     <Parameters>
                        <Parameter type="TInt" name="from"/>
                        <Parameter type="TInt" name="to"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Swap(TInt from, TInt to){\n      if((from &gt;= 0) &amp;&amp; (from &lt; this-&gt;_count) &amp;&amp; (to &gt;= 0) &amp;&amp; (to &lt; this-&gt;_count) &amp;&amp; (from != to)){\n         T value = this-&gt;_pMemory[from];\n   	   this-&gt;_pMemory[from] = this-&gt;_pMemory[to];\n         this-&gt;_pMemory[to] = value;\n      }\n   }</Source>
                  </Method>
                  <Method name="Delete" description="移除指定数据。" note="可能会移除多个相同的数据。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Delete(TInt index){\n      MO_ASSERT_RANGE(index, 0, this-&gt;_count);\n      if(index != this-&gt;_count - 1){\n         RTypeMemory&lt;T&gt;::Copy(this-&gt;_pMemory + index + 1, this-&gt;_pMemory + index, this-&gt;_count - index);\n      }\n      this-&gt;_count--;\n   }</Source>
                  </Method>
                  <Method name="Delete" description="删除指定位置起的长度的数据" note="如果长度超过，则删除指定位置到结束位置之间的数据">
                     <Parameters>
                        <Parameter type="TInt" name="offset"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Delete(TInt offset, TInt length){\n      MO_ASSERT_RANGE(offset, 0, this-&gt;_count);\n      MO_ASSERT_RANGE(length, 0, this-&gt;_count - offset);\n      TInt count = this-&gt;_count - offset - length;\n      if(count &gt; 0){\n         RTypeMemory&lt;T&gt;::Copy(this-&gt;_pMemory + offset + length, this-&gt;_pMemory + offset, MO_MIN(count, length));\n      }\n      this-&gt;_count -= length;\n   }</Source>
                  </Method>
                  <Method name="Remove" description="移除指定数据。" note="可能会移除多个相同的数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Remove(T value){\n      TInt position = 0;\n      for(TInt n=0; n&lt;this-&gt;_count; n++){\n         if(this-&gt;_pMemory[n] != value){\n            this-&gt;_pMemory[position++] = this-&gt;_pMemory[n];\n         }\n      }\n      this-&gt;_count = position;\n   }</Source>
                  </Method>
                  <Method name="Compress" description="移除空数据。" note="可能会移除多个相同的数据。">
                     <Return type="void"/>
                     <Source>\nvoid Compress(){\n      TInt count = 0;\n      for(TInt n = 0; n&lt;this-&gt;_count; n++){\n         if(NULL != this-&gt;_pMemory[n]){\n            this-&gt;_pMemory[count++] = this-&gt;_pMemory[n];\n         }\n      }\n      if(count &gt; 0){\n         T* pMemory = RTypeMemory&lt;T&gt;::Alloc(count);\n         RTypeMemory&lt;T&gt;::Copy(this-&gt;_pMemory, pMemory, count);\n         RTypeMemory&lt;T&gt;::Free(this-&gt;_pMemory);\n         this-&gt;_pMemory = pMemory;\n      }else{\n         RTypeMemory&lt;T&gt;::Free(this-&gt;_pMemory);\n         this-&gt;_pMemory = NULL;\n      }\n      this-&gt;_count = count;\n      this-&gt;_total = count;\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清除所有数据。" note="注意本操作对数据不做任何处理，如果存储指针，一定要先自己释放。只是将长度置为空，可以重新放数据。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;_count = 0;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_total"/>
               </Attributes>
            </Class>
            <Class name="MObjectsC">
               <Methods>
                  <Constructor name="MObjectsC"/>
                  <Method name="operator[]">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nconst T operator[](TInt index) const{\n      return (index &gt;= 0 &amp;&amp; index &lt; _count) ? _pMemory[index] : RType&lt;T&gt;::Default();\n   }</Source>
                  </Method>
                  <Method name="IsEmpty">
                     <Return type="TBool"/>
                     <Source>\nTBool IsEmpty() const{\n	   return (0 == _count);\n   }</Source>
                  </Method>
                  <Method name="MemoryC">
                     <Return type="T*"/>
                     <Source>\nconst T* MemoryC() const{\n      return _pMemory;\n   }</Source>
                  </Method>
                  <Method name="Count">
                     <Return type="TInt"/>
                     <Source>\nTInt Count() const{\n	   return _count;\n   }</Source>
                  </Method>
                  <Method name="Contains">
                     <Parameters>
                        <Parameter type="T&amp;" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Contains(const T&amp; value) const{\n      return RTypes&lt;T&gt;::Contains(_pMemory, _count, value);\n   }</Source>
                  </Method>
                  <Method name="IndexOf">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt IndexOf(T value) const{\n      return RTypes&lt;T&gt;::IndexOf(_pMemory, _count, value);\n   }</Source>
                  </Method>
                  <Method name="IndexOf">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                        <Parameter type="TInt" name="offset"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt IndexOf(T value, TInt offset) const{\n      return (offset &lt; _count) ? RTypes&lt;T&gt;::IndexOf(_pMemory + offset, _count - offset, value) : ENotFound;\n   }</Source>
                  </Method>
                  <Method name="LastIndexOf">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt LastIndexOf(T value) const{\n      return RTypes&lt;T&gt;::LastIndexOf(_pMemory, _count, value);\n   }</Source>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Get(TInt index) const{\n      return (index &gt;= 0 &amp;&amp; index &lt; _count) ? _pMemory[index] : RType&lt;T&gt;::Default();\n   }</Source>
                  </Method>
                  <Method name="PtrC">
                     <Return type="MPtrC&lt;T&gt;"/>
                     <Source>\nMPtrC&lt;T&gt; PtrC() const{\n      return TPtr&lt;T&gt;(_pMemory, _count);\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T*" name="_pMemory"/>
                  <Attribute type="TInt" name="_count"/>
               </Attributes>
            </Class>
            <Class name="MPipe">
               <Inherits>
                  <Inherit name="IPipe" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Info" flag="virtual">
                     <Return type="SPipeInfo*"/>
                  </Method>
                  <Method name="InnerGetInfo" flag="virtual">
                     <Parameters>
                        <Parameter type="TByte**" name="ppMemory"/>
                        <Parameter type="TUint32&amp;" name="capacity"/>
                        <Parameter type="TUint32&amp;" name="length"/>
                        <Parameter type="TUint32&amp;" name="first"/>
                        <Parameter type="TUint32&amp;" name="last"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="IsEmpty" flag="override" description="判断管道是否为空。">
                     <Return type="TBool" description="是否为空"/>
                     <Source>//============================================================\n// &lt;T&gt;判断管道是否为空。&lt;/T&gt;\n//\n// @return 是否为空\n//============================================================\n\nTBool MPipe::IsEmpty(){\n   TByte* pMemory;\n   TUint32 capacity, length, first, last;\n   InnerGetInfo(&amp;pMemory, capacity, length, first, last);\n   return length &gt; 0;\n}</Source>
                  </Method>
                  <Method name="Length" flag="override" description="获得管道以被占用长度。">
                     <Return type="TInt" description="被占用长度。"/>
                     <Source>//============================================================\n// &lt;T&gt;获得管道以被占用长度。&lt;/T&gt;\n//\n// @return 被占用长度。\n//============================================================\n\nTInt MPipe::Length(){\n   TByte* pMemory;\n   TUint32 capacity, length, first, last;\n   InnerGetInfo(&amp;pMemory, capacity, length, first, last);\n   return length;\n}</Source>
                  </Method>
                  <Method name="Reamin" flag="override" description="获得管道以剩余的长度。">
                     <Return type="TInt" description="剩余的长度"/>
                     <Source>//============================================================\n// &lt;T&gt;获得管道以剩余的长度。&lt;/T&gt;\n//\n// @return 剩余的长度\n//============================================================\n\nTInt MPipe::Reamin(){\n   TByte* pMemory;\n   TUint32 capacity, length, first, last;\n   InnerGetInfo(&amp;pMemory, capacity, length, first, last);\n   return capacity - length - MO_PIPE_RESERVE_LENGTH;\n}</Source>
                  </Method>
                  <Method name="Peek" flag="override" description="从管道读取数据，但不影响管道内容。">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt" description="实际读取数据长度。"/>
                     <Source>//============================================================\n// &lt;T&gt;从管道读取数据，但不影响管道内容。&lt;/T&gt;\n//\n// @return 实际读取数据长度。\n//============================================================\n\nTInt MPipe::Peek(TAny* pData, TSize size){\n   // 检查参数\n   MO_ASSERT(pData);\n   if(0 == size){\n      return 0;\n   }\n   // 获取变量\n   TByte* pMemory;\n   TUint32 capacity, length, first, last;\n   InnerGetInfo(&amp;pMemory, capacity, length, first, last);\n   // 处理一次读出数据 [---F===L----] | [===L---F====]\n   TUint32 readed = MO_MIN(size, length);\n   TUint32 copied = (first &lt; last) ? readed : MO_MIN(readed, capacity - first);\n   memcpy(pData, pMemory + first, copied);\n   // 处理二次读出数据\n   if(readed &gt; copied){\n      memcpy(pMemory, (TByte*)pData + copied, readed - copied);\n   }\n   // 存储变量\n   return readed;\n}</Source>
                  </Method>
                  <Method name="Write" flag="override" description="往管道写入指定长度数据。">
                     <Parameters>
                        <Parameter type="TAnyC*" name="pData"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TInt" description="实际写入数据长度。"/>
                     <Source>//============================================================\n// &lt;T&gt;往管道写入指定长度数据。&lt;/T&gt;\n//\n// @return 实际写入数据长度。\n//============================================================\n\nTInt MPipe::Write(TAnyC* pData, TSize capacity){\n   // 检查参数\n   MO_ASSERT(pData);\n   if(0 == capacity){\n      return 0;\n   }\n   // 获取变量\n   TByte* pMemory;\n   TUint32 total, length, first, last;\n   InnerGetInfo(&amp;pMemory, total, length, first, last);\n   // 处理一次写入数据 [---F===L----] | [===L---F====]\n   TUint32 writed = MO_MIN(capacity, total - length - MO_PIPE_RESERVE_LENGTH);\n   TUint32 copied = (first &lt; last) ? MO_MIN(writed, total - last) : writed;\n   memcpy(pMemory + last, pData, copied);\n   last += copied;\n   // 处理二次写入数据 [===L---F====]\n   if(writed &gt; copied){\n      memcpy(pMemory, (TByte*)pData + copied, writed - copied);\n      last = writed - copied;\n   }\n   // 存储变量\n   Info()-&gt;last = last;\n   return writed;\n}</Source>
                  </Method>
                  <Method name="Read" flag="override" description="从管道取走指定长度数据。">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt" description="实际取走数据长度。"/>
                     <Source>//============================================================\n// &lt;T&gt;从管道取走指定长度数据。&lt;/T&gt;\n//\n// @return 实际取走数据长度。\n//============================================================\n\nTInt MPipe::Read(TAny* pData, TSize size){\n   // 检查参数\n   MO_ASSERT(pData);\n   if(0 == size){\n      return 0;\n   }\n   // 获取变量\n   TByte* pMemory;\n   TUint32 capacity, length, first, last;\n   InnerGetInfo(&amp;pMemory, capacity, length, first, last);\n   // 处理一次读出数据 [---F===L----] | [===L---F====]\n   TUint32 readed = MO_MIN(size, length);\n   TUint32 copied = (first &lt; last) ? readed : MO_MIN(readed, capacity - first);\n   memcpy(pData, pMemory + first, copied);\n   first += copied;\n   // 处理二次读出数据 [===L---F====]\n   if(readed &gt; copied){\n      memcpy(pMemory, (TByte*)pData + copied, readed - copied);\n      first = readed - copied;\n   }\n   // 存储变量\n   Info()-&gt;first = first;\n   return readed;\n}</Source>
                  </Method>
                  <Method name="TryWrite" flag="override">
                     <Parameters>
                        <Parameter type="TAnyC*" name="pData"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool MPipe::TryWrite(TAnyC* pData, TSize capacity){\n   // 检查参数\n   MO_ASSERT(pData);\n   if(0 == capacity){\n      return ETrue;\n   }\n   // 获取变量\n   TByte* pMemory;\n   TUint32 total, length, first, last;\n   InnerGetInfo(&amp;pMemory, total, length, first, last);\n   // 判断是否可以写入\n   if(capacity &gt; (total - length - MO_PIPE_RESERVE_LENGTH)){\n      return EFalse;\n   }\n   // 处理一次写入数据 [---F===L----] | [===L---F====]\n   TUint32 moved = (first &lt; last) ? MO_MIN(capacity, total - last) : capacity;\n   memcpy(pMemory + last, pData, moved);\n   last += moved;\n   // 处理二次写入数据\n   if(capacity &gt; moved){\n      last = capacity - moved;\n      memcpy(pMemory, (TByte*)pData + moved, last);\n   }\n   // 存储变量\n   Info()-&gt;last = last;\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="TryRead" flag="override" description="判断是否又足够的数据读出。">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="capacity"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;判断是否又足够的数据读出。&lt;/T&gt;\n//============================================================\n\nTInt MPipe::TryRead(TAny* pData, TSize capacity){\n   // 检查参数\n   MO_ASSERT(pData);\n   if(0 == capacity){\n      return 0;\n   }\n   // 获取变量\n   TByte* pMemory;\n   TUint32 total, length, first, last;\n   InnerGetInfo(&amp;pMemory, total, length, first, last);\n   // 判断是否可以读出\n   if(length &lt; sizeof(TUint32)){\n      return 0;\n   }\n   TUint32 size = *(TUint32*)(pMemory + first);\n   if((size &gt; capacity) || (size &gt; length)){\n      return 0;\n   }\n   // 处理一次读出数据 [---F===L----] | [===L---F====]\n   TUint32 moved = (first &lt; last) ? size : MO_MIN(size, total - first);\n   memcpy(pData, pMemory + first, moved);\n   // 处理二次读出数据\n   if(size &gt; moved){\n      memcpy((TByte*)pData + moved, pMemory, size - moved);\n      first = size - moved;\n   }else{\n      first += moved;\n   }\n   // 存储变量\n   Info()-&gt;first = first;\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Close" flag="override" description="关闭管道。">
                     <Return type="TBool" description="处理结果"/>
                     <Source>//============================================================\n// &lt;T&gt;关闭管道。&lt;/T&gt;\n//\n// @return 处理结果\n//============================================================\n\nTBool MPipe::Close(){\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MProperties16">
               <Inherits>
                  <Inherit name="MProperties16C" scope="public"/>
               </Inherits>
            </Class>
            <Class name="MProperties16C">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
            </Class>
            <Class name="MProperties32">
               <Inherits>
                  <Inherit name="MProperties32C" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="EnsureSize">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Assign">
                     <Parameters>
                        <Parameter type="MProperties32C&amp;" name="properties"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="MProperties32C&amp;" name="properties"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="AppendSplit">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                        <Parameter type="TChar32" name="nameSpliter"/>
                        <Parameter type="TChar32" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="AppendSplit">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                        <Parameter type="TChar32C*" name="pNameSpliter"/>
                        <Parameter type="TChar32C*" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Add">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pName"/>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pName"/>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Split">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                        <Parameter type="TChar32" name="nameSpliter"/>
                        <Parameter type="TChar32" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Split">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                        <Parameter type="TChar32C*" name="pNameSpliter"/>
                        <Parameter type="TChar32C*" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Unpack">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pPack"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pName"/>
                     </Parameters>
                     <Return type="TString32"/>
                  </Method>
                  <Method name="Clear">
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="MProperties32C">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="MProperties32C"/>
                  <Destructor name="~MProperties32C"/>
                  <Method name="operator[]">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pName"/>
                     </Parameters>
                     <Return type="TChar32C*"/>
                  </Method>
                  <Method name="IsEmpty">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Count">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Contains">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="ContainsValue">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pName"/>
                     </Parameters>
                     <Return type="TChar32C*"/>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pName"/>
                     </Parameters>
                     <Return type="TChar32C*"/>
                  </Method>
                  <Method name="FindNvl">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pName"/>
                        <Parameter type="TChar32C*" name="pDefault"/>
                     </Parameters>
                     <Return type="TChar32C*"/>
                  </Method>
                  <Method name="Search">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="TChar32C*"/>
                  </Method>
                  <Method name="Join">
                     <Parameters>
                        <Parameter type="FString32*" name="pValue"/>
                        <Parameter type="TChar32" name="nameSpliter"/>
                        <Parameter type="TChar32" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Join">
                     <Parameters>
                        <Parameter type="FString32*" name="pValue"/>
                        <Parameter type="TChar32C*" name="pNameSpliter"/>
                        <Parameter type="TChar32C*" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Pack">
                     <Return type="TChar32C*"/>
                  </Method>
                  <Method name="Dump">
                     <Return type="TString32"/>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="FString32s*" name="_pNames"/>
                  <Attribute type="FString32s*" name="_pValues"/>
               </Attributes>
            </Class>
            <Class name="MProperties8">
               <Inherits>
                  <Inherit name="MProperties8C" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="EnsureSize">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8::EnsureSize(TInt size){\n	_pNames-&gt;EnsureSize(size);\n	_pValues-&gt;EnsureSize(size);\n}</Source>
                  </Method>
                  <Method name="Assign">
                     <Parameters>
                        <Parameter type="MProperties8C&amp;" name="properties"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8::Assign(const MProperties8C&amp; properties){\n	Clear();\n	Append(properties);\n}</Source>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="MProperties8C&amp;" name="properties"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8::Append(const MProperties8C&amp; properties){\n	TInt count = properties.Count();\n	for(TInt n = 0; n &lt; count; n++){\n		_pNames-&gt;Push(properties.Name(n));\n		_pValues-&gt;Push(properties.Value(n));\n	}\n	_count = count;\n}</Source>
                  </Method>
                  <Method name="AppendSplit">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                        <Parameter type="TChar8" name="nameSpliter"/>
                        <Parameter type="TChar8" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8::AppendSplit(TChar8C* pValue, TChar8 nameSpliter, TChar8 valueSpliter){\n	TString8Refer value(pValue);\n	TInt offset = 0;\n	TInt nameEnd = value.IndexOf(nameSpliter,  offset);\n	while(ENotFound != nameEnd){\n		_pNames-&gt;Push(value.SubPtrC(offset, nameEnd));\n		TInt valueEnd = value.IndexOf(valueSpliter, offset);\n		_pValues-&gt;Push(value.SubPtrC(nameEnd + 1, valueEnd));\n		offset += (valueEnd + 1);\n		nameEnd = value.IndexOf(nameSpliter,  offset);\n		++_count;\n	}\n}</Source>
                  </Method>
                  <Method name="AppendSplit">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                        <Parameter type="TChar8C*" name="pNameSpliter"/>
                        <Parameter type="TChar8C*" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8::AppendSplit(TChar8C* pValue, TChar8C* pNameSpliter, TChar8C* valueSpliter){\n	TString8Refer value(pValue);\n	TInt nameSpliterLen = strlen(pNameSpliter);\n	TInt valueSpliterLen = strlen(valueSpliter);\n	TInt offset = 0;\n	TInt nameEnd = value.Find(pNameSpliter,  offset);\n	while(ENotFound != nameEnd){\n		_pNames-&gt;Push(value.SubPtrC(offset, nameEnd));\n		TInt valueEnd = value.Find(valueSpliter, offset);\n		_pValues-&gt;Push(value.SubPtrC(nameEnd + nameSpliterLen + 1, valueEnd));\n		offset += (valueEnd + valueSpliterLen + 1);\n		nameEnd = value.Find(pNameSpliter,  offset);\n		++_count;\n	}\n}</Source>
                  </Method>
                  <Method name="Add">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pName"/>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8::Add(TChar8C* pName, TChar8C* pValue){\n	_pNames-&gt;Push(pName);\n	_pValues-&gt;Push(pValue);\n	++_count;\n}</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pName"/>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8::Set(TChar8C* pName, TChar8C* pValue){\n	TInt index = _pNames-&gt;IndexOf(pName);\n	MO_ASSERT(ENotFound != index);\n	while(ENotFound != index){\n		_pValues-&gt;Set(index, pValue);\n		index = _pNames-&gt;IndexOf(pName);\n	}\n}</Source>
                  </Method>
                  <Method name="Split">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                        <Parameter type="TChar8" name="nameSpliter"/>
                        <Parameter type="TChar8" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8::Split(TChar8C* pValue, TChar8 nameSpliter, TChar8 valueSpliter){\n	Clear();\n	AppendSplit(pValue, nameSpliter, valueSpliter);\n}</Source>
                  </Method>
                  <Method name="Split">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                        <Parameter type="TChar8C*" name="pNameSpliter"/>
                        <Parameter type="TChar8C*" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8::Split(TChar8C* pValue, TChar8C* pNameSpliter, TChar8C* valueSpliter){\n	Clear();\n	AppendSplit(pValue, pNameSpliter, valueSpliter);\n}</Source>
                  </Method>
                  <Method name="Unpack">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pPack"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8::Unpack(TChar8C* pPack){\n	TString8Refer value(pPack);\n	TInt count = value.Length();\n	TInt offset = 0;\n	while(offset &lt; count){\n		// name\n		TFsName8 nameLenLenStr = value.SubPtrC(offset, ++offset);\n		TInt nameLenLen = RInt::Parse(nameLenLenStr.MemoryC());\n		MO_ASSERT(nameLenLen &gt;0 &amp;&amp; nameLenLen &lt;=9);\n		TFsName8 nameLenStr = value.SubPtrC(offset, offset + nameLenLen);\n		offset += nameLenLen;\n		TInt nameLen = RInt::Parse(nameLenStr.MemoryC());\n		_pNames-&gt;Push( value.SubPtrC(offset, offset + nameLen));\n		offset+= nameLen;\n		// value\n		TFsName8 valueLenLenStr = value.SubPtrC(offset, ++offset);\n		TInt valueLenLen = RInt::Parse(valueLenLenStr.MemoryC());\n		MO_ASSERT(valueLenLen &gt;0 &amp;&amp; valueLenLen &lt;=9);\n		TFsName8 valueLenStr = value.SubPtrC(offset, offset + valueLenLen);\n		offset += valueLenLen;\n		TInt valueLen = RInt::Parse(valueLenStr.MemoryC());\n		_pNames-&gt;Push(value.SubPtrC(offset, offset + valueLen));\n		offset+= valueLen;\n		++_count;\n	}\n}</Source>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pName"/>
                     </Parameters>
                     <Return type="TString8"/>
                     <Source>//============================================================\n\nTString8 MProperties8::Remove(TChar8C* pName){\n	TString8 value;\n	TInt index = _pNames-&gt;IndexOf(pName);\n	MO_ASSERT(ENotFound != index);\n	value.Append(_pNames-&gt;Get(index));\n	value.Append(_pValues-&gt;Get(index));\n	_pNames-&gt;Delete(index);\n	_pValues-&gt;Delete(index);\n	--_count;\n	return value;\n}</Source>
                  </Method>
                  <Method name="Clear">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8::Clear(){\n	_pNames-&gt;Clear();\n	_pValues-&gt;Clear();\n	_count = 0;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MProperties8C">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="MProperties8C"/>
                  <Destructor name="~MProperties8C"/>
                  <Method name="operator[]">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pName"/>
                     </Parameters>
                     <Return type="TChar8C*"/>
                     <Source>//============================================================\n\nTChar8C* MProperties8C::operator[](TChar8C* pName){\n	return Get(pName);\n}</Source>
                  </Method>
                  <Method name="IsEmpty">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool MProperties8C::IsEmpty() const{\n	return (0 == _count);\n}</Source>
                  </Method>
                  <Method name="Count">
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MProperties8C::Count() const{\n	return _count;\n}</Source>
                  </Method>
                  <Method name="Contains">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool MProperties8C::Contains(TChar8C* pName) const{\n	MO_ASSERT(pName);\n	TInt index = _pNames-&gt;IndexOf(pName);\n	return (ENotFound != index);\n}</Source>
                  </Method>
                  <Method name="ContainsValue">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool MProperties8C::ContainsValue(TChar8C* pValue) const{\n	for(TInt n = 0; n &lt; _count; n++){\n		if(0 == strcmp(_pValues-&gt;Get(n), pValue)){\n			return ETrue;\n		}\n	}\n	return EFalse;\n}</Source>
                  </Method>
                  <Method name="Names">
                     <Return type="FString8s*"/>
                     <Source>//============================================================\n\nFString8s* MProperties8C::Names(){\n	return _pNames;\n}</Source>
                  </Method>
                  <Method name="Values">
                     <Return type="FString8s*"/>
                     <Source>//============================================================\n\nFString8s* MProperties8C::Values(){\n	return _pValues;\n}</Source>
                  </Method>
                  <Method name="Name">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="TChar8C*"/>
                     <Source>//============================================================\n\nTChar8C* MProperties8C::Name(TInt index) const{\n	MO_ASSERT_RANGE(index, 0, _count);\n	return _pNames-&gt;Get(index);\n}</Source>
                  </Method>
                  <Method name="SetName">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="TChar8C*" name="pName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8C::SetName(TInt index, TChar8C* pName) const{\n	MO_ASSERT_RANGE(index, 0, _count);\n	_pNames-&gt;Set(index, pName);\n}</Source>
                  </Method>
                  <Method name="Value">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="TChar8C*"/>
                     <Source>//============================================================\n\nTChar8C* MProperties8C::Value(TInt index) const{\n	MO_ASSERT_RANGE(index, 0, _count);\n	return _pValues-&gt;Get(index);\n}</Source>
                  </Method>
                  <Method name="SetValue">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8C::SetValue(TInt index, TChar8C* pValue) const{\n	MO_ASSERT_RANGE(index, 0, _count);\n	_pValues-&gt;Set(index, pValue);\n}</Source>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pName"/>
                     </Parameters>
                     <Return type="TChar8C*"/>
                     <Source>//============================================================\n\nTChar8C* MProperties8C::Get(TChar8C* pName) const{\n	TInt index = _pNames-&gt;IndexOf(pName);\n	MO_ASSERT(ENotFound != index);\n	return _pValues-&gt;Get(index);\n}</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pName"/>
                     </Parameters>
                     <Return type="TChar8C*"/>
                     <Source>//============================================================\n\nTChar8C* MProperties8C::Find(TChar8C* pName) const{\n	TInt index = _pNames-&gt;IndexOf(pName);\n	if(ENotFound == index){\n		return NULL;\n	}\n	return _pValues-&gt;Get(index);\n}</Source>
                  </Method>
                  <Method name="FindNvl">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pName"/>
                        <Parameter type="TChar8C*" name="pDefault"/>
                     </Parameters>
                     <Return type="TChar8C*"/>
                     <Source>//============================================================\n\nTChar8C* MProperties8C::FindNvl(TChar8C* pName, TChar8C* pDefault) const{\n	TInt index = _pNames-&gt;IndexOf(pName);\n	if(ENotFound == index){\n		return pDefault;\n	}\n	return _pValues-&gt;Get(index);\n}</Source>
                  </Method>
                  <Method name="Search">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="TChar8C*"/>
                     <Source>//============================================================\n\nTChar8C* MProperties8C::Search(TChar8C* pValue) const{\n	TInt index = _pValues-&gt;IndexOf(pValue);\n	if(ENotFound == index){\n		return NULL;\n	}\n	return _pNames-&gt;Get(index);\n}</Source>
                  </Method>
                  <Method name="Join">
                     <Parameters>
                        <Parameter type="FString8*" name="pValue"/>
                        <Parameter type="TChar8" name="nameSpliter"/>
                        <Parameter type="TChar8" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8C::Join(FString8* pValue, TChar8 nameSpliter, TChar8 valueSpliter){\n	for(TInt n = 0; n &lt; _count; n++){\n		if(n){\n			pValue-&gt;Append(valueSpliter);\n		}\n		pValue-&gt;Append(_pNames-&gt;Get(n));\n		pValue-&gt;Append(nameSpliter);\n		pValue-&gt;Append(_pValues-&gt;Get(n));\n	}\n}</Source>
                  </Method>
                  <Method name="Join">
                     <Parameters>
                        <Parameter type="FString8*" name="pValue"/>
                        <Parameter type="TChar8C*" name="pNameSpliter"/>
                        <Parameter type="TChar8C*" name="valueSpliter"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MProperties8C::Join(FString8* pValue, TChar8C* pNameSpliter, TChar8C* valueSpliter){\n	for(TInt n = 0; n &lt; _count; n++){\n		if(n){\n			pValue-&gt;Append(valueSpliter);\n		}\n		pValue-&gt;Append(_pNames-&gt;Get(n));\n		pValue-&gt;Append(pNameSpliter);\n		pValue-&gt;Append(_pValues-&gt;Get(n));\n	}\n}</Source>
                  </Method>
                  <Method name="Pack">
                     <Parameters>
                        <Parameter type="TChar8*" name="pPack"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MProperties8C::Pack(TChar8* pPack, TInt length){\n	TInt nameLength, valueLength, nameLenLen, valueLenLen;\n	if(pPack){\n		TChar8* writePos = pPack;\n		TInt bytesWrite = 0;\n		char lengthString[16];\n		for(TInt n = 0; n &lt; _count; n++){\n			TFsDump8 onePair;\n			TChar8C* pName = _pNames-&gt;Get(n);\n			TChar8C* pValue = _pValues-&gt;Get(n);\n			nameLength = strlen(pName);\n			valueLength = strlen(pValue);\n			nameLenLen = RInt::CountDigit(nameLength);\n			valueLenLen = RInt::CountDigit(valueLength);\n			// 名字长度的长度\n			RRuntime::IntToString8(nameLenLen, lengthString, 16);\n			onePair.Append(lengthString);\n			// 名字长度\n			RRuntime::IntToString8(nameLength, lengthString, 16);\n			onePair.Append(lengthString);\n			// 名字\n			onePair.Append(pName);\n			// 值长度的长度\n			RRuntime::IntToString8(valueLenLen, lengthString, 16);\n			onePair.Append(lengthString);\n			// 值长度\n			RRuntime::IntToString8(valueLength, lengthString, 16);\n			onePair.Append(lengthString);\n			// 值\n			onePair.Append(pValue);\n			TInt pairLen = onePair.Length();\n			MO_LIB_MEMCPY(writePos,length - bytesWrite, onePair.MemoryC(), pairLen);\n			//MO_LIB_STRCPY(writePos, length - bytesWrite, onePair.MemoryC());\n			bytesWrite += pairLen;\n			writePos+= pairLen;\n		}\n		return bytesWrite;\n	}else{\n		TInt byteCount = 0;\n		for(TInt n = 0; n &lt; _count; n++){\n			nameLength = strlen(_pNames-&gt;Get(n));\n			nameLenLen = RInt::CountDigit(nameLength);\n			valueLength = strlen(_pValues-&gt;Get(n));\n			valueLenLen = RInt::CountDigit(valueLength);\n			byteCount += ( 1 + nameLenLen + nameLength + 1 + valueLenLen + valueLength);\n		}\n		return byteCount;\n	}\n}</Source>
                  </Method>
                  <Method name="Dump">
                     <Return type="TString8"/>
                     <Source>//============================================================\n\nTString8 MProperties8C::Dump() const{\n	TString8 temp;\n	return temp;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="FString8s*" name="_pNames"/>
                  <Attribute type="FString8s*" name="_pValues"/>
               </Attributes>
            </Class>
            <Class name="MProperties8Iterator">
               <Inherits>
                  <Inherit name="MProperties8IteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="MProperties8Iterator"/>
                  <Constructor name="MProperties8Iterator">
                     <Parameters>
                        <Parameter type="MProperties8IteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Method name="SetName" type="inline">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void SetName(TCharC* pName) const{\n   }</Source>
                  </Method>
                  <Method name="SetValue" type="inline">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void SetValue(TCharC* pValue) const{\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MProperties8IteratorC">
               <Methods>
                  <Constructor name="MProperties8IteratorC"/>
                  <Constructor name="MProperties8IteratorC">
                     <Parameters>
                        <Parameter type="MProperties8IteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="MProperties8IteratorC">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                        <Parameter type="FString8s*" name="pNames"/>
                        <Parameter type="FString8s*" name="pValues"/>
                     </Parameters>
                  </Constructor>
                  <Method name="IsEmpty" type="inline" description="获得当前位置的数据内容。获得当前位置的数据内容。当前节点是否含有数据。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsEmpty(){\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="HasNext" type="inline" description="判断是否存在下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool HasNext(){\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="Next" type="inline" description="移动到下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Next(){\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="HasPrior" type="inline" description="判断是否存在下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool HasPrior(){\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="Prior" type="inline" description="移动到上一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Prior(){\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="Reset" type="inline" description="重置位置。">
                     <Return type="void"/>
                     <Source>\ninline void Reset(){\n   }</Source>
                  </Method>
                  <Method name="IsName" type="inline" description="判断名称是否相同。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsName(TCharC* pName) const{\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="IsValue" type="inline" description="判断内容是否相同。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsValue(TCharC* pValue) const{\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="Name" type="inline" description="获得当前位置的数据名称。">
                     <Return type="TCharC*"/>
                     <Source>\ninline TCharC* Name() const{\n      return NULL;\n   }</Source>
                  </Method>
                  <Method name="Value" type="inline" description="获得当前位置的数据内容。">
                     <Return type="TCharC*"/>
                     <Source>\ninline TCharC* Value() const{\n      return NULL;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_index"/>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="FString8s*" name="_pNames"/>
                  <Attribute type="FString8s*" name="_pValues"/>
               </Attributes>
            </Class>
            <Class name="MPtrC">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerInitialize" type="static" description="内部初始化。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(const T* pMemory, TInt length, TInt size){\n      _pMemory = MO_CAST_CONST(pMemory, T*);\n      _length = length;\n      _size = size;\n   }</Source>
                  </Method>
                  <Method name="T*" description="获取数据指针。">
                     <Return type="const"/>
                     <Source>\noperator const T*() const{\n      return _pMemory;\n   }</Source>
                  </Method>
                  <Method name="operator[]" description="获取指定索引位置的数据。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT operator[](TInt index) const{\n      MO_ASSERT(_pMemory);\n      MO_ASSERT_RANGE(index, 0, _length);\n      return _pMemory[index];\n   }</Source>
                  </Method>
                  <Method name="IsEmpty" description="判断内容是否为空。">
                     <Return type="TBool"/>
                     <Source>\nTBool IsEmpty() const{\n      return (0 == _length);\n   }</Source>
                  </Method>
                  <Method name="MemoryC" description="获得只读数据指针。">
                     <Return type="T*"/>
                     <Source>\nconst T* MemoryC() const{\n      return _pMemory;\n   }</Source>
                  </Method>
                  <Method name="Length" description="获得数据长度。">
                     <Return type="TInt"/>
                     <Source>\nTInt Length() const{\n      return _length;\n   }</Source>
                  </Method>
                  <Method name="Size" description="获得数据大小。">
                     <Return type="TInt"/>
                     <Source>\nTInt Size() const{\n      return _size;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T*" name="_pMemory"/>
                  <Attribute type="TInt" name="_length"/>
                  <Attribute type="TInt" name="_size"/>
               </Attributes>
            </Class>
            <Class name="MSet">
               <Inherits>
                  <Inherit name="MSetC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerCast" type="inline" description="获得内部类型指针。">
                     <Return type="A*"/>
                     <Source>\ninline A* InnerCast(){\n      return static_cast&lt;A*&gt;(this);\n   }</Source>
                  </Method>
                  <Method name="EntryAlloc" type="inline" description="收集一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryAlloc(){\n      SEntry* pEntry = NULL;\n      // 查看未使用节点中是否有自由节点\n      if(NULL != this-&gt;_pUnused){\n         // 收集未使用的节点\n         pEntry = this-&gt;_pUnused;\n         this-&gt;_pUnused = this-&gt;_pUnused-&gt;pNext;\n      }else{\n         // 收集新节点\n         pEntry = InnerCast()-&gt;A::EntryCreate();\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryFree" type="inline" description="释放一个被使用的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFree(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      pEntry-&gt;pNext = this-&gt;_pUnused;\n      this-&gt;_pUnused = pEntry;\n   }</Source>
                  </Method>
                  <Method name="operator+=">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="set"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(const MSetC&lt;N, V&gt;&amp; set){\n		Append(&amp;set);\n	}</Source>
                  </Method>
                  <Method name="EntriesResize" type="inline" description="扩充当前对象的哈希值数组。">
                     <Parameters>
                        <Parameter type="SEntry**" name="ppEntries"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntriesResize(SEntry** ppEntries, TInt size){\n      // 循环取出旧的节点列表内容，移到新的节点列表上\n      TInt n = 0;\n      while(++n &lt; this-&gt;_entryCount){\n         SEntry* pEntry = this-&gt;_ppEntries[n];\n         while(NULL != pEntry){\n            // 保存当前节点的下一个节点指针\n            SEntry* pLink = pEntry-&gt;pLink;\n            // 将当前节点存储到新建的节点列表上去\n            TInt index = pEntry-&gt;code % size;\n            pEntry-&gt;pLink = ppEntries[index];\n            ppEntries[index] = pEntry;\n            // 获得保存的下一个节点指针\n            pEntry = pLink;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Iterator" description="获得可写迭代器。">
                     <Return type="TIterator"/>
                     <Source>\nTIterator Iterator(){\n      return TIterator(this-&gt;_pFirst);\n   }</Source>
                  </Method>
                  <Method name="LastIterator" description="获得结尾可写迭代器。">
                     <Return type="TIterator"/>
                     <Source>\nTIterator LastIterator(){\n      return TIterator(this-&gt;_pLast);\n   }</Source>
                  </Method>
                  <Method name="Assign" description="复制集合内的全部数据。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;*" name="pSet"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MSetC&lt;N, V&gt;* pSet){\n      MO_ASSERT(pSet);\n      Clear();\n      Append(pSet);\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加集合内的全部数据。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;*" name="pSet"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MSetC&lt;N, V&gt;* pSet){\n      MO_ASSERT(pSet);\n      TIteratorC iterator = pSet-&gt;IteratorC();\n      while(iterator.Next()){\n         Set(iterator.Code(), iterator.Value());\n      }\n   }</Source>
                  </Method>
                  <Method name="Set" description="根据名称设置数据。">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(N code, V value){\n      TInt index = code % this-&gt;_entryCount;\n      // 查找数据出现的位置\n      SEntry* pEntry = this-&gt;_ppEntries[index];\n      while(NULL != pEntry) {\n         if(pEntry-&gt;code == code){\n            pEntry-&gt;value = value;\n            return;\n         }\n         pEntry = pEntry-&gt;pLink;\n      }\n      // 如果名称不存在，为新建节点检查内存\n      pEntry = EntryAlloc();\n      pEntry-&gt;pLink = this-&gt;_ppEntries[index];\n      pEntry-&gt;code = code;\n      pEntry-&gt;value = value;\n      this-&gt;_ppEntries[index] = pEntry;\n      // 追加到链表尾部\n      EntryPush(pEntry);\n   }</Source>
                  </Method>
                  <Method name="Remove" description="移除指定名称的数据。">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="V"/>
                     <Source>\nV Remove(N code){\n      TInt index = code % this-&gt;_entryCount;\n      // 查找数据出现的位置\n      V value = NULL;\n      SEntry* pPrior = this-&gt;_ppEntries[index];\n      SEntry* pEntry = pPrior;\n      while(NULL != pEntry){\n         if(pEntry-&gt;code == code){\n            value = pEntry-&gt;value;\n            if(pEntry == pPrior){\n               // 当前对象是第一个对象时\n               this-&gt;_ppEntries[index] = pEntry-&gt;pNext;\n            }else{\n               // 当前对象不是第一个对象时\n               pPrior-&gt;pNext = pEntry-&gt;pNext;\n            }\n            // 删除当前节点\n            EntryRemove(pEntry);\n            break;\n         }\n         pPrior = pEntry;\n         pEntry = pEntry-&gt;pLink;\n      }\n      return value;\n   }</Source>
                  </Method>
                  <Method name="Sort" description="使用排序器对集合对象进行排序">
                     <Parameters>
                        <Parameter type="IComparer&lt;N&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Sort(IComparer&lt;N&gt;* pComparer){\n      MO_ASSERT(pComparer);\n      if(this-&gt;_pFirst &amp;&amp; this-&gt;_pLast &amp;&amp; this-&gt;_count &gt; 1) {\n         if(MO_COMPLIST_THRESHOLD &gt; this-&gt;_count){\n            RComparerSort&lt;N&gt;::SetInsertSort(this-&gt;_pFirst, this-&gt;_pLast, pComparer);\n         } else{\n            RComparerSort&lt;N&gt;::SetQuickSort(this-&gt;_pFirst, this-&gt;_pLast, pComparer);\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清空当前哈希集合全部数据。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;EntryClear();\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SEntry*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="MSetC">
               <Inherits>
                  <Inherit name="MEntriesC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      MEntriesC&lt;SEntry&gt;::InnerInitialize();\n      _entryCount = 0;\n      _ppEntries = NULL;\n   }</Source>
                  </Method>
                  <Method name="operator==" description="判断当前哈希集合和指定哈希集合中所有数据内容是否相等。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="set"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator==(const MSetC&lt;N, V&gt;&amp; set) const{\n		return Equals(&amp;set);\n	}</Source>
                  </Method>
                  <Method name="operator!=" description="判断当前哈希集合和指定哈希集合中所有数据内容是否不相等。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="set"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator!=(const MSetC&lt;N, V&gt;&amp; set) const{\n		return !Equals(&amp;set);\n	}</Source>
                  </Method>
                  <Method name="operator[]" description="获得指定代码的数据内容。">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="V"/>
                     <Source>\nV operator[](N code){\n      SEntry* pEntry = EntryFind(code);\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n	}</Source>
                  </Method>
                  <Method name="EntryFind" type="inline" description="查找指定名称的索引位置。">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryFind(N code) const{\n      // 数据存在时\n      if(this-&gt;_count &gt; 0){\n         // 查找名称的索引位置\n         SEntry* pEntry = _ppEntries[code % _entryCount];\n         while(NULL != pEntry){\n            if(pEntry-&gt;code == code){\n               return pEntry;\n            }\n            pEntry = pEntry-&gt;pLink;\n         }\n      }\n      // 未找到时返回结果\n      return NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryFindValue" type="inline" description="查找指定名称的索引位置。">
                     <Parameters>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryFindValue(V value) const{\n      // 数据存在时\n      if(this-&gt;_count &gt; 0){\n         TInt n = 0;\n         while(++n &lt; _entryCount){\n            SEntry* pEntry = _ppEntries[n];\n            while(NULL != pEntry){\n               if(pEntry-&gt;value == value){\n                  return pEntry;\n               }\n               pEntry = pEntry-&gt;pLink;\n            }\n         }\n      }\n      // 未找到时返回结果\n      return NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryClear" type="inline">
                     <Return type="void"/>
                     <Source>\ninline void EntryClear(){\n      // 清除表格\n      for(TInt n=0; n&lt;_entryCount; n++){\n         _ppEntries[n] = NULL;\n      }\n      // 清除链表\n      MEntriesC&lt;SEntry&gt;::EntryClear();\n   }</Source>
                  </Method>
                  <Method name="IsEmpty" description="当前哈希集合对象是否为空。">
                     <Return type="TBool"/>
                     <Source>\nTBool IsEmpty() const{\n      return (0 == this-&gt;_count);\n   }</Source>
                  </Method>
                  <Method name="Count" description="获得数据个数。">
                     <Return type="TInt"/>
                     <Source>\nTInt Count() const{\n      return this-&gt;_count;\n   }</Source>
                  </Method>
                  <Method name="Contains" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Contains(N code) const{\n      return (NULL != EntryFind(code));\n   }</Source>
                  </Method>
                  <Method name="ContainsValue" description="判断指定名称是否存在。">
                     <Parameters>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool ContainsValue(V value) const{\n      return (NULL != EntryFindValue(value));\n   }</Source>
                  </Method>
                  <Method name="Equals" description="判断当前哈希集合和指定哈希集合内容是否相等。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;*" name="pSet"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Equals(const MSetC&lt;N, V&gt;* pSet) const{\n      MO_ASSERT(pSet);\n      // 比较数量\n      if(this-&gt;_count != pSet-&gt;_count){\n         return EFalse;\n      }\n      // 比较所有项目\n      TIteratorC iterator = pSet-&gt;IteratorC();\n      while(iterator.Next()){\n         N code = iterator.Code();\n         SEntry* pEntry = this-&gt;EntryFind(code);\n         if(NULL == pEntry){\n            return EFalse;\n         }\n         if(!iterator.IsValue(pEntry-&gt;value)){\n            return EFalse;\n         }\n      }\n      return ETrue;\n	}</Source>
                  </Method>
                  <Method name="First" description="获得首位置的数据。">
                     <Return type="V"/>
                     <Source>\nV First() const{\n      return (NULL != this-&gt;_pFirst) ? this-&gt;_pFirst-&gt;value : NULL;\n   }</Source>
                  </Method>
                  <Method name="Last" description="获得尾位置的数据。">
                     <Return type="V"/>
                     <Source>\nV Last() const{\n      return (NULL != this-&gt;_pLast) ? this-&gt;_pLast-&gt;value : NULL;\n   }</Source>
                  </Method>
                  <Method name="IteratorC" description="获得只读迭代器。">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC IteratorC(){\n      return TIteratorC(this-&gt;_pFirst);\n   }</Source>
                  </Method>
                  <Method name="LastIteratorC" description="获得结尾只读迭代器。">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC LastIteratorC(){\n      return TIteratorC(this-&gt;_pLast);\n   }</Source>
                  </Method>
                  <Method name="Get" description="获得指定代码的数据。">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="V"/>
                     <Source>\nV Get(N code) const{\n      SEntry* pEntry = EntryFind(code);\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="Find" description="获得指定代码的数据。">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="V"/>
                     <Source>\nV Find(N code) const{\n      SEntry* pEntry = EntryFind(code);\n      return (NULL != pEntry) ? pEntry-&gt;value : (V)NULL;\n   }</Source>
                  </Method>
                  <Method name="Search" description="获得指定数据的代码。">
                     <Parameters>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="N"/>
                     <Source>\nN Search(V value) const{\n      SEntry* pEntry = EntryFindValue(value);\n      return (NULL != pEntry) ? pEntry-&gt;code : (N)NULL;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_entryCount"/>
                  <Attribute type="SEntry**" name="_ppEntries"/>
               </Attributes>
            </Class>
            <Class name="MSingleton">
               <Inherits>
                  <Inherit name="ISingleton" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="MSingleton" description="构造唯一对象的实例。"/>
                  <Destructor name="~MSingleton" description="析构唯一对象的实例。"/>
                  <Method name="SingletonType" flag="override" description="获得唯一对象的类型。">
                     <Return type="ESingleton" description="类型"/>
                     <Source>//============================================================\n// &lt;T&gt;获得唯一对象的类型。&lt;/T&gt;\n//\n// @return 类型\n//============================================================\n\nESingleton MSingleton::SingletonType(){\n   return ESingleton_Object;\n}</Source>
                  </Method>
                  <Method name="Code" flag="override" description="获得唯一对象的代码。">
                     <Return type="TInt" description="代码"/>
                     <Source>//============================================================\n// &lt;T&gt;获得唯一对象的代码。&lt;/T&gt;\n//\n// @return 代码\n//============================================================\n\nTInt MSingleton::Code(){\n   return _code;\n}</Source>
                  </Method>
                  <Method name="Name" flag="override" description="获得唯一对象的名称。">
                     <Return type="TCharC*" description="名称"/>
                     <Source>//============================================================\n// &lt;T&gt;获得唯一对象的名称。&lt;/T&gt;\n//\n// @return 名称\n//============================================================\n\nTCharC* MSingleton::Name(){\n   return _name.MemoryC();\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_code"/>
                  <Attribute type="TFsName" name="_name"/>
               </Attributes>
            </Class>
            <Class name="MString16">
               <Inherits>
                  <Inherit name="MString16C" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerCast" type="inline" description="获得内部类型指针。">
                     <Return type="A*"/>
                     <Source>\ninline A* InnerCast(){\n      return static_cast&lt;A*&gt;(this);\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="当前字符串上追加一个ANSI字符串。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(TChar16C* pValue){\n      Append(pValue);\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="当前字符串上追加一个ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;TChar16&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(const MPtrC&lt;TChar16&gt;&amp; value){\n      Append(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="TChar16*" description="获得数据指针">
                     <Return type="operator"/>
                     <Source>\noperator TChar16*(){\n      return _pMemory;\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接受一个字符串到当前字符串对象的末尾。" note="如果长度小于0，则自动计算指针的数据长度。">
                     <Parameters>
                        <Parameter type="TInt" name="length" default="-1"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(TChar16C* pValue, TInt length = -1){\n      Clear();\n      if(NULL != pValue){\n         Append(pValue, length);\n      }\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接受一个字符串到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;TChar16&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MPtrC&lt;TChar16&gt;&amp; value){\n      Clear();\n      if(!value.IsEmpty()){\n         Append(value.MemoryC(), value.Length());\n      }\n   }</Source>
                  </Method>
                  <Method name="AssignFormat" description="追加一个格式化字符串到对象尾部。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pFormat"/>
                        <Parameter type="pFormat," name="..."/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AssignFormat(TChar16C* pFormat, ...){\n      Clear();\n      // 格式化可变参数字符串信息\n      va_list params;\n      va_start(params, pFormat);\n      // 输出日志信息\n      TInt length = _vscwprintf(pFormat, params);\n      InnerCast()-&gt;A::EnsureSize(_length + length + 1);\n      length = vswprintf_s(_pMemory + _length, length + 1, pFormat, params);\n      this-&gt;_length += length;\n      va_end(params);\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个字符到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="TChar16" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(TChar16 value){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      this-&gt;_pMemory[this-&gt;_length++] = value;\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个字符串到当前字符串对象的末尾。" note="如果长度小于0，则自动计算指针的数据长度。">
                     <Parameters>
                        <Parameter type="TInt" name="length" default="-1"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(TChar16C* pValues, TInt length = -1){\n      if(length &lt; 0){\n         length = RTypes&lt;TChar16C&gt;::IndexOf(pValues, 0);\n      }\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + length + 1);\n      RTypes&lt;TChar16&gt;::Copy(this-&gt;_pMemory + this-&gt;_length, pValues, length);\n      this-&gt;_length += length;\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个字符串到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;TChar16&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MPtrC&lt;TChar16&gt;&amp; value){\n      if(!value.IsEmpty()){\n         Append(value.MemoryC(), value.Length());\n      }\n   }</Source>
                  </Method>
                  <Method name="AppendInt" description="追加一个数字到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="TInt" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendInt(TInt value){\n      TChar16 result[MO_FS_NUMBER_LENGTH];\n      Append(RRuntime::IntToString16(value, result, MO_FS_NUMBER_LENGTH));\n   }</Source>
                  </Method>
                  <Method name="AppendRepeat" description="重复追加一个字符串到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendRepeat(TChar16C* pValue, TInt count){\n      for(TInt n=0; n&lt;count; n++){\n         Append(pValue);\n      }\n   }</Source>
                  </Method>
                  <Method name="AppendFormat" description="追加一个格式化字符串到对象尾部。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pFormat"/>
                        <Parameter type="pFormat," name="..."/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendFormat(TChar16C* pFormat, ...){\n      // 格式化可变参数字符串信息\n      va_list params;\n      va_start(params, pFormat);\n      // 输出日志信息\n      TInt length = _vscwprintf(pFormat, params);\n      InnerCast()-&gt;A::EnsureSize(_length + length + 1);\n      length = vswprintf_s(_pMemory + _length, length + 1, pFormat, params);\n      this-&gt;_length += length;\n      va_end(params);\n   }</Source>
                  </Method>
                  <Method name="AppendFormat">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pFormat"/>
                        <Parameter type="va_list&amp;" name="params"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendFormat(TChar16C* pFormat, va_list&amp; params){\n      TInt length = _vscwprintf(pFormat, params);\n      InnerCast()-&gt;A::EnsureSize(_length + length + 1);\n      length = vswprintf_s(_pMemory + _length, length + 1, pFormat, params);\n      this-&gt;_length += length;\n   }</Source>
                  </Method>
                  <Method name="AppendLine" description="追加一个空行。">
                     <Return type="void"/>
                     <Source>\nvoid AppendLine(){\n      this-&gt;Append('\n');\n   }</Source>
                  </Method>
                  <Method name="Memory">
                     <Return type="TChar16*"/>
                     <Source>\nTChar16* Memory() const{\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="MemoryZ" description="获得一个末尾是空的字符串。">
                     <Return type="TChar16*"/>
                     <Source>\nTChar16* MemoryZ(){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="PtrZ" description="获得只读指针。">
                     <Return type="MString16PtrC"/>
                     <Source>\nMString16PtrC PtrZ(){\n      return TString16Ptr(this-&gt;_pMemory, this-&gt;_length, this-&gt;_size);\n   }</Source>
                  </Method>
                  <Method name="SetLength" description="设置字符串的长度。">
                     <Parameters>
                        <Parameter type="TUint" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid SetLength(TUint length){\n      InnerCast()-&gt;A::EnsureSize(length);\n      this-&gt;_length = length;\n   }</Source>
                  </Method>
                  <Method name="Fix" description="修正当前字符串内容。" note="如果字符串中含有0，则废弃后面的部分，并修正长度。如果字符串结尾处没有0，则自动添入0进行结尾。">
                     <Return type="void"/>
                     <Source>\nvoid Fix(){\n      for(TInt n=0; n&lt;this-&gt;_size; n++){\n         if(0 == this-&gt;_pMemory[n]){\n            this-&gt;_length = n;\n            return;\n         }\n      }\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n   }</Source>
                  </Method>
                  <Method name="ToLower" description="将内部字符串转换为小写。">
                     <Return type="void"/>
                     <Source>\nvoid ToLower(){\n      RChar16::ToLower(this-&gt;_pMemory, this-&gt;_length);\n   }</Source>
                  </Method>
                  <Method name="ToUpper" description="将内部字符串转换为大写。">
                     <Return type="void"/>
                     <Source>\nvoid ToUpper(){\n      RChar16::ToUpper(this-&gt;_pMemory, this-&gt;_length);\n   }</Source>
                  </Method>
                  <Method name="PadLeft">
                     <Parameters>
                        <Parameter type="TChar16" name="pad"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid PadLeft(TChar16 pad, TInt length){\n   }</Source>
                  </Method>
                  <Method name="PadRight">
                     <Parameters>
                        <Parameter type="TChar16" name="pad"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid PadRight(TChar16 pad, TInt length){\n      TInt count = length - this-&gt;_length;\n      for(TInt n=0; n&lt;count; n++){\n         this-&gt;_pMemory[this-&gt;_length++] = pad;\n      }\n   }</Source>
                  </Method>
                  <Method name="Replace" description="替换指定字符为另外字符。">
                     <Parameters>
                        <Parameter type="TChar16" name="source"/>
                        <Parameter type="TChar16" name="target"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt Replace(TChar16 source, TChar16 target){\n      TInt result = 0;\n      for(TInt n=0; n&lt;this-&gt;_length; n++){\n         if(source == this-&gt;_pMemory[n]){\n            this-&gt;_pMemory[n] = target;\n            result++;\n         }\n      }\n      return result;\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清除所有数据。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;_length = 0;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MString16C">
               <Inherits>
                  <Inherit name="MArrayC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Equals" description="判断当前字符串和指定字符串是否相等。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断当前字符串和指定字符串是否相等。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString16C::Equals(TChar16C* pValue) const{\n   return (0 == wcscmp(MemoryC(), pValue));\n}</Source>
                  </Method>
                  <Method name="EqualsIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串是否相等。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串是否相等。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString16C::EqualsIgnoreCase(TChar16C* pValue) const{\n   return (0 == _wcsicmp(MemoryC(), pValue));\n}</Source>
                  </Method>
                  <Method name="EqualsIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串是否相等。">
                     <Parameters>
                        <Parameter type="MString16PtrC&amp;" name="value" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串是否相等。&lt;/T&gt;\n//\n// @param value 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString16C::EqualsIgnoreCase(const MString16PtrC&amp; value) const{\n   return (0 == _wcsicmp(MemoryC(), value.MemoryC()));\n}</Source>
                  </Method>
                  <Method name="StartsWith" description="查找指定数组是否出现在当前数组的开始位置。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;查找指定数组是否出现在当前数组的开始位置。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString16C::StartsWith(TChar16C* pValue) const{\n   MO_ASSERT(pValue);\n   TInt length = wcslen(pValue);\n   return RTypes&lt;TChar16C&gt;::StartsWith(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="EndsWith" description="查找指定数组是否出现在当前数组的结束位置。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;查找指定数组是否出现在当前数组的结束位置。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString16C::EndsWith(TChar16C* pValue) const{\n   MO_ASSERT(pValue);\n   TInt length = wcslen(pValue);\n   return RTypes&lt;TChar16C&gt;::EndsWith(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="CompareIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串的大小。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TInt" description="&lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;">
                        <L value="value='等于0'&gt;当前字符串相等指定字符串"/>
                        <L value="value='大于0'&gt;当前字符串大于指定字符串"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串的大小。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;\n//         &lt;L value='等于0'&gt;当前字符串相等指定字符串&lt;/L&gt;\n//         &lt;L value='大于0'&gt;当前字符串大于指定字符串&lt;/L&gt;\n//============================================================\n\nTInt MString16C::CompareIgnoreCase(TChar16C* pValue) const{\n   return wcscmp(MemoryC(), pValue);\n}</Source>
                  </Method>
                  <Method name="CompareIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串的大小。">
                     <Parameters>
                        <Parameter type="MString16PtrC&amp;" name="value" description="指定字符串"/>
                     </Parameters>
                     <Return type="TInt" description="&lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;">
                        <L value="value='等于0'&gt;当前字符串相等指定字符串"/>
                        <L value="value='大于0'&gt;当前字符串大于指定字符串"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串的大小。&lt;/T&gt;\n//\n// @param value 指定字符串\n// @return &lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;\n//         &lt;L value='等于0'&gt;当前字符串相等指定字符串&lt;/L&gt;\n//         &lt;L value='大于0'&gt;当前字符串大于指定字符串&lt;/L&gt;\n//============================================================\n\nTInt MString16C::CompareIgnoreCase(const MString16PtrC&amp; value) const{\n   return _wcsicmp(MemoryC(), value.MemoryC());\n}</Source>
                  </Method>
                  <Method name="HashCode" description="计算当前字符串的哈希值。">
                     <Return type="THashCode" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;计算当前字符串的哈希值。&lt;/T&gt;\n//\n// @return 哈希值\n//============================================================\n\nTHashCode MString16C::HashCode() const{\n   return RTypes&lt;TChar16&gt;::MakeHashCode(this-&gt;_pMemory, this-&gt;_length);\n}</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MString16C::Find(TChar16C* pValue){\n   TInt length = wcslen(pValue);\n   return RTypes&lt;TChar16&gt;::Find(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue"/>
                        <Parameter type="TInt" name="offset"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MString16C::Find(TChar16C* pValue, TInt offset){\n   MO_ASSERT_BETWEEN(offset, 0, this-&gt;_length);\n   TInt length = wcslen(pValue);\n   TInt result = RTypes&lt;TChar16&gt;::Find(this-&gt;_pMemory + offset, this-&gt;_length - offset, pValue, length);\n   return (ENotFound != result) ? offset + result : ENotFound;\n}</Source>
                  </Method>
                  <Method name="LastFind">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MString16C::LastFind(TChar16C* pValue){\n   TInt length = wcslen(pValue);\n   return RTypes&lt;TChar16&gt;::LastFind(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="TrimLeft" description="去掉左边的空白，返回字符串引用。">
                     <Return type="MString16PtrC" description="字符串引用"/>
                     <Source>//============================================================\n// &lt;T&gt;去掉左边的空白，返回字符串引用。&lt;/T&gt;\n//\n// @return 字符串引用\n//============================================================\n\nMString16PtrC MString16C::TrimLeft() const{\n   TInt position = 0;\n   TInt length = Length();\n   TChar16* pMemory = _pMemory;\n	while((position &lt; length) &amp;&amp; (pMemory[position] &lt;= ' ')){\n	    position++;\n	}\n	return TString16Ptr(pMemory + position, length - position);\n}</Source>
                  </Method>
                  <Method name="TrimRight" description="去掉右边的空白，返回字符串引用。">
                     <Return type="MString16PtrC" description="字符串引用"/>
                     <Source>//============================================================\n// &lt;T&gt;去掉右边的空白，返回字符串引用。&lt;/T&gt;\n//\n// @return 字符串引用\n//============================================================\n\nMString16PtrC MString16C::TrimRight() const{\n   TInt position = Length() - 1;\n   TChar16* pMemory = _pMemory;\n	while((position &gt;= 0) &amp;&amp; (pMemory[position] &lt;= ' ')){\n	    position--;\n	}\n	return TString16Ptr(pMemory, position);\n}</Source>
                  </Method>
                  <Method name="Trim" description="去掉两边的空白，返回字符串引用。">
                     <Return type="MString16PtrC" description="字符串引用"/>
                     <Source>//============================================================\n// &lt;T&gt;去掉两边的空白，返回字符串引用。&lt;/T&gt;\n//\n// @return 字符串引用\n//============================================================\n\nMString16PtrC MString16C::Trim() const{\n   TInt start = 0;\n   TInt length = Length();\n   TChar16* pMemory = _pMemory;\n   // 去掉左边空白字符\n	while((start &lt; length) &amp;&amp; (pMemory[start] &lt;= ' ')){\n	    start++;\n	}\n   // 去掉右边空白字符\n   TInt end = length - 1;\n	while((end &gt;= 0) &amp;&amp; (pMemory[end] &lt;= ' ')){\n	    end--;\n	}\n	return TString16Ptr(pMemory + start, end - start + 1);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MString16s">
               <Inherits>
                  <Inherit name="MString16sC" scope="public"/>
               </Inherits>
            </Class>
            <Class name="MString16sC">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
            </Class>
            <Class name="MString32">
               <Inherits>
                  <Inherit name="MString32C" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerCast" type="inline" description="获得内部类型指针。">
                     <Return type="A*"/>
                     <Source>\ninline A* InnerCast(){\n      return static_cast&lt;A*&gt;(this);\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="当前字符串上追加一个ANSI字符串。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(TChar32C* pValue){\n      Append(pValue);\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="当前字符串上追加一个ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;TChar32&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(const MPtrC&lt;TChar32&gt;&amp; value){\n      Append(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="TChar32*" description="获得数据指针">
                     <Return type="operator"/>
                     <Source>\noperator TChar32*(){\n      return _pMemory;\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接受一个字符串到当前字符串对象的末尾。" note="如果长度小于0，则自动计算指针的数据长度。">
                     <Parameters>
                        <Parameter type="TInt" name="length" default="-1"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(TChar32C* pValue, TInt length = -1){\n      Clear();\n      if(NULL != pValue){\n         Append(pValue, length);\n      }\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接受一个字符串到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;TChar32&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MPtrC&lt;TChar32&gt;&amp; value){\n      Clear();\n      if(!value.IsEmpty()){\n         Append(value.MemoryC(), value.Length());\n      }\n   }</Source>
                  </Method>
                  <Method name="AssignFormat" description="追加一个格式化字符串到对象尾部。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pFormat"/>
                        <Parameter type="pFormat," name="..."/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AssignFormat(TChar32C* pFormat, ...){\n      Clear();\n      // 格式化可变参数字符串信息\n      va_list params;\n      va_start(params, pFormat);\n      // 输出日志信息\n      TChar32 buffer[MO_FS_SPRINT_LENGTH];\n      vswprintf(buffer, MO_FS_SPRINT_LENGTH, pFormat, params);\n      Append(buffer);\n      va_end(params);\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个字符到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="TChar32" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(TChar32 value){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      this-&gt;_pMemory[this-&gt;_length++] = value;\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个字符串到当前字符串对象的末尾。" note="如果长度小于0，则自动计算指针的数据长度。">
                     <Parameters>
                        <Parameter type="TInt" name="length" default="-1"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(TChar32C* pValues, TInt length = -1){\n      if(length &lt; 0){\n         length = RTypes&lt;TChar32C&gt;::IndexOf(pValues, 0);\n      }\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + length + 1);\n      RTypes&lt;TChar32&gt;::Copy(this-&gt;_pMemory + this-&gt;_length, pValues, length);\n      this-&gt;_length += length;\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个字符串到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;TChar32&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MPtrC&lt;TChar32&gt;&amp; value){\n      if(!value.IsEmpty()){\n         Append(value.MemoryC(), value.Length());\n      }\n   }</Source>
                  </Method>
                  <Method name="AppendInt" description="追加一个数字到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="TInt" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendInt(TInt value){\n      TChar result[MO_FS_NUMBER_LENGTH];\n      Append(RRuntime::IntToString(value, result, MO_FS_NUMBER_LENGTH));\n   }</Source>
                  </Method>
                  <Method name="AppendRepeat" description="重复追加一个字符串到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendRepeat(TChar32C* pValue, TInt count){\n      for(TInt n=0; n&lt;count; n++){\n         Append(pValue);\n      }\n   }</Source>
                  </Method>
                  <Method name="AppendFormat" description="追加一个格式化字符串到对象尾部。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pFormat"/>
                        <Parameter type="pFormat," name="..."/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendFormat(TChar32C* pFormat, ...){\n      // 格式化可变参数字符串信息\n      va_list params;\n      va_start(params, pFormat);\n      // 输出日志信息\n      TChar32 buffer[MO_FS_SPRINT_LENGTH];\n      vswprintf(buffer, MO_FS_SPRINT_LENGTH, pFormat, params);\n      Append(buffer);\n   }</Source>
                  </Method>
                  <Method name="AppendFormat">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pFormat"/>
                        <Parameter type="va_list&amp;" name="params"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendFormat(TChar32C* pFormat, va_list&amp; params){\n      TChar32 buffer[MO_FS_SPRINT_LENGTH];\n      vswprintf(buffer, MO_FS_SPRINT_LENGTH, pFormat, params);\n      Append(buffer);\n   }</Source>
                  </Method>
                  <Method name="AppendLine" description="追加一个空行。">
                     <Return type="void"/>
                     <Source>\nvoid AppendLine(){\n      this-&gt;Append('\n');\n   }</Source>
                  </Method>
                  <Method name="Memory">
                     <Return type="TChar32*"/>
                     <Source>\nTChar32* Memory() const{\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="MemoryZ" description="获得一个末尾是空的字符串。">
                     <Return type="TChar32*"/>
                     <Source>\nTChar32* MemoryZ(){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="PtrZ" description="获得只读指针。">
                     <Return type="MString32PtrC"/>
                     <Source>\nMString32PtrC PtrZ(){\n      return TString32Ptr(this-&gt;_pMemory, this-&gt;_length, this-&gt;_size);\n   }</Source>
                  </Method>
                  <Method name="SetLength" description="设置字符串的长度。">
                     <Parameters>
                        <Parameter type="TUint" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid SetLength(TUint length){\n      InnerCast()-&gt;A::EnsureSize(length);\n      this-&gt;_length = length;\n   }</Source>
                  </Method>
                  <Method name="Fix" description="修正当前字符串内容。" note="如果字符串中含有0，则废弃后面的部分，并修正长度。如果字符串结尾处没有0，则自动添入0进行结尾。">
                     <Return type="void"/>
                     <Source>\nvoid Fix(){\n      for(TInt n=0; n&lt;this-&gt;_size; n++){\n         if(0 == this-&gt;_pMemory[n]){\n            this-&gt;_length = n;\n            return;\n         }\n      }\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n   }</Source>
                  </Method>
                  <Method name="ToLower" description="将内部字符串转换为小写。">
                     <Return type="void"/>
                     <Source>\nvoid ToLower(){\n      RChar32::ToLower(this-&gt;_pMemory, this-&gt;_length);\n   }</Source>
                  </Method>
                  <Method name="ToUpper" description="将内部字符串转换为大写。">
                     <Return type="void"/>
                     <Source>\nvoid ToUpper(){\n      RChar32::ToUpper(this-&gt;_pMemory, this-&gt;_length);\n   }</Source>
                  </Method>
                  <Method name="PadLeft">
                     <Parameters>
                        <Parameter type="TChar32" name="pad"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid PadLeft(TChar32 pad, TInt length){\n   }</Source>
                  </Method>
                  <Method name="PadRight">
                     <Parameters>
                        <Parameter type="TChar32" name="pad"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid PadRight(TChar32 pad, TInt length){\n      TInt count = length - this-&gt;_length;\n      for(TInt n=0; n&lt;count; n++){\n         this-&gt;_pMemory[this-&gt;_length++] = pad;\n      }\n   }</Source>
                  </Method>
                  <Method name="Replace" description="替换指定字符为另外字符。">
                     <Parameters>
                        <Parameter type="TChar32" name="source"/>
                        <Parameter type="TChar32" name="target"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt Replace(TChar32 source, TChar32 target){\n      TInt result = 0;\n      for(TInt n=0; n&lt;this-&gt;_length; n++){\n         if(source == this-&gt;_pMemory[n]){\n            this-&gt;_pMemory[n] = target;\n            result++;\n         }\n      }\n      return result;\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清除所有数据。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;_length = 0;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MString32C">
               <Inherits>
                  <Inherit name="MArrayC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Equals" description="判断当前字符串和指定字符串是否相等。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断当前字符串和指定字符串是否相等。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString32C::Equals(TChar32C* pValue) const{\n   return (0 == wcscmp(MemoryC(), pValue));\n}</Source>
                  </Method>
                  <Method name="EqualsIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串是否相等。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串是否相等。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString32C::EqualsIgnoreCase(TChar32C* pValue) const{\n   return (0 == wcscasecmp(MemoryC(), pValue));\n}</Source>
                  </Method>
                  <Method name="EqualsIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串是否相等。">
                     <Parameters>
                        <Parameter type="MString32PtrC&amp;" name="value" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串是否相等。&lt;/T&gt;\n//\n// @param value 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString32C::EqualsIgnoreCase(const MString32PtrC&amp; value) const{\n   return (0 == wcscasecmp(MemoryC(), value.MemoryC()));\n}</Source>
                  </Method>
                  <Method name="StartsWith" description="查找指定数组是否出现在当前数组的开始位置。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;查找指定数组是否出现在当前数组的开始位置。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString32C::StartsWith(TChar32C* pValue) const{\n   MO_ASSERT(pValue);\n   TInt length = wcslen(pValue);\n   return RTypes&lt;TChar32C&gt;::StartsWith(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="EndsWith" description="查找指定数组是否出现在当前数组的结束位置。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;查找指定数组是否出现在当前数组的结束位置。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString32C::EndsWith(TChar32C* pValue) const{\n   MO_ASSERT(pValue);\n   TInt length = wcslen(pValue);\n   return RTypes&lt;TChar32C&gt;::EndsWith(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="CompareIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串的大小。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TInt" description="&lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;">
                        <L value="value='等于0'&gt;当前字符串相等指定字符串"/>
                        <L value="value='大于0'&gt;当前字符串大于指定字符串"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串的大小。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;\n//         &lt;L value='等于0'&gt;当前字符串相等指定字符串&lt;/L&gt;\n//         &lt;L value='大于0'&gt;当前字符串大于指定字符串&lt;/L&gt;\n//============================================================\n\nTInt MString32C::CompareIgnoreCase(TChar32C* pValue) const{\n   return wcscasecmp(MemoryC(), pValue);\n}</Source>
                  </Method>
                  <Method name="CompareIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串的大小。">
                     <Parameters>
                        <Parameter type="MString32PtrC&amp;" name="value" description="指定字符串"/>
                     </Parameters>
                     <Return type="TInt" description="&lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;">
                        <L value="value='等于0'&gt;当前字符串相等指定字符串"/>
                        <L value="value='大于0'&gt;当前字符串大于指定字符串"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串的大小。&lt;/T&gt;\n//\n// @param value 指定字符串\n// @return &lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;\n//         &lt;L value='等于0'&gt;当前字符串相等指定字符串&lt;/L&gt;\n//         &lt;L value='大于0'&gt;当前字符串大于指定字符串&lt;/L&gt;\n//============================================================\n\nTInt MString32C::CompareIgnoreCase(const MString32PtrC&amp; value) const{\n   return wcscasecmp(MemoryC(), value.MemoryC());\n}</Source>
                  </Method>
                  <Method name="HashCode" description="计算当前字符串的哈希值。">
                     <Return type="THashCode" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;计算当前字符串的哈希值。&lt;/T&gt;\n//\n// @return 哈希值\n//============================================================\n\nTHashCode MString32C::HashCode() const{\n   return RTypes&lt;TChar32&gt;::MakeHashCode(this-&gt;_pMemory, this-&gt;_length);\n}</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MString32C::Find(TChar32C* pValue){\n   TInt length = wcslen(pValue);\n   return RTypes&lt;TChar32&gt;::Find(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                        <Parameter type="TInt" name="offset"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MString32C::Find(TChar32C* pValue, TInt offset){\n   MO_ASSERT_BETWEEN(offset, 0, this-&gt;_length);\n   TInt length = wcslen(pValue);\n   TInt result = RTypes&lt;TChar32&gt;::Find(this-&gt;_pMemory + offset, this-&gt;_length - offset, pValue, length);\n   return (ENotFound != result) ? offset + result : ENotFound;\n}</Source>
                  </Method>
                  <Method name="LastFind">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MString32C::LastFind(TChar32C* pValue){\n   TInt length = wcslen(pValue);\n   return RTypes&lt;TChar32&gt;::LastFind(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="TrimLeft" description="去掉左边的空白，返回字符串引用。">
                     <Return type="MString32PtrC" description="字符串引用"/>
                     <Source>//============================================================\n// &lt;T&gt;去掉左边的空白，返回字符串引用。&lt;/T&gt;\n//\n// @return 字符串引用\n//============================================================\n\nMString32PtrC MString32C::TrimLeft() const{\n   TInt position = 0;\n   TInt length = Length();\n   TChar32* pMemory = _pMemory;\n   while((position &lt; length) &amp;&amp; (pMemory[position] &lt;= ' ')){\n      position++;\n   }\n   return TString32Ptr(pMemory + position, length - position);\n}</Source>
                  </Method>
                  <Method name="TrimRight" description="去掉右边的空白，返回字符串引用。">
                     <Return type="MString32PtrC" description="字符串引用"/>
                     <Source>//============================================================\n// &lt;T&gt;去掉右边的空白，返回字符串引用。&lt;/T&gt;\n//\n// @return 字符串引用\n//============================================================\n\nMString32PtrC MString32C::TrimRight() const{\n   TInt position = Length() - 1;\n   TChar32* pMemory = _pMemory;\n   while((position &gt;= 0) &amp;&amp; (pMemory[position] &lt;= ' ')){\n      position--;\n   }\n   return TString32Ptr(pMemory, position);\n}</Source>
                  </Method>
                  <Method name="Trim" description="去掉两边的空白，返回字符串引用。">
                     <Return type="MString32PtrC" description="字符串引用"/>
                     <Source>//============================================================\n// &lt;T&gt;去掉两边的空白，返回字符串引用。&lt;/T&gt;\n//\n// @return 字符串引用\n//============================================================\n\nMString32PtrC MString32C::Trim() const{\n   TInt start = 0;\n   TInt length = Length();\n   TChar32* pMemory = _pMemory;\n   // 去掉左边空白字符\n   while((start &lt; length) &amp;&amp; (pMemory[start] &lt;= ' ')){\n      start++;\n   }\n   // 去掉右边空白字符\n   TInt end = length - 1;\n   while((end &gt;= 0) &amp;&amp; (pMemory[end] &lt;= ' ')){\n      end--;\n   }\n   return TString32Ptr(pMemory + start, end - start + 1);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MString32s">
               <Inherits>
                  <Inherit name="MString32sC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="+=">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="operator"/>
                  </Method>
                  <Method name="+=">
                     <Parameters>
                        <Parameter type="MString32sC&amp;" name="rhs"/>
                     </Parameters>
                     <Return type="operator"/>
                  </Method>
                  <Method name="-=">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="operator"/>
                  </Method>
                  <Method name="-=">
                     <Parameters>
                        <Parameter type="MString32sC&amp;" name="rhs"/>
                     </Parameters>
                     <Return type="operator"/>
                  </Method>
                  <Method name="EnsureSize">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Assign">
                     <Parameters>
                        <Parameter type="MString32sC&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="MString32sC&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="AppendSplit">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                        <Parameter type="TChar32" name="splitter"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="AppendSplit">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                        <Parameter type="TChar32C*" name="pSplitter"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Push">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="MString32sC&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Delete">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Split">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                        <Parameter type="TChar32" name="splitter"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Split">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                        <Parameter type="TChar32C*" name="pSplitter"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Clear">
                     <Return type="void"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="MString32sC">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="operator[]">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="TChar32C*"/>
                  </Method>
                  <Method name="IsEmpty">
                     <Return type="TBool"/>
                  </Method>
                  <Method name="Count">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="IteratorC">
                     <Return type="TString32sIteratorC"/>
                  </Method>
                  <Method name="First">
                     <Return type="TChar32C*"/>
                  </Method>
                  <Method name="Last">
                     <Return type="TChar32C*"/>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="TChar32C*"/>
                  </Method>
                  <Method name="IndexOf">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="FString32Vector*" name="_pStrings"/>
               </Attributes>
            </Class>
            <Class name="MString8">
               <Inherits>
                  <Inherit name="MString8C" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerCast" type="inline" description="获得内部类型指针。">
                     <Return type="A*"/>
                     <Source>\ninline A* InnerCast(){\n      return static_cast&lt;A*&gt;(this);\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="当前字符串上追加一个ANSI字符串。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(TChar8C* pValue){\n      Append(pValue);\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="当前字符串上追加一个ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;TChar8&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(const MPtrC&lt;TChar8&gt;&amp; value){\n      Append(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="TChar8*" description="获得数据指针">
                     <Return type="operator"/>
                     <Source>\noperator TChar8*(){\n      return _pMemory;\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接受一个字符串到当前字符串对象的末尾。" note="如果长度小于0，则自动计算指针的数据长度。">
                     <Parameters>
                        <Parameter type="TInt" name="length" default="-1"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(TChar8C* pValue, TInt length = -1){\n      Clear();\n      if(NULL != pValue){\n         Append(pValue, length);\n      }\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接受一个字符串到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;TChar8&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MPtrC&lt;TChar8&gt;&amp; value){\n      Clear();\n      if(!value.IsEmpty()){\n         Append(value.MemoryC(), value.Length());\n      }\n   }</Source>
                  </Method>
                  <Method name="AssignFormat" description="追加一个格式化字符串到对象尾部。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pFormat"/>
                        <Parameter type="pFormat," name="..."/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AssignFormat(TChar8C* pFormat, ...){\n      Clear();\n      // 格式化可变参数字符串信息\n      va_list params;\n      va_start(params, pFormat);\n      // 输出日志信息\n   #ifdef _WINDOWS\n      TInt length = _vscprintf(pFormat, params);\n      InnerCast()-&gt;A::EnsureSize(_length + length + 1);\n      length = vsprintf_s(_pMemory + _length, length + 1, pFormat, params);\n      this-&gt;_length += length;\n   #else\n      TChar buffer[MO_FS_SPRINT_LENGTH];\n      vsnprintf(buffer, MO_FS_SPRINT_LENGTH, pFormat, params);\n      Append(buffer);\n   #endif\n      va_end(params);\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个字符到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="TChar8" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(TChar8 value){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      this-&gt;_pMemory[this-&gt;_length++] = value;\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个字符串到当前字符串对象的末尾。" note="如果长度小于0，则自动计算指针的数据长度。">
                     <Parameters>
                        <Parameter type="TInt" name="length" default="-1"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(TChar8C* pValues, TInt length = -1){\n      if(length &lt; 0){\n         length = RTypes&lt;TChar8C&gt;::IndexOf(pValues, 0);\n      }\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + length + 1);\n      RTypes&lt;TChar8&gt;::Copy(this-&gt;_pMemory + this-&gt;_length, pValues, length);\n      this-&gt;_length += length;\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个字符串到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;TChar8&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MPtrC&lt;TChar8&gt;&amp; value){\n      if(!value.IsEmpty()){\n         Append(value.MemoryC(), value.Length());\n      }\n   }</Source>
                  </Method>
                  <Method name="AppendInt" description="追加一个数字到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="TInt" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendInt(TInt value){\n      TChar8 result[MO_FS_NUMBER_LENGTH];\n      Append(RRuntime::IntToString8(value, result, MO_FS_NUMBER_LENGTH));\n   }</Source>
                  </Method>
                  <Method name="AppendRepeat" description="重复追加一个字符串到当前字符串对象的末尾。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendRepeat(TChar8C* pValue, TInt count){\n      for(TInt n=0; n&lt;count; n++){\n         Append(pValue);\n      }\n   }</Source>
                  </Method>
                  <Method name="AppendFormat" description="追加一个格式化字符串到对象尾部。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pFormat"/>
                        <Parameter type="pFormat," name="..."/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendFormat(TChar8C* pFormat, ...){\n      // 格式化可变参数字符串信息\n      va_list params;\n      va_start(params, pFormat);\n      // 输出日志信息\n   #ifdef _WINDOWS\n      TInt length = _vscprintf(pFormat, params);\n      InnerCast()-&gt;A::EnsureSize(_length + length + 1);\n      length = vsprintf_s(_pMemory + _length, length + 1, pFormat, params);\n      this-&gt;_length += length;\n   #else\n      TChar buffer[MO_FS_SPRINT_LENGTH];\n      vsnprintf(buffer, MO_FS_SPRINT_LENGTH, pFormat, params);\n      Append(buffer);\n   #endif\n      va_end(params);\n   }</Source>
                  </Method>
                  <Method name="AppendFormat">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pFormat"/>
                        <Parameter type="va_list&amp;" name="params"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid AppendFormat(TChar8C* pFormat, va_list&amp; params){\n#ifdef _WINDOWS\n      TInt length = _vscprintf(pFormat, params);\n      InnerCast()-&gt;A::EnsureSize(_length + length + 1);\n      length = vsprintf_s(_pMemory + _length, length + 1, pFormat, params);\n      this-&gt;_length += length;\n#else\n      TChar buffer[MO_FS_SPRINT_LENGTH];\n      vsnprintf(buffer, MO_FS_SPRINT_LENGTH, pFormat, params);\n      Append(buffer);\n#endif\n   }</Source>
                  </Method>
                  <Method name="AppendLine" description="追加一个空行。">
                     <Return type="void"/>
                     <Source>\nvoid AppendLine(){\n      this-&gt;Append('\n');\n   }</Source>
                  </Method>
                  <Method name="Memory">
                     <Return type="TChar8*"/>
                     <Source>\nTChar8* Memory() const{\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="MemoryZ" description="获得一个末尾是空的字符串。">
                     <Return type="TChar8*"/>
                     <Source>\nTChar8* MemoryZ(){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="PtrZ" description="获得只读指针。">
                     <Return type="MString8PtrC"/>
                     <Source>\nMString8PtrC PtrZ(){\n      return TString8Ptr(this-&gt;_pMemory, this-&gt;_length, this-&gt;_size);\n   }</Source>
                  </Method>
                  <Method name="SetLength" description="设置字符串的长度。">
                     <Parameters>
                        <Parameter type="TUint" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid SetLength(TUint length){\n      InnerCast()-&gt;A::EnsureSize(length);\n      this-&gt;_length = length;\n   }</Source>
                  </Method>
                  <Method name="Fix" description="修正当前字符串内容。" note="如果字符串中含有0，则废弃后面的部分，并修正长度。如果字符串结尾处没有0，则自动添入0进行结尾。">
                     <Return type="void"/>
                     <Source>\nvoid Fix(){\n      for(TInt n=0; n&lt;this-&gt;_size; n++){\n         if(0 == this-&gt;_pMemory[n]){\n            this-&gt;_length = n;\n            return;\n         }\n      }\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_length + 1);\n      this-&gt;_pMemory[this-&gt;_length] = 0;\n   }</Source>
                  </Method>
                  <Method name="ToLower" description="将内部字符串转换为小写。">
                     <Return type="void"/>
                     <Source>\nvoid ToLower(){\n      RChar8::ToLower(this-&gt;_pMemory, this-&gt;_length);\n   }</Source>
                  </Method>
                  <Method name="ToUpper" description="将内部字符串转换为大写。">
                     <Return type="void"/>
                     <Source>\nvoid ToUpper(){\n      RChar8::ToUpper(this-&gt;_pMemory, this-&gt;_length);\n   }</Source>
                  </Method>
                  <Method name="PadLeft">
                     <Parameters>
                        <Parameter type="TChar8" name="pad"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid PadLeft(TChar8 pad, TInt length){\n   }</Source>
                  </Method>
                  <Method name="PadRight">
                     <Parameters>
                        <Parameter type="TChar8" name="pad"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid PadRight(TChar8 pad, TInt length){\n      TInt count = length - this-&gt;_length;\n      for(TInt n=0; n&lt;count; n++){\n         this-&gt;_pMemory[this-&gt;_length++] = pad;\n      }\n   }</Source>
                  </Method>
                  <Method name="Replace" description="替换指定字符为另外字符。">
                     <Parameters>
                        <Parameter type="TChar8" name="source"/>
                        <Parameter type="TChar8" name="target"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt Replace(TChar8 source, TChar8 target){\n      TInt result = 0;\n      for(TInt n=0; n&lt;this-&gt;_length; n++){\n         if(source == this-&gt;_pMemory[n]){\n            this-&gt;_pMemory[n] = target;\n            result++;\n         }\n      }\n      return result;\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清除所有数据。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;_length = 0;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MString8C">
               <Inherits>
                  <Inherit name="MArrayC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Equals" description="判断当前字符串和指定字符串是否相等。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断当前字符串和指定字符串是否相等。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString8C::Equals(TChar8C* pValue) const{\n   return (0 == strcmp(MemoryC(), pValue));\n}</Source>
                  </Method>
                  <Method name="EqualsIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串是否相等。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串是否相等。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString8C::EqualsIgnoreCase(TChar8C* pValue) const{\n   return (0 == strcmp(MemoryC(), pValue));\n}</Source>
                  </Method>
                  <Method name="EqualsIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串是否相等。">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="value" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串是否相等。&lt;/T&gt;\n//\n// @param value 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString8C::EqualsIgnoreCase(const MString8PtrC&amp; value) const{\n   return (0 == strcmp(MemoryC(), value.MemoryC()));\n}</Source>
                  </Method>
                  <Method name="StartsWith" description="查找指定数组是否出现在当前数组的开始位置。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;查找指定数组是否出现在当前数组的开始位置。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString8C::StartsWith(TChar8C* pValue) const{\n   MO_ASSERT(pValue);\n   TInt length = strlen(pValue);\n   return RTypes&lt;TChar8C&gt;::StartsWith(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="EndsWith" description="查找指定数组是否出现在当前数组的结束位置。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TBool" description="&lt;L value='ETrue'&gt;相等&lt;/L&gt;">
                        <L value="value='EFalse'&gt;不相等"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;查找指定数组是否出现在当前数组的结束位置。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='ETrue'&gt;相等&lt;/L&gt;\n//         &lt;L value='EFalse'&gt;不相等&lt;/L&gt;\n//============================================================\n\nTBool MString8C::EndsWith(TChar8C* pValue) const{\n   MO_ASSERT(pValue);\n   TInt length = strlen(pValue);\n   return RTypes&lt;TChar8C&gt;::EndsWith(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="CompareIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串的大小。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue" description="指定字符串"/>
                     </Parameters>
                     <Return type="TInt" description="&lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;">
                        <L value="value='等于0'&gt;当前字符串相等指定字符串"/>
                        <L value="value='大于0'&gt;当前字符串大于指定字符串"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串的大小。&lt;/T&gt;\n//\n// @param pValue 指定字符串\n// @return &lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;\n//         &lt;L value='等于0'&gt;当前字符串相等指定字符串&lt;/L&gt;\n//         &lt;L value='大于0'&gt;当前字符串大于指定字符串&lt;/L&gt;\n//============================================================\n\nTInt MString8C::CompareIgnoreCase(TChar8C* pValue) const{\n#ifdef _WINDOWS\n   return _stricmp(MemoryC(), pValue);\n#else\n   return strcasecmp(MemoryC(), pValue);\n#endif\n}</Source>
                  </Method>
                  <Method name="CompareIgnoreCase" description="不关心字符大小写，判断当前字符串和指定字符串的大小。">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="value" description="指定字符串"/>
                     </Parameters>
                     <Return type="TInt" description="&lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;">
                        <L value="value='等于0'&gt;当前字符串相等指定字符串"/>
                        <L value="value='大于0'&gt;当前字符串大于指定字符串"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;不关心字符大小写，判断当前字符串和指定字符串的大小。&lt;/T&gt;\n//\n// @param value 指定字符串\n// @return &lt;L value='小于0'&gt;当前字符串小于指定字符串&lt;/L&gt;\n//         &lt;L value='等于0'&gt;当前字符串相等指定字符串&lt;/L&gt;\n//         &lt;L value='大于0'&gt;当前字符串大于指定字符串&lt;/L&gt;\n//============================================================\n\nTInt MString8C::CompareIgnoreCase(const MString8PtrC&amp; value) const{\n#ifdef _WINDOWS\n   return _stricmp(MemoryC(), value.MemoryC());\n#else\n   return strcasecmp(MemoryC(), value.MemoryC());\n#endif\n}</Source>
                  </Method>
                  <Method name="HashCode" description="计算当前字符串的哈希值。">
                     <Return type="THashCode" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;计算当前字符串的哈希值。&lt;/T&gt;\n//\n// @return 哈希值\n//============================================================\n\nTHashCode MString8C::HashCode() const{\n   return RTypes&lt;TChar8&gt;::MakeHashCode(this-&gt;_pMemory, this-&gt;_length);\n}</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MString8C::Find(TChar8C* pValue){\n   TInt length = strlen(pValue);\n   return RTypes&lt;TChar8&gt;::Find(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                        <Parameter type="TInt" name="offset"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MString8C::Find(TChar8C* pValue, TInt offset){\n   MO_ASSERT_BETWEEN(offset, 0, this-&gt;_length);\n   TInt length = strlen(pValue);\n   TInt result = RTypes&lt;TChar8&gt;::Find(this-&gt;_pMemory + offset, this-&gt;_length - offset, pValue, length);\n   return (ENotFound != result) ? offset + result : ENotFound;\n}</Source>
                  </Method>
                  <Method name="LastFind">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt MString8C::LastFind(TChar8C* pValue){\n   TInt length = strlen(pValue);\n   return RTypes&lt;TChar8&gt;::LastFind(this-&gt;_pMemory, this-&gt;_length, pValue, length);\n}</Source>
                  </Method>
                  <Method name="TrimLeft" description="去掉左边的空白，返回字符串引用。">
                     <Return type="MString8PtrC" description="字符串引用"/>
                     <Source>//============================================================\n// &lt;T&gt;去掉左边的空白，返回字符串引用。&lt;/T&gt;\n//\n// @return 字符串引用\n//============================================================\n\nMString8PtrC MString8C::TrimLeft() const{\n   TInt position = 0;\n   TInt length = Length();\n   TChar8* pMemory = _pMemory;\n	while((position &lt; length) &amp;&amp; (pMemory[position] &lt;= ' ')){\n	    position++;\n	}\n	return TString8Ptr(pMemory + position, length - position);\n}</Source>
                  </Method>
                  <Method name="TrimRight" description="去掉右边的空白，返回字符串引用。">
                     <Return type="MString8PtrC" description="字符串引用"/>
                     <Source>//============================================================\n// &lt;T&gt;去掉右边的空白，返回字符串引用。&lt;/T&gt;\n//\n// @return 字符串引用\n//============================================================\n\nMString8PtrC MString8C::TrimRight() const{\n   TInt position = Length() - 1;\n   TChar8* pMemory = _pMemory;\n	while((position &gt;= 0) &amp;&amp; (pMemory[position] &lt;= ' ')){\n	    position--;\n	}\n	return TString8Ptr(pMemory, position);\n}</Source>
                  </Method>
                  <Method name="Trim" description="去掉两边的空白，返回字符串引用。">
                     <Return type="MString8PtrC" description="字符串引用"/>
                     <Source>//============================================================\n// &lt;T&gt;去掉两边的空白，返回字符串引用。&lt;/T&gt;\n//\n// @return 字符串引用\n//============================================================\n\nMString8PtrC MString8C::Trim() const{\n   TInt start = 0;\n   TInt length = Length();\n   TChar8* pMemory = _pMemory;\n   // 去掉左边空白字符\n	while((start &lt; length) &amp;&amp; (pMemory[start] &lt;= ' ')){\n	    start++;\n	}\n   // 去掉右边空白字符\n   TInt end = length - 1;\n	while((end &gt;= 0) &amp;&amp; (pMemory[end] &lt;= ' ')){\n	    end--;\n	}\n	return TString8Ptr(pMemory + start, end - start + 1);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MString8s">
               <Inherits>
                  <Inherit name="MString8sC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="MString8s"/>
                  <Destructor name="~MString8s"/>
                  <Method name="+=">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="MString8s::operator"/>
                     <Source>//============================================================\n\nvoid MString8s::operator +=(TChar8C* pValue){\n	Push(pValue);\n}</Source>
                  </Method>
                  <Method name="+=">
                     <Parameters>
                        <Parameter type="MString8sC&amp;" name="rhs"/>
                     </Parameters>
                     <Return type="MString8s::operator"/>
                     <Source>//============================================================\n\nvoid MString8s::operator +=(const MString8sC&amp; rhs){\n	TInt count = rhs.Count();\n	for(TInt i = 0; i &lt; count; i++){\n		Push(rhs[i]);\n	}\n}</Source>
                  </Method>
                  <Method name="-=">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="MString8s::operator"/>
                     <Source>//============================================================\n\nvoid MString8s::operator -=(TChar8C* pValue){\n	Remove(pValue);\n}</Source>
                  </Method>
                  <Method name="-=">
                     <Parameters>
                        <Parameter type="MString8sC&amp;" name="rhs"/>
                     </Parameters>
                     <Return type="MString8s::operator"/>
                     <Source>//============================================================\n\nvoid MString8s::operator -=(const MString8sC&amp; rhs){\n	Remove(rhs);\n}</Source>
                  </Method>
                  <Method name="EnsureSize">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MString8s::EnsureSize(TInt size){\n	 _pStrings-&gt;EnsureSize(size);\n }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MString8s::Set(TInt index, TCharC* pValue){\n	 MO_ASSERT_RANGE(index, 0, _count);\n	 _pStrings-&gt;Get(index)-&gt;Assign(pValue);\n }</Source>
                  </Method>
                  <Method name="Assign">
                     <Parameters>
                        <Parameter type="MString8sC&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MString8s::Assign(const MString8sC&amp; strings){\n	_pStrings-&gt;Clear();\n	TInt count = strings.Count();\n	for(TInt i = 0; i &lt; count; i++){\n		FString8* pString = MO_CREATE(FString8);\n		pString-&gt;Assign(strings[i]);\n		_pStrings-&gt;Push(pString);\n	}\n	_count = count;\n}</Source>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="MString8sC&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MString8s::Append(const MString8sC&amp; strings){\n	TInt count = strings.Count();\n	for(TInt i = 0; i &lt; count; i++){\n		Push(strings[i]);\n	}\n}</Source>
                  </Method>
                  <Method name="AppendSplit" description="将一个字符串按指定字符分割成多个字符串，并存入容器。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                        <Parameter type="TChar8" name="splitter" description="分割字符"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将一个字符串按指定字符分割成多个字符串，并存入容器。&lt;/T&gt;\n//\n// @param pValue被分割串\n// @param splitter 分割字符\n//============================================================\n\nvoid MString8s::AppendSplit(TChar8C* pValue, TChar8 splitter){\n   TString8Refer value(pValue);\n   TInt begin = 0;\n   TInt index = value.IndexOf(splitter, begin);\n   while(ENotFound != index){\n      Push(value.SubPtrC(begin, index));\n      begin = index + 1;\n      index = value.IndexOf(splitter, begin);\n   }\n}</Source>
                  </Method>
                  <Method name="AppendSplit" description="将一个字符串用指定字符串分割成多个字符串，并存入容器。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                        <Parameter type="TChar8C*" name="pSplitter" description="分割串"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将一个字符串用指定字符串分割成多个字符串，并存入容器。&lt;/T&gt;\n//\n// @param pValue被分割串\n// @param pSplitter 分割串\n//============================================================\n\nvoid MString8s::AppendSplit(TChar8C* pValue, TChar8C* pSplitter){\n   TInt length = strlen(pSplitter);\n   TString8Refer value(pValue);\n   // 上一个结束位置\n   TInt begin = 0 ;\n   TInt index = value.Find(pSplitter);\n   while(ENotFound != index){\n      Push(value.SubPtrC(begin, index));\n      begin = index + length;\n      index = value.Find(pSplitter, begin);\n   }\n}</Source>
                  </Method>
                  <Method name="Push">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MString8s::Push(TChar8C* pValue){\n	FString8* pString = _pStrings-&gt;Get(_count);\n	if(pString){\n		pString-&gt;Assign(pValue);\n	}else{\n		pString = MO_CREATE(FString8, pValue);\n		_pStrings-&gt;Push(pString);\n	}\n	++_count;\n}</Source>
                  </Method>
                  <Method name="Push">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MString8s::Push(const MString8PtrC&amp; value){\n	FString8* pString = _pStrings-&gt;Get(_count);\n	if(pString){\n		pString-&gt;Assign(value);\n	}else{\n		pString = MO_CREATE(FString8,  value);\n		_pStrings-&gt;Push(pString);\n	}\n	++_count;\n}</Source>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MString8s::Remove(TChar8C* pValue){\n	for(TInt n = 0; n &lt; _count; n++){\n		FString8* pString = _pStrings-&gt;Get(n);\n		if(pString-&gt;Equals(pValue)){\n			_pStrings-&gt;Delete(n);\n			--_count;\n			_pStrings-&gt;Push(pString);\n		}\n	}\n}</Source>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="MString8sC&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MString8s::Remove(const MString8sC&amp; strings){\n	TInt count = strings.Count();\n	for(TInt i = 0; i &lt; count; i++){\n		Remove(strings[i]);\n	}\n}</Source>
                  </Method>
                  <Method name="Delete">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MString8s::Delete(TInt index){\n	MO_ASSERT_RANGE(index, 0, _count);\n	FString8* pSting = _pStrings-&gt;Delete(index);\n	_pStrings-&gt;Push(pSting);\n	--_count;\n}</Source>
                  </Method>
                  <Method name="Split" description="将一个字符串按指定字符分割成多个字符串，并存入清空后的容器。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                        <Parameter type="TChar8" name="splitter" description="分割字符"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将一个字符串按指定字符分割成多个字符串，并存入清空后的容器。&lt;/T&gt;\n//\n// @param pValue被分割串\n// @param splitter 分割字符\n//============================================================\n\nvoid MString8s::Split(TChar8C* pValue, TChar8 splitter){\n   Clear();\n   AppendSplit(pValue, splitter);\n}</Source>
                  </Method>
                  <Method name="Split" description="将一个字符串按指定字符分割成多个字符串，并存入清空后的容器。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                        <Parameter type="TChar8C*" name="pSplitter"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将一个字符串按指定字符分割成多个字符串，并存入清空后的容器。&lt;/T&gt;\n//\n// @param pValue被分割串\n// @param splitter 分割字符串\n//============================================================\n\nvoid MString8s::Split(TChar8C* pValue, TChar8C* pSplitter){\n   Clear();\n   AppendSplit(pValue, pSplitter);\n}</Source>
                  </Method>
                  <Method name="Unpack">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pPack"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MString8s::Unpack(TChar8C* pPack){\n	TInt count = strlen(pPack);\n	TInt offset = 0;\n	while(offset &lt; count){\n		TInt valueLenLen = pPack[offset++] - 48;\n		MO_ASSERT(valueLenLen &gt; 0 &amp;&amp; valueLenLen &lt;= 9);\n		char buffer[16];\n		MO_LIB_MEMCPY(buffer, 16, pPack + offset, valueLenLen);\n		offset += valueLenLen;\n		buffer[valueLenLen] = 0;\n		TInt valueLen = RInt::Parse(buffer);\n		FString8* pString = MO_CREATE(FString8,  pPack + offset, valueLen);\n		offset += valueLen;\n	}\n}</Source>
                  </Method>
                  <Method name="Clear">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid MString8s::Clear(){\n	_pStrings-&gt;Clear();\n	_count = 0;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MString8sC">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="MString8sC"/>
                  <Destructor name="~MString8sC"/>
                  <Method name="Contains">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="TBool"/>
                  </Method>
                  <Method name="IndexOf">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="operator[]">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>\nTCharC* MString8sC::operator[](TInt index) const{\n	MO_ASSERT_RANGE(index, 0, _count);\n	FString8* pString = _pStrings-&gt;Get(index);\n	return pString-&gt;MemoryC();\n}</Source>
                  </Method>
                  <Method name="IsEmpty">
                     <Return type="TBool"/>
                     <Source>\nTBool MString8sC::IsEmpty() const{\n	return 0 == _count;\n}</Source>
                  </Method>
                  <Method name="Count">
                     <Return type="TInt"/>
                     <Source>\nTInt MString8sC::Count() const{\n	return _count;\n}</Source>
                  </Method>
                  <Method name="IteratorC">
                     <Return type="TString8sIteratorC"/>
                     <Source>\nTString8sIteratorC MString8sC::IteratorC() const{\n	//return TString8sIteratorC(_pStrings-&gt;MemoryC(), _count);\n   return TString8sIteratorC();\n}</Source>
                  </Method>
                  <Method name="First">
                     <Return type="TCharC*"/>
                     <Source>\nTCharC* MString8sC::First() const{\n	if( 0 == _count){\n		return NULL;\n	}\n	FString8* pString = _pStrings-&gt;Get(0);\n	return pString-&gt;MemoryC();\n}</Source>
                  </Method>
                  <Method name="Last">
                     <Return type="TCharC*"/>
                     <Source>\nTCharC* MString8sC::Last() const{\n	if(0 == _count){\n		return NULL;\n	}\n	FString8* pString = _pStrings-&gt;Get(_count - 1);\n	return pString-&gt;MemoryC();\n}</Source>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>\nTCharC* MString8sC::Get(TInt index) const{\n	MO_ASSERT_RANGE(index, 0, _count);\n	FString8* pString = _pStrings-&gt;Get(index);\n	return pString-&gt;MemoryC();\n}</Source>
                  </Method>
                  <Method name="IndexOf">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt MString8sC::IndexOf(TCharC* pValue) const{\n	for(TInt n = 0; n &lt; _count; n++){\n		if(_pStrings-&gt;Get(n)-&gt;Equals(pValue)){\n			return n;\n		}\n	}\n	return ENotFound;\n}</Source>
                  </Method>
                  <Method name="Join">
                     <Parameters>
                        <Parameter type="TChar8" name="splitter"/>
                     </Parameters>
                     <Return type="TString8"/>
                     <Source>\nTString8 MString8sC::Join(TChar8 splitter){\n	TString8 result;\n	for(TInt n = 0; n &lt; _count; n++){\n		if(n){\n			result.Append(splitter);\n		}\n		result.Append(_pStrings-&gt;Get(n)-&gt;MemoryC());\n	}\n	return result;\n}</Source>
                  </Method>
                  <Method name="Join">
                     <Parameters>
                        <Parameter type="TChar8C*" name="splitter"/>
                     </Parameters>
                     <Return type="TString8"/>
                     <Source>\nTString8 MString8sC::Join(TChar8C* splitter){\n	TString8 result;\n	for(TInt n = 0; n &lt; _count; n++){\n		if(n){\n			result.Append(splitter);\n		}\n		result.Append(_pStrings-&gt;Get(n)-&gt;MemoryC());\n	}\n	return result;\n}</Source>
                  </Method>
                  <Method name="Pack">
                     <Parameters>
                        <Parameter type="TChar8*" name="pPack"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt MString8sC::Pack(TChar8* pPack, TInt length){\n	TInt valueLen, valueLenLen, byteCount = 0;\n	FString8* pString;\n	for(TInt n = 0; n &lt; _count; n++){\n		pString = _pStrings-&gt;Get(n);\n		valueLen = pString-&gt;Length();\n		valueLenLen = RInt::CountDigit(valueLen);\n		if(pPack){\n			TChar8 buffer[16];\n			RRuntime::IntToString8(valueLenLen, buffer, 16);\n			pPack[byteCount++] = buffer[0];\n			RRuntime::IntToString8(valueLen, buffer, 16);\n			MO_LIB_MEMCPY(&amp;pPack[byteCount], length - byteCount, buffer, valueLenLen);\n			byteCount += valueLenLen;\n			MO_LIB_MEMCPY(&amp;pPack[byteCount], length - byteCount, pString-&gt;MemoryC(), valueLen);\n			byteCount += valueLen;\n		}else{\n			byteCount += (1 + valueLenLen + valueLen);\n		}\n	}\n	if(pPack){\n		pPack[byteCount] = 0;\n	}\n	return byteCount;\n}</Source>
                  </Method>
                  <Method name="Pack">
                     <Return type="TString8"/>
                     <Source>\nTString8 MString8sC::Pack(){\n	TString8 result;\n	TInt valueLen, valueLenLen;\n	FString8* pString;\n	for(TInt n = 0; n &lt; _count; n++){\n		pString = _pStrings-&gt;Get(n);\n		valueLen = pString-&gt;Length();\n		valueLenLen = RInt::CountDigit(valueLen);\n		TChar8 buffer[16];\n		result.Append(RRuntime::IntToString8(valueLenLen, buffer, 16));\n		result.Append(RRuntime::IntToString8(valueLen, buffer, 16));\n		result.Append(pString-&gt;MemoryC());\n	}\n	return result;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="FString8Vector*" name="_pStrings"/>
               </Attributes>
            </Class>
            <Class name="MTree">
               <Inherits>
                  <Inherit name="MTreeC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Initialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="level"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void Initialize(TInt level){\n      MTreeC&lt;N, V&gt;::Initialize(level);\n      this-&gt;_level = level;\n      this-&gt;_pRoot = EntryAlloc();\n   }</Source>
                  </Method>
                  <Method name="EntryAlloc">
                     <Return type="SEntry*"/>
                     <Source>\nSEntry* EntryAlloc(){\n      SEntry* pEntry = this-&gt;_pUnused;\n      if(NULL == pEntry){\n         pEntry = new SEntry();\n      }else{\n         this-&gt;_pUnused = pEntry-&gt;pNext;\n      }\n      pEntry-&gt;exists = EFalse;\n      EntryPush(pEntry);\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryRelease">
                     <Return type="void"/>
                     <Source>\nvoid EntryRelease(){\n      SEntry* pEntry = this-&gt;_pFirst;\n      while(NULL != pEntry){\n         // 释放当前节点\n         if(NULL != pEntry-&gt;ppNodes){\n            RTypeMemory&lt;SEntry*&gt;::Free(pEntry-&gt;ppNodes);\n         }\n         // 处理下一个节点\n         SEntry* pNext = pEntry-&gt;pNext;\n         delete pEntry;\n         pEntry = pNext;\n      }\n   }</Source>
                  </Method>
                  <Method name="Iterator" description="获得当前树的只读迭代器。">
                     <Return type="TIterator"/>
                     <Source>\nTIterator Iterator() const{\n      return TIterator(this-&gt;_pFirst);\n	}</Source>
                  </Method>
                  <Method name="Assign">
                     <Parameters>
                        <Parameter type="MTreeC&lt;N, V&gt;&amp;" name="tree"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MTreeC&lt;N, V&gt;&amp; tree){\n		Clear();\n      Append(tree);\n	}</Source>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="MTreeC&lt;N, V&gt;&amp;" name="tree"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MTreeC&lt;N, V&gt;&amp; tree){\n		TTreeIteratorC&lt;N, V&gt; iterator = tree.IteratorC();\n		while(iterator.Next()){\n         Set(iterator.Code(), iterator.Value());\n		}\n	}</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(N code, V value){\n      N find = code;\n      SEntry* pFind = this-&gt;_pRoot;\n      SEntry* pEntry = this-&gt;_pRoot;\n      // 循环查找\n      while(find &gt; 0){\n         TInt index = find % (1 &lt;&lt; this-&gt;_level);\n         find = find &gt;&gt; this-&gt;_level;\n         // 填充节点内部\n         if(NULL == pEntry-&gt;ppNodes){\n            pEntry-&gt;ppNodes = RTypeMemory&lt;SEntry*&gt;::Alloc(1 &lt;&lt; this-&gt;_level, 0);\n         }\n         // 增加存储节点\n         pFind = pEntry-&gt;ppNodes[index];\n         if(NULL == pFind){\n            pFind = EntryAlloc();\n            pEntry-&gt;ppNodes[index] = pFind;\n         }\n         pEntry = pFind;\n      }\n      // 设置数据内容\n      pFind-&gt;exists = ETrue;\n      pFind-&gt;code = code;\n      pFind-&gt;value = value;\n   }</Source>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Remove(N code){\n      SEntry* pEntry = EntryFind(code);\n      MO_ASSERT(pEntry);\n      // 不删除节点，将数据标志设置为空\n      pEntry-&gt;exists = EFalse;\n   }</Source>
                  </Method>
                  <Method name="Clear">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;EntryClear();\n      this-&gt;_pRoot = EntryAlloc();\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MTreeC">
               <Inherits>
                  <Inherit name="MLinkedEntryC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Initialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="level"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void Initialize(TInt level){\n      MO_ASSERT(level &gt; 1);\n      MLinkedC::Initialize();\n      _level = level;\n      _pRoot = NULL;\n   }</Source>
                  </Method>
                  <Method name="operator==" description="比较当前树内容和指定树所有代码和内容是否相等。">
                     <Parameters>
                        <Parameter type="MTreeC&lt;N, V&gt;&amp;" name="tree"/>
                     </Parameters>
                     <Return type="EBoolean"/>
                     <Source>\nEBoolean operator==(const MTreeC&lt;N, V&gt;&amp; tree) const{\n		return Equals(tree);\n	}</Source>
                  </Method>
                  <Method name="operator!=" description="比较当前树内容和指定树所有代码和内容是否不相等。">
                     <Parameters>
                        <Parameter type="MTreeC&lt;N, V&gt;&amp;" name="tree"/>
                     </Parameters>
                     <Return type="EBoolean"/>
                     <Source>\nEBoolean operator!=(const MTreeC&lt;N, V&gt;&amp; tree) const{\n		return !Equals(tree);\n	}</Source>
                  </Method>
                  <Method name="operator[]" type="inline">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="V"/>
                     <Source>\ninline V operator[](N code) const{\n      SEntry* pEntry = EntryFind(code);\n      MO_ASSERT(pEntry);\n      return pEntry-&gt;value;\n	}</Source>
                  </Method>
                  <Method name="EntryFind" type="inline">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryFind(N code) const{\n      // 获得指定位置数据\n      SEntry* pEntry = _pRoot;\n      while(code &gt; 0){\n         pEntry = pEntry-&gt;ppNodes[code % (1&lt;&lt;_level)];\n         if(NULL == pEntry){\n            return NULL;\n         }\n         code = code &gt;&gt; _level;\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="EntryClear" type="inline">
                     <Return type="void"/>
                     <Source>\ninline void EntryClear(){\n      // 清除所有节点，并查找到最后一个节点\n      SEntry* pEntry = this-&gt;_pFirst;\n      while(NULL != pEntry){\n         if(NULL != pEntry-&gt;ppNodes){\n            RTypes&lt;SEntry*&gt;::Clear(pEntry-&gt;ppNodes, 1 &lt;&lt; _level);\n         }\n         pEntry = pEntry-&gt;pNext;\n      }\n      // 将使用节点全部放入回收节点\n      MLinkedEntryC&lt;SEntry*&gt;::EntryClear();\n      // 清空内所有内容\n      _pRoot = NULL;\n   }</Source>
                  </Method>
                  <Method name="Level">
                     <Return type="TInt"/>
                     <Source>\nTInt Level() const{\n      return _level;\n   }</Source>
                  </Method>
                  <Method name="Constains" description="判断是否存在指定代码。">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Constains(N code) const{\n      SEntry* pEntry = EntryFind(code);\n      return (NULL != pEntry) ? pEntry-&gt;exists : EFalse;\n   }</Source>
                  </Method>
                  <Method name="Equals" description="比较当前树内容和指定树所有代码和内容是否相等。">
                     <Parameters>
                        <Parameter type="MTreeC&lt;N, V&gt;&amp;" name="tree"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Equals(const MTreeC&lt;N, V&gt;&amp; tree) const{\n      // 比较数量\n      if(this-&gt;_count == tree._count){\n         // 比较所有项目\n         TIteratorC iterator = tree.IteratorC();\n         while(iterator.Next()){\n            SEntry* pEntry = EntryFind(iterator.Code());\n            if(NULL == pEntry){\n               return EFalse;\n            }\n            if(pEntry-&gt;value != iterator.value){\n               return EFalse;\n            }\n         }\n         return ETrue;\n      }\n      return EFalse;\n	}</Source>
                  </Method>
                  <Method name="Get" description="获得指定代码的数据。">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="V"/>
                     <Source>\nV Get(N code) const{\n      SEntry* pEntry = EntryFind(code);\n      MO_ASSERT(pEntry);\n      MO_ASSERT(pEntry-&gt;exists);\n      return pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="IteratorC" description="获得当前树的只读迭代器。">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC IteratorC() const{\n      return TIteratorC(this-&gt;_pFirst);\n	}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_level"/>
                  <Attribute type="SEntry*" name="_pRoot"/>
               </Attributes>
            </Class>
            <Class name="MVector">
               <Inherits>
                  <Inherit name="MVectorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="InnerCast" type="inline" description="获得内部类型指针。">
                     <Return type="A*"/>
                     <Source>\ninline A* InnerCast(){\n      return static_cast&lt;A*&gt;(this);\n   }</Source>
                  </Method>
                  <Method name="operator[]" description="设置指定位置的数据内容。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T&amp;"/>
                     <Source>\nT&amp; operator[](TInt index){\n      MO_ASSERT_RANGE(index, 0, this-&gt;_count);\n      return this-&gt;_pMemory[index];\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="追加一个数据到当前数组尾部。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(T value){\n      Push(value);\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="追加一个数组到当前数组尾部。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(const MPtrC&lt;T&gt;&amp; ptr){\n      Append(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="operator+=" description="追加一个数组到当前数组尾部。">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(const MVectorC&lt;T&gt;&amp; values){\n      Append(values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="T*" description="获得数据内容">
                     <Return type="operator"/>
                     <Source>\noperator T*(){\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="Memory" description="获得数据指针。">
                     <Return type="T*"/>
                     <Source>\nT* Memory(){\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="Ptr" description="获取当前数组的指针对象。">
                     <Return type="TPtr&lt;T&gt;"/>
                     <Source>\nTPtr&lt;T&gt; Ptr() const{\n      return TPtr&lt;T&gt;(this-&gt;_pMemory, this-&gt;_count, this-&gt;_size);\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接受一个数组指针到当前数组尾部。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const T* pValues, TInt count){\n      MO_ASSERT(pValues);\n      InnerCast()-&gt;A::EnsureSize(count);\n      this-&gt;_count = count;\n      RTypes&lt;T&gt;::Copy(this-&gt;_pMemory, pValues, count);\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接受一个数组指针到当前数组尾部。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MPtrC&lt;T&gt;&amp; ptr){\n      Assign(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="Assign" description="接受一个数组指针到当前数组尾部。">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const MVectorC&lt;T&gt;&amp; values){\n      Assign(values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个数组指针到当前数组尾部。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const T* pValues, TInt count){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_count + count);\n      RTypes&lt;T&gt;::Copy(this-&gt;_pMemory + this-&gt;_count, pValues, count);\n      this-&gt;_count += count;\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个变长数组对象到当前数组尾部。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MPtrC&lt;T&gt;&amp; ptr){\n      Append(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="Append" description="追加一个变长数组对象到当前数组尾部。">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const MVectorC&lt;T&gt;&amp; values){\n      Append(values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="Insert" description="插入一个数据在指定位置。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Insert(TInt index, T value){\n      MO_ASSERT_BETWEEN(index, 0, this-&gt;_count);\n	   InnerCast()-&gt;A::EnsureSize(this-&gt;_count + 1);\n      RTypes&lt;T&gt;::Move(this-&gt;_pMemory + index + 1, this-&gt;_pMemory + index, this-&gt;_count - index);\n      this-&gt;_pMemory[index] = value;\n	   this-&gt;_count++;\n   }</Source>
                  </Method>
                  <Method name="Insert" description="插入一个数据指针在指定位置。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Insert(TInt index, const T* pValues, TInt count){\n      MO_ASSERT_BETWEEN(index, 0, this-&gt;_count);\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_count + count);\n      RTypes&lt;T&gt;::Move(this-&gt;_pMemory + index + count, this-&gt;_pMemory + index, this-&gt;_count - index);\n      RTypes&lt;T&gt;::Copy(this-&gt;_pMemory + index, pValues, count);\n      this-&gt;_count += count;\n   }</Source>
                  </Method>
                  <Method name="Insert" description="插入一个数组在指定位置。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Insert(TInt index, const MVectorC&lt;T&gt;&amp; values){\n      Insert(index, values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="Shift" description="从首部弹出一个数据。">
                     <Return type="T"/>
                     <Source>\nT Shift(){\n      MO_ASSERT(this-&gt;_count);\n      T value = this-&gt;_pMemory[0];\n      this-&gt;_count--;\n      if(this-&gt;_count &gt; 0){\n         RTypes&lt;T&gt;::Move(this-&gt;_pMemory, this-&gt;_pMemory + 1, this-&gt;_count);\n      }\n      return value;\n   }</Source>
                  </Method>
                  <Method name="Unshift" description="从首部压入一个数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Unshift(T value){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_count + 1);\n      if(this-&gt;_count &gt; 0){\n         RTypes&lt;T&gt;::Move(this-&gt;_pMemory + 1, this-&gt;_pMemory, this-&gt;_count);\n      }\n      this-&gt;_pMemory[0] = value;\n      this-&gt;_count++;\n   }</Source>
                  </Method>
                  <Method name="Pop" description="从尾部弹出一个数据。">
                     <Return type="T"/>
                     <Source>\nT Pop(){\n      MO_ASSERT(this-&gt;_count);\n      return this-&gt;_pMemory[--this-&gt;_count];\n   }</Source>
                  </Method>
                  <Method name="Push" description="追加一个数据到当前数组尾部。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Push(T value){\n      InnerCast()-&gt;A::EnsureSize(this-&gt;_count + 1);\n      this-&gt;_pMemory[this-&gt;_count++] = value;\n   }</Source>
                  </Method>
                  <Method name="Fill" description="使用指定内容填充当前数组。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Fill(T value){\n      RTypes&lt;T&gt;::Fill(this-&gt;_pMemory, this-&gt;_count, value);\n   }</Source>
                  </Method>
                  <Method name="Fill" description="使用指定内容和指定个数填充当前数组。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Fill(T value, TInt count){\n      MO_ASSERT_RANGE(count, 0, count)\n      RTypes&lt;T&gt;::Fill(this-&gt;_pMemory, count, value);\n   }</Source>
                  </Method>
                  <Method name="Fill" description="使用指定内容和指定个数从指定位置填充当前数组。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                        <Parameter type="TInt" name="offset"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Fill(T value, TInt offset, TInt count){\n      MO_ASSERT_RANGE(count, 0, this-&gt;_count - offset)\n      RTypes&lt;T&gt;::Fill(this-&gt;_pMemory + offset, count, value);\n   }</Source>
                  </Method>
                  <Method name="Replace" description="从源内容替换为目标内容。">
                     <Parameters>
                        <Parameter type="T" name="source"/>
                        <Parameter type="T" name="target"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Replace(T source, T target){\n      RTypes&lt;T&gt;::Replace(this-&gt;_pMemory, this-&gt;_count, source, target);\n   }</Source>
                  </Method>
                  <Method name="Replace" description="从源数组替换为目标数组。">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="source"/>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="target"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Replace(const MVectorC&lt;T&gt;&amp; source, const MVectorC&lt;T&gt;&amp; target){\n      TInt position = 0;\n      TInt pos = RTypes&lt;T&gt;::Find(this-&gt;_pMemory, this-&gt;_count, source.MemoryC(), source.Count());\n      if(ENotFound != pos){\n         TInt n = target.Count() - source.Count();\n         TInt max = MO_MAX(target.Count(), source.Count());\n         while(ENotFound != pos){\n            if(n &lt; 0){\n               position += pos + max;\n               RTypes&lt;T&gt;::Copy(this-&gt;_pMemory + position, target.MemoryC(), target.Count());\n               RTypes&lt;T&gt;::Move(this-&gt;_pMemory + position + source.Count(), this-&gt;_pMemory + position + target.Count(), this-&gt;_count - position - source.Count());\n            }else if(n &gt; 0){\n               InnerCast()-&gt;A::EnsureSize(this-&gt;_count + n);\n               RTypes&lt;T&gt;::Move(this-&gt;_pMemory + position + source.Count(), this-&gt;_pMemory + position + target.Count(), this-&gt;_count - position - source.Count());\n               RTypes&lt;T&gt;::Copy(this-&gt;_pMemory + position, target.MemoryC(), target.Count());\n            }\n            this-&gt;_count += n;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Swap" description="交换当前数组中两个位置的值。">
                     <Parameters>
                        <Parameter type="TInt" name="from"/>
                        <Parameter type="TInt" name="to"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Swap(TInt from, TInt to){\n      MO_ASSERT_RANGE(from, 0, this-&gt;_count);\n      MO_ASSERT_RANGE(to, 0, this-&gt;_count);\n      if(from != to){\n         T value = this-&gt;_pMemory[from];\n   	   this-&gt;_pMemory[from] = this-&gt;_pMemory[to];\n         this-&gt;_pMemory[to] = value;\n      }\n   }</Source>
                  </Method>
                  <Method name="Delete" description="删除指定位置的数据。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Delete(TInt index){\n      MO_ASSERT_RANGE(index, 0, this-&gt;_count);\n      T value = this-&gt;_pMemory[index];\n      if(index != this-&gt;_count - 1){\n         RTypes&lt;T&gt;::Move(this-&gt;_pMemory + index, this-&gt;_pMemory + index + 1, this-&gt;_count - index);\n      }\n      this-&gt;_count--;\n      return value;\n   }</Source>
                  </Method>
                  <Method name="Delete" description="删除指定位置起的长度的数据。" note="如果长度超过，则删除指定位置到结束位置之间的数据">
                     <Parameters>
                        <Parameter type="TInt" name="offset"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Delete(TInt offset, TInt count){\n      MO_ASSERT_RANGE(offset, 0, this-&gt;_count);\n      MO_ASSERT_RANGE(count, 0, this-&gt;_count - offset);\n      TInt last = this-&gt;_count - offset - count;\n      if(last &gt; 0){\n         RTypes&lt;T&gt;::Move(this-&gt;_pMemory + offset, this-&gt;_pMemory + offset + count, MO_MIN(last, count));\n      }\n      this-&gt;_count -= count;\n   }</Source>
                  </Method>
                  <Method name="Remove" description="移除指定数据。" note="可能会移除多个相同的数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Remove(T value){\n      TInt position = 0;\n      TInt n = -1;\n      while(++n &lt; this-&gt;_count){\n         if(this-&gt;_pMemory[n] != value){\n            this-&gt;_pMemory[position++] = this-&gt;_pMemory[n];\n         }\n      }\n      this-&gt;_count = position;\n   }</Source>
                  </Method>
                  <Method name="Set" description="设置指定索引位置的数据。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(TInt index, T value){\n      MO_ASSERT_RANGE(index, 0, this-&gt;_count);\n      this-&gt;_pMemory[index] = value;\n   }</Source>
                  </Method>
                  <Method name="SetCount" description="设置数据长度。">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid SetCount(TInt count){\n      InnerCast()-&gt;A::EnsureSize(count);\n      this-&gt;_count = count;\n   }</Source>
                  </Method>
                  <Method name="Sort" description="使用排序器对集合对象进行排序。">
                     <Parameters>
                        <Parameter type="IComparer&lt;T&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Sort(IComparer&lt;T&gt;* pComparer){\n      MO_ASSERT(pComparer)\n      if(this-&gt;_pMemory &amp;&amp; this-&gt;_count &gt; 1){\n         if(MO_COMPVEC_THRESHOLD &gt; this-&gt;_count){\n            RComparerSort&lt;T&gt;::InsertSort(this-&gt;_pMemory, 0, this-&gt;_count-1, pComparer);\n         }else{\n            RComparerSort&lt;T&gt;::QuickSort(this-&gt;_pMemory, 0, this-&gt;_count-1, pComparer);\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="BinarySearch" description="此函数只可在排序后调用。返回指定元素的位置。">
                     <Parameters>
                        <Parameter type="T" name="data"/>
                        <Parameter type="IComparer&lt;T&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt BinarySearch(T data, IComparer&lt;T&gt;* pComparer){\n      MO_ASSERT(pComparer)\n      if(this-&gt;_pMemory &amp;&amp; this-&gt;_count &gt; 0){\n         return RBinarySearch&lt;T&gt;::BinarySearch(\n               this-&gt;_pMemory, 0, this-&gt;_count-1, data, pComparer);\n      }\n      return ENotFound;\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清除所有数据。" note="注意本操作对数据不做任何处理，如果存储指针，一定要先自己释放。只是将长度置为空，可以重新放数据。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;_count = 0;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="MVectorC">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="MVectorC" description="内部初始化。"/>
                  <Method name="operator==">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator==(const MVectorC&lt;T&gt;&amp; values) const{\n      return RTypes&lt;T&gt;::Equals(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="operator!=">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator!=(const MVectorC&lt;T&gt;&amp; values) const{\n      return !RTypes&lt;T&gt;::Equals(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="operator&lt;">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator&lt;(const MVectorC&lt;T&gt;&amp; values) const{\n      return RTypes&lt;T&gt;::Compare(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count()) &lt; 0;\n   }</Source>
                  </Method>
                  <Method name="operator&gt;">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator&gt;(const MVectorC&lt;T&gt;&amp; values) const{\n      return RTypes&lt;T&gt;::Compare(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count()) &gt; 0;\n   }</Source>
                  </Method>
                  <Method name="operator&lt;=">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator&lt;=(const MVectorC&lt;T&gt;&amp; values) const{\n      return RTypes&lt;T&gt;::Compare(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count()) &lt;= 0;\n   }</Source>
                  </Method>
                  <Method name="operator&gt;=">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator&gt;=(const MVectorC&lt;T&gt;&amp; values) const{\n      return RTypes&lt;T&gt;::Compare(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count()) &gt;= 0;\n   }</Source>
                  </Method>
                  <Method name="T*" description="获得只读数据内容。">
                     <Return type="const"/>
                     <Source>\noperator const T*() const{\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="operator[]" description="获得指定位置的数据内容。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nconst T operator[](TInt index) const{\n      MO_ASSERT(_pMemory);\n      MO_ASSERT_RANGE(index, 0, this-&gt;_count);\n      return this-&gt;_pMemory[index];\n   }</Source>
                  </Method>
                  <Method name="IsEmpty" description="判断内容是否为空。">
                     <Return type="TBool"/>
                     <Source>\nTBool IsEmpty() const{\n      return (0 == _count);\n   }</Source>
                  </Method>
                  <Method name="PtrC" description="获得只读数据指针。">
                     <Return type="TPtrC&lt;T&gt;"/>
                     <Source>\nTPtrC&lt;T&gt; PtrC() const{\n      return TPtrC&lt;T&gt;(this-&gt;_pMemory, this-&gt;_count);\n   }</Source>
                  </Method>
                  <Method name="MemoryC" description="获得只读数据指针。">
                     <Return type="T*"/>
                     <Source>\nconst T* MemoryC() const{\n      return _pMemory;\n   }</Source>
                  </Method>
                  <Method name="Count" description="获得数据个数。">
                     <Return type="TInt"/>
                     <Source>\nTInt Count() const{\n      return _count;\n   }</Source>
                  </Method>
                  <Method name="Size" description="获得数据大小。">
                     <Return type="TInt"/>
                     <Source>\nTInt Size() const{\n      return _size;\n   }</Source>
                  </Method>
                  <Method name="Equals">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Equals(const MVectorC&lt;T&gt;&amp; values) const{\n      return RTypes&lt;T&gt;::Equals(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="StartsWith">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool StartsWith(const MVectorC&lt;T&gt;&amp; values) const{\n      return RTypes&lt;T&gt;::StartsWith(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="EndsWith">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool EndsWith(const MVectorC&lt;T&gt;&amp; values) const{\n      return RTypes&lt;T&gt;::EndsWith(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="Contains" description="从当前数组中是否含有指定数据。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Contains(T value) const{\n      TInt result = RTypes&lt;T&gt;::IndexOf(this-&gt;_pMemory, this-&gt;_count, value);\n      return (ENotFound != result);\n   }</Source>
                  </Method>
                  <Method name="Compare">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt Compare(const MVectorC&lt;T&gt;&amp; values) const{\n      return RTypes&lt;T&gt;::Compare(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="IndexOf">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt IndexOf(T value) const{\n      return RTypes&lt;T&gt;::IndexOf(this-&gt;_pMemory, this-&gt;_count, value);\n   }</Source>
                  </Method>
                  <Method name="IndexOf">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                        <Parameter type="TInt" name="offset"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt IndexOf(T value, TInt offset) const{\n      MO_ASSERT_RANGE(offset, 0, this-&gt;_count);\n      TInt find = RTypes&lt;T&gt;::IndexOf(this-&gt;_pMemory + offset, this-&gt;_count - offset, value);\n      return offset + find;\n   }</Source>
                  </Method>
                  <Method name="LastIndexOf">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt LastIndexOf(T value) const{\n      return RTypes&lt;T&gt;::LastIndexOf(this-&gt;_pMemory, this-&gt;_count, value);\n   }</Source>
                  </Method>
                  <Method name="LastIndexOf">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                        <Parameter type="TInt" name="offset"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt LastIndexOf(T value, TInt offset) const{\n      MO_ASSERT_RANGE(offset, 0, this-&gt;_count);\n      return RTypes&lt;T&gt;::LastIndexOf(this-&gt;_pMemory, offset, value);\n   }</Source>
                  </Method>
                  <Method name="IteratorC" description="获取只读迭代器。">
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC IteratorC(){\n      return TIteratorC(this-&gt;_pMemory, this-&gt;_count);\n   }</Source>
                  </Method>
                  <Method name="IteratorC" description="获取只读迭代器。">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="TIteratorC"/>
                     <Source>\nTIteratorC IteratorC(TInt index){\n      return TIteratorC(this-&gt;_pMemory + index, this-&gt;_count - index);\n   }</Source>
                  </Method>
                  <Method name="Get">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nT Get(TInt index) const{\n      MO_ASSERT_RANGE(index, 0, this-&gt;_count);\n      return this-&gt;_pMemory[index];\n   }</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="T*" name="pValue"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt Find(const T* pValue, TInt count) const{\n      return RTypes&lt;T&gt;::Find(this-&gt;_pMemory, this-&gt;_count, pValue, count);\n   }</Source>
                  </Method>
                  <Method name="Find">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt Find(const MVectorC&lt;T&gt;&amp; values) const{\n      return RTypes&lt;T&gt;::Find(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="LastFind">
                     <Parameters>
                        <Parameter type="T*" name="pValue"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt LastFind(const T* pValue, TInt count) const{\n      return RTypes&lt;T&gt;::LastFind(this-&gt;_pMemory, this-&gt;_count, pValue, count);\n   }</Source>
                  </Method>
                  <Method name="LastFind">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nTInt LastFind(const MVectorC&lt;T&gt;&amp; values) const{\n      return RTypes&lt;T&gt;::LastFind(this-&gt;_pMemory, this-&gt;_count, values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="LeftPtrC">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="TPtrC&lt;T&gt;"/>
                     <Source>\nTPtrC&lt;T&gt; LeftPtrC(TInt count) const{\n      MO_ASSERT_BETWEEN(count, 0, this-&gt;_count);\n      return TPtr&lt;T&gt;(this-&gt;_pMemory, count);\n   }</Source>
                  </Method>
                  <Method name="MidPtrC">
                     <Parameters>
                        <Parameter type="TInt" name="offset"/>
                     </Parameters>
                     <Return type="TPtrC&lt;T&gt;"/>
                     <Source>\nTPtrC&lt;T&gt; MidPtrC(TInt offset) const{\n      MO_ASSERT_BETWEEN(offset, 0, this-&gt;_count);\n      return TPtr&lt;T&gt;(this-&gt;_pMemory + offset, this-&gt;_count - offset);\n   }</Source>
                  </Method>
                  <Method name="MidPtrC">
                     <Parameters>
                        <Parameter type="TInt" name="offset"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TPtrC&lt;T&gt;"/>
                     <Source>\nTPtrC&lt;T&gt; MidPtrC(TInt offset, TInt length) const{\n      MO_ASSERT_BETWEEN(offset, 0, this-&gt;_count);\n      MO_ASSERT_BETWEEN(length, 0, this-&gt;_count - offset);\n      return TPtr&lt;T&gt;(this-&gt;_pMemory + offset, length);\n   }</Source>
                  </Method>
                  <Method name="RightPtrC">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="TPtrC&lt;T&gt;"/>
                     <Source>\nTPtrC&lt;T&gt; RightPtrC(TInt count) const{\n      MO_ASSERT_BETWEEN(count, 0, this-&gt;_count);\n      return TPtr&lt;T&gt;(this-&gt;_pMemory + (this-&gt;_count - count), count);\n   }</Source>
                  </Method>
                  <Method name="SubPtrC">
                     <Parameters>
                        <Parameter type="TInt" name="begin"/>
                        <Parameter type="TInt" name="end"/>
                     </Parameters>
                     <Return type="TPtrC&lt;T&gt;"/>
                     <Source>\nTPtrC&lt;T&gt; SubPtrC(TInt begin, TInt end) const{\n      MO_ASSERT_BETWEEN(begin, 0, this-&gt;_count);\n      MO_ASSERT_BETWEEN(end, 0, this-&gt;_count);\n      MO_ASSERT(begin &lt;= end);\n      return TPtr&lt;T&gt;(this-&gt;_pMemory + begin, end - begin);\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T*" name="_pMemory"/>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="TInt" name="_size"/>
               </Attributes>
            </Class>
            <Class name="RActivator">
               <Methods>
                  <Method name="Initialize" type="static" description="初始化资源。">
                     <Return type="void"/>
                     <Source>//============================================================\n\n//============================================================\n// &lt;T&gt;初始化资源。&lt;/T&gt;\n//============================================================\n\nvoid RActivator::Initialize(){\n}</Source>
                  </Method>
                  <Method name="Release" type="static" description="释放资源。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放资源。&lt;/T&gt;\n//============================================================\n\nvoid RActivator::Release(){\n}</Source>
                  </Method>
                  <Method name="Create" type="static" description="创建一个对象的实例。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pClassName" description="类名称"/>
                        <Parameter type="TInt" name="size" description="对象大小"/>
                        <Parameter type="TChar8C*" name="pFileName" description="编译文件"/>
                        <Parameter type="TInt" name="line" description="编译行数"/>
                     </Parameters>
                     <Return type="TAny*" description="对象实例指针"/>
                     <Source>//============================================================\n// &lt;T&gt;创建一个对象的实例。&lt;/T&gt;\n//\n// @param pClassName 类名称\n// @param size 对象大小\n// @param pFileName 编译文件\n// @param line 编译行数\n// @return 对象实例指针\n//============================================================\n\nTAny* RActivator::Create(TChar8C* pClassName, TInt size, TChar8C* pFileName, TInt line){\n   // 获得当前线程的陷阱接口\n   //FThreadTrap* pThreadTrap = RThread::Static().Console()-&gt;Current()-&gt;ThreadTrap();\n   //FTrap* pTrap = pThreadTrap-&gt;CurrentTrap();\n   // 收集指定大小的内存\n   //return pTrap-&gt;Alloc(pClassName, size, pFileName, line);\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="Remove" type="static" description="移除一个对象的实例。">
                     <Parameters>
                        <Parameter type="TAny*" name="pObject" description="对象实例指针"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;移除一个对象的实例。&lt;/T&gt;\n//\n// @param pObject 对象实例指针\n//============================================================\n\nvoid RActivator::Remove(TAny* pObject){\n   // 获得当前线程的陷阱接口\n   //FThreadTrap* pThreadTrap = RThread::Static().Console()-&gt;Current()-&gt;ThreadTrap();\n   //FTrap* pTrap = pThreadTrap-&gt;CurrentTrap();\n   // 释放指定大小的内存\n   //pTrap-&gt;Remove(pObject);\n}</Source>
                  </Method>
                  <Method name="Destroy" type="static" description="删除一个对象的实例。">
                     <Parameters>
                        <Parameter type="TAny*" name="pObject" description="对象实例指针"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;删除一个对象的实例。&lt;/T&gt;\n//\n// @param pObject 对象实例指针\n//============================================================\n\nvoid RActivator::Destroy(TAny* pObject){\n   // 获得当前线程的陷阱接口\n   //FTrap* pTrap = RTrap::Static().CurrentTrap();\n   // 释放指定大小的内存\n   //pTrap-&gt;Free(pObject);\n}</Source>
                  </Method>
                  <Method name="Lock" type="static" description="资源加锁。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;资源加锁。&lt;/T&gt;\n//============================================================\n\nvoid RActivator::Lock(){\n   _section.Enter();\n}</Source>
                  </Method>
                  <Method name="Unlock" type="static" description="资源解锁。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;资源解锁。&lt;/T&gt;\n//============================================================\n\nvoid RActivator::Unlock(){\n   _section.Leave();\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TThreadSection" name="_section"/>
               </Attributes>
            </Class>
            <Class name="RAllocator">
               <Methods>
                  <Method name="Create" type="static" description="构造内存收集器。">
                     <Return type="void"/>
                     <Source>//============================================================\n\n//============================================================\n// &lt;T&gt;构造内存收集器。&lt;/T&gt;\n//============================================================\n\nvoid RAllocator::Create(){\n   // 创建不定长内存收集器\n   _pMemoryAllocator = MO_PTR_CREATE(FMemoryLockAllocator);\n   // 创建块内存列表\n   _pBlockAllocatorSet = MO_PTR_CREATE(FBlockAllocatorSet);\n   // 创建块内存列表\n   _pBlockAllocators = MO_PTR_CREATE(FBlockAllocatorList);\n   // 创建加锁块内存列表\n   _pBlockLockAllocators = MO_PTR_CREATE(FBlockLockAllocatorList);\n}</Source>
                  </Method>
                  <Method name="Destroy" type="static" description="释放内存收集器。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放内存收集器。&lt;/T&gt;\n//============================================================\n\nvoid RAllocator::Destroy(){\n   // 释放所有加锁块内存列表\n   if(!_pBlockLockAllocators-&gt;IsEmpty()){\n      TListIterator&lt;FBlockLockAllocator*&gt; iterator = _pBlockLockAllocators-&gt;IteratorC();\n      while(iterator.Next()){\n         FBlockLockAllocator* pBlockLockAllocator = iterator.Get();\n         MO_PTR_DELETE(pBlockLockAllocator);\n      }\n   }\n   MO_PTR_DELETE(_pBlockLockAllocators);\n   // 释放所有块内存列表\n   if(!_pBlockAllocatorSet-&gt;IsEmpty()){\n      TSetIterator&lt;TUint, FBlockAllocator*&gt; iterator = _pBlockAllocatorSet-&gt;IteratorC();\n      while(iterator.Next()){\n         FBlockAllocator* pBlockAllocator = iterator.Value();\n         MO_PTR_DELETE(pBlockAllocator);\n      }\n   }\n   MO_PTR_DELETE(_pBlockAllocatorSet);\n   // 释放所有块内存列表\n   if(!_pBlockAllocators-&gt;IsEmpty()){\n      TListIterator&lt;FBlockAllocator*&gt; iterator = _pBlockAllocators-&gt;IteratorC();\n      while(iterator.Next()){\n         FBlockAllocator* pBlockAllocator = iterator.Get();\n         MO_PTR_DELETE(pBlockAllocator);\n      }\n   }\n   MO_PTR_DELETE(_pBlockAllocators);\n   // 释放不定长内存收集器\n   MO_PTR_DELETE(_pMemoryAllocator);\n}</Source>
                  </Method>
                  <Method name="Alloc" type="static" description="收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TUint" name="size" description="内存大小"/>
                     </Parameters>
                     <Return type="TAny*" description="内存指针"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param size 内存大小\n// @return 内存指针\n//============================================================\n\nTAny* RAllocator::Alloc(TUint size){\n   return malloc(size);\n   //return _pMemoryAllocator-&gt;Alloc(size);\n};</Source>
                  </Method>
                  <Method name="Alloc" type="static" description="收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pTypeName" description="类型名称"/>
                        <Parameter type="TUint" name="size" description="内存大小"/>
                        <Parameter type="TChar8C*" name="pFileName" description="文件名称"/>
                        <Parameter type="TInt" name="line" description="文件行数"/>
                     </Parameters>
                     <Return type="TAny*" description="内存指针"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param pTypeName 类型名称\n// @param size 内存大小\n// @param pFileName 文件名称\n// @param line 文件行数\n// @return 内存指针\n//============================================================\n\nTAny* RAllocator::Alloc(TCharC* pTypeName, TUint size, TChar8C* pFileName, TInt line){\n   return malloc(size);\n   //return _pMemoryAllocator-&gt;Alloc(pTypeName, size, pFileName, line);\n};</Source>
                  </Method>
                  <Method name="TypeAlloc" type="static" description="收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TUint" name="size" description="内存大小"/>
                     </Parameters>
                     <Return type="TAny*" description="内存指针"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param size 内存大小\n// @return 内存指针\n//============================================================\n\nTAny* RAllocator::TypeAlloc(TUint size){\n   return malloc(size);\n   /*_section.Enter();</Source>
                  </Method>
                  <Method name="TypeAlloc" type="static" description="收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pTypeName" description="类型名称"/>
                        <Parameter type="TUint" name="size" description="内存大小"/>
                        <Parameter type="TChar8C*" name="pFileName" description="文件名称"/>
                        <Parameter type="TInt" name="line" description="文件行数"/>
                     </Parameters>
                     <Return type="TAny*" description="内存指针"/>
                     <Source>//============================================================\n// &lt;T&gt;收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param pTypeName 类型名称\n// @param size 内存大小\n// @param pFileName 文件名称\n// @param line 文件行数\n// @return 内存指针\n//============================================================\n\nTAny* RAllocator::TypeAlloc(TCharC* pTypeName, TUint size, TChar8C* pFileName, TInt line){\n   return malloc(size);\n   /*_section.Enter();</Source>
                  </Method>
                  <Method name="Free" type="static" description="释放内存。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory" description="内存指针"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放内存。&lt;/T&gt;\n//\n// @param pMemory 内存指针\n//============================================================\n\nvoid RAllocator::Free(TAny* pMemory){\n   MO_ASSERT(pMemory);\n   free(pMemory);\n   /*// 获得当前使用的实例\n   SMemoryEntry* pAtom = (SMemoryEntry*)pAlloc[0];\n   // 检查内存转换正确性\n   MO_ASSERT(pAtom-&gt;pMemory == pMemory);\n   // 释放类型内存块\n   pAtom-&gt;pAllocator-&gt;Free(pMemory);*/\n}</Source>
                  </Method>
                  <Method name="BlockAllocatorAlloc" type="static">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="FBlockAllocator*"/>
                     <Source>//============================================================\n\nFBlockAllocator* RAllocator::BlockAllocatorAlloc(TInt size){\n   FBlockAllocator* pAllocator = MO_PTR_CREATE(FBlockAllocator, size);\n   _section.Enter();\n   _pBlockAllocators-&gt;Push(pAllocator);\n   _section.Leave();\n   return pAllocator;\n}</Source>
                  </Method>
                  <Method name="BlockAllocatorFree" type="static">
                     <Parameters>
                        <Parameter type="FBlockAllocator*" name="pAllocator"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid RAllocator::BlockAllocatorFree(FBlockAllocator* pAllocator){\n   MO_ASSERT(pAllocator);\n   _section.Enter();\n   _pBlockAllocators-&gt;Remove(pAllocator);\n   _section.Leave();\n   MO_PTR_DELETE(pAllocator);\n}</Source>
                  </Method>
                  <Method name="BlockLockAllocatorAlloc" type="static">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="FBlockLockAllocator*"/>
                     <Source>//============================================================\n\nFBlockLockAllocator* RAllocator::BlockLockAllocatorAlloc(TInt size){\n   FBlockLockAllocator* pAllocator = MO_PTR_CREATE(FBlockLockAllocator, size);\n   _section.Enter();\n   _pBlockLockAllocators-&gt;Push(pAllocator);\n   _section.Leave();\n   return pAllocator;\n}</Source>
                  </Method>
                  <Method name="BlockLockAllocatorFree" type="static">
                     <Parameters>
                        <Parameter type="FBlockLockAllocator*" name="pAllocator"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid RAllocator::BlockLockAllocatorFree(FBlockLockAllocator* pAllocator){\n   MO_ASSERT(pAllocator);\n   _section.Enter();\n   _pBlockLockAllocators-&gt;Remove(pAllocator);\n   _section.Leave();\n   MO_PTR_DELETE(pAllocator);\n}</Source>
                  </Method>
                  <Method name="CalculateStatistics" type="static">
                     <Parameters>
                        <Parameter type="TUint&amp;" name="used"/>
                        <Parameter type="TUint&amp;" name="total"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool RAllocator::CalculateStatistics(TUint&amp; used, TUint&amp; total){\n   used = 0;\n   total = 0;\n   // 非加锁内存运行信息\n   if(!_pBlockAllocators-&gt;IsEmpty()){\n      TListIteratorC&lt;FBlockAllocator*&gt; iterator = _pBlockAllocators-&gt;IteratorC();\n      while(iterator.Next()){\n         FBlockAllocator* pAllocator = iterator.Get();\n         used += pAllocator-&gt;GetMemoryUsed();\n         total += pAllocator-&gt;GetMemoryTotal();\n      }\n   }\n   // 加锁内存运行信息\n   if(!_pBlockLockAllocators-&gt;IsEmpty()){\n      TListIteratorC&lt;FBlockLockAllocator*&gt; iterator = _pBlockLockAllocators-&gt;IteratorC();\n      while(iterator.Next()){\n         FBlockLockAllocator* pAllocator = iterator.Get();\n         used += pAllocator-&gt;GetMemoryUsed();\n         total += pAllocator-&gt;GetMemoryTotal();\n      }\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="DumpTrack" type="static">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid RAllocator::DumpTrack(){\n   TInt memoryUsed = 0;\n   TInt memoryTotal = 0;\n   //MO_STATIC_TRACK(&quot;-- Track memory - %s --------------------------------------&quot;, &quot;begin&quot;);\n   // 非加锁内存运行信息\n   if(!_pBlockAllocators-&gt;IsEmpty()){\n      TListIteratorC&lt;FBlockAllocator*&gt; iterator = _pBlockAllocators-&gt;IteratorC();\n      while(iterator.Next()){\n         FBlockAllocator* pAllocator = iterator.Get();\n         memoryUsed += pAllocator-&gt;GetMemoryUsed();\n         memoryTotal += pAllocator-&gt;GetMemoryTotal();\n         pAllocator-&gt;DumpTrack();\n      }\n   }\n   // 加锁内存运行信息\n   if(!_pBlockLockAllocators-&gt;IsEmpty()){\n      TListIteratorC&lt;FBlockLockAllocator*&gt; iterator = _pBlockLockAllocators-&gt;IteratorC();\n      while(iterator.Next()){\n         FBlockLockAllocator* pAllocator = iterator.Get();\n         memoryUsed += pAllocator-&gt;GetMemoryUsed();\n         memoryTotal += pAllocator-&gt;GetMemoryTotal();\n         pAllocator-&gt;DumpTrack();\n      }\n   }\n   //MO_STATIC_TRACK(&quot;-- Track memory - end -- used=0x%08X, total=0x%08X ------------------&quot;, memoryUsed, memoryTotal);\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TThreadSection" name="_section"/>
                  <Attribute type="FMemoryAllocator*" name="_pMemoryAllocator"/>
                  <Attribute type="FBlockAllocatorSet*" name="_pBlockAllocatorSet"/>
                  <Attribute type="FBlockAllocatorList*" name="_pBlockAllocators"/>
                  <Attribute type="FBlockLockAllocatorList*" name="_pBlockLockAllocators"/>
               </Attributes>
            </Class>
            <Class name="RApplication">
               <Inherits>
                  <Inherit name="RSingleton" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="CatchUsr1" type="static">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="GetArgument" type="static">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RApplication::GetArgument(TInt index){\n   return _pInstance-&gt;GetArgument(index);\n}</Source>
                  </Method>
                  <Method name="FindArgument" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RApplication::FindArgument(TCharC* pName){\n   return _pInstance-&gt;FindArgument(pName);\n}</Source>
                  </Method>
                  <Method name="Hinstance" type="static" description="获得当前应用程序的句柄。">
                     <Return type="TInstance"/>
                     <Source>//============================================================\n// &lt;T&gt;获得当前应用程序的句柄。&lt;/T&gt;\n//\n// @history 100424 MAOCY 创建\n//============================================================\n\nTInstance RApplication::Hinstance(){\n   return _pInstance-&gt;Hinstance();\n}</Source>
                  </Method>
                  <Method name="CommandShow" type="static">
                     <Return type="TInt"/>
                     <Source>//============================================================\n\nTInt RApplication::CommandShow(){\n   return _pInstance-&gt;CommandShow();\n}</Source>
                  </Method>
                  <Method name="GetCurrentDirectory" type="static" description="获得系统当前路径">
                     <Return type="TFsPath" description="系统当前路径"/>
                     <Source>//============================================================\n// &lt;T&gt;获得系统当前路径&lt;/T&gt;\n//\n// @return 系统当前路径\n//============================================================\n\nTFsPath RApplication::GetCurrentDirectory(){\n   TFsPath path;\n#ifdef _WINDOWS\n   ::GetCurrentDirectory(path.Size(), path.Memory());\n#else\n   TChar* pResult = getcwd(path.Memory(), path.Size());\n   MO_ASSERT(pResult);\n#endif\n   path.Fix();\n   return path;\n}</Source>
                  </Method>
                  <Method name="GetExecuteDirectory" type="static" description="获得可执行文件的当前路径。">
                     <Return type="TFsPath" description="当前路径"/>
                     <Source>//============================================================\n// &lt;T&gt;获得可执行文件的当前路径。&lt;/T&gt;\n//\n// @return 当前路径\n//============================================================\n\nTFsPath RApplication::GetExecuteDirectory(){\n   TFsPath path;\n#ifdef _WINDOWS\n   // TODO:\n#else\n   TInt length = readlink(&quot;//proc/self/exe&quot;, path.Memory(), path.Size());\n   MO_ASSERT(length &lt; path.Size());\n   path.SetLength(length);\n#endif\n   return path;\n}</Source>
                  </Method>
                  <Method name="CatchSegmentFault" type="static" description="拦截无效内存错误。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;拦截无效内存错误。&lt;/T&gt;\n//\n// @history 100412 MAOCY 创建\n//============================================================\n\nTInt RApplication::CatchSegmentFault(){\n   return _pInstance-&gt;CatchSegmentFault();\n}</Source>
                  </Method>
                  <Method name="CatchInterrupt" type="static" description="捕获中断信号。">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;捕获中断信号。&lt;/T&gt;\n//\n//============================================================\n\nTInt RApplication::CatchInterrupt(){\n   return _pInstance-&gt;CatchInterrupt();\n}</Source>
                  </Method>
                  <Method name="InstallDaemon" type="static" description="获得可执行文件的当前路径。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;获得可执行文件的当前路径。&lt;/T&gt;\n//\n// @history 100302 MAOCY 创建\n//============================================================\n\nvoid RApplication::InstallDaemon(){\n   return _pInstance-&gt;InstallDaemon();\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RBinarySearch">
               <Methods>
                  <Method name="BinarySearch" type="static" description="查找已序数组中的元素。">
                     <Parameters>
                        <Parameter type="T" name="*pMemory"/>
                        <Parameter type="TInt" name="b"/>
                        <Parameter type="TInt" name="e"/>
                        <Parameter type="T" name="data"/>
                        <Parameter type="IComparer&lt;T&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nstatic TInt BinarySearch(T *pMemory, TInt b, TInt e, T data, IComparer&lt;T&gt;* pComparer){\n      if(b &lt; e) {\n         TInt pvt = (b + e) / 2;\n         TInt ret = pComparer-&gt;Compare(pMemory[pvt], data);\n         if(ret &gt; 0) {\n            return BinarySearch(pMemory, b, pvt-1, data, pComparer);\n         } else if(ret &lt; 0) {\n            return BinarySearch(pMemory, pvt+1, e, data, pComparer);\n         } else {\n            return pvt;\n         }\n      } else if(b == e) {\n         if(pComparer-&gt;Compare(pMemory[b], data) == 0)\n            return b;\n      }\n      return ENotFound;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RBool">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static" description="将字符变换为布尔值。">
                     <Parameters>
                        <Parameter type="TChar" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool" description="布尔值"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符变换为布尔值。&lt;/T&gt;\n//\n// @param value 字符\n// @return 布尔值\n//============================================================\n\nTBool RBool::Parse(TChar value){\n   return (MO_BOOL_TRUE_CHAR == value);\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static" description="将字符串变换为布尔值。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TBool" description="布尔值"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为布尔值。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 布尔值\n//============================================================\n\nTBool RBool::ParseNvl(TCharC* pValue){\n   if(NULL != pValue){\n      if(0 == strcmp(&quot;Y&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;YES&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;y&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;yes&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;1&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;T&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;true&quot;, pValue)){\n         return ETrue;\n      }\n   }\n   return EFalse;\n}</Source>
                  </Method>
                  <Method name="IsTrue" type="static" description="将字符串变换为布尔值。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TBool" description="布尔值"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为布尔值。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 布尔值\n//============================================================\n\nTBool RBool::IsTrue(TCharC* pValue){\n   if(NULL != pValue){\n      if(0 == strcmp(&quot;Y&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;YES&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;y&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;yes&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;1&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;T&quot;, pValue)){\n         return ETrue;\n      }else if(0 == strcmp(&quot;true&quot;, pValue)){\n         return ETrue;\n      }\n   }\n   return EFalse;\n}</Source>
                  </Method>
                  <Method name="ToChar" type="static" description="将布尔值变换为字符。">
                     <Parameters>
                        <Parameter type="TBool" name="value" description="布尔值"/>
                     </Parameters>
                     <Return type="TChar" description="字符"/>
                     <Source>//============================================================\n// &lt;T&gt;将布尔值变换为字符。&lt;/T&gt;\n//\n// @param value 布尔值\n// @return 字符\n//============================================================\n\nTChar RBool::ToChar(TBool value){\n   return value ? MO_BOOL_TRUE_CHAR : MO_BOOL_FALSE_CHAR;\n}</Source>
                  </Method>
                  <Method name="ToString" type="static" description="将布尔值变换为字符串。">
                     <Parameters>
                        <Parameter type="TBool" name="value" description="布尔值"/>
                     </Parameters>
                     <Return type="TCharC*" description="字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;将布尔值变换为字符串。&lt;/T&gt;\n//\n// @param value 布尔值\n// @return 字符串\n//============================================================\n\nTCharC* RBool::ToString(TBool value){\n   return value ? MO_BOOL_TRUE_STR : MO_BOOL_FALSE_STR;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RByte">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Format" type="static">
                     <Parameters>
                        <Parameter type="TByteC*" name="pBytes"/>
                        <Parameter type="TInt" name="count"/>
                        <Parameter type="TChar*" name="pResult"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TChar*"/>
                     <Source>//============================================================\n\n//============================================================\n\nTChar* RByte::Format(TByteC* pBytes, TInt count, TChar* pResult, TInt length){\n   TInt n = -1;\n   TChar* pWrite = pResult;\n   while(++n &lt; count){\n      TUbyte byte = pBytes[n];\n      // 写入空字符\n      if(n &gt; 0){\n         *pWrite++ = ' ';\n         if(--length &lt; 1){\n            break;\n         }\n      }\n      // 写入高字节\n      *pWrite++ = HEX_CHARS[byte &gt;&gt; 4];\n      if(--length &lt; 1){\n         break;\n      }\n      // 写入低字节\n      *pWrite++ = HEX_CHARS[byte &amp; 0x0F];\n      if(--length &lt; 1){\n         break;\n      }\n   }\n   // 写入结尾\n   *pWrite = 0;\n   // 返回结果\n   return pResult;\n}</Source>
                  </Method>
                  <Method name="FormatMemory" type="static" description="字节流格式化。" note="输出格式：地址: 十六进制数据 文本">
                     <Parameters>
                        <Parameter type="TByteC*" name="pBytes" description="输入字节流首地址"/>
                        <Parameter type="TInt" name="count" description="输入字节流的长度"/>
                        <Parameter type="TInt" name="columns" description="显示的列数"/>
                        <Parameter type="TChar*" name="pResult" description="结果字符串缓存"/>
                        <Parameter type="TInt" name="length" description="结果字符串缓存长度"/>
                     </Parameters>
                     <Return type="TChar*" description="格式化后的字符串指针"/>
                     <Source>//============================================================\n// &lt;T&gt;字节流格式化。&lt;/T&gt;\n//\n// &lt;P&gt;输出格式：地址: 十六进制数据 文本&lt;/P&gt;\n// @param pBytes 输入字节流首地址\n// @param count 输入字节流的长度\n// @param columns 显示的列数\n// @param pResult 结果字符串缓存\n// @param length  结果字符串缓存长度\n// @return 格式化后的字符串指针\n//============================================================\n\nTChar* RByte::FormatMemory(TByteC* pBytes, TInt count, TInt columns, TChar* pResult, TInt length){\n   TInt index = 0;\n   TInt position = 0;\n   TInt size = 18 + (4 * columns) + 4;\n   while(length &gt; size + 4){\n      MO_LIB_SPRINTF(pResult + position, length - position, &quot; - 0x%04&quot; MO_FMT_HEX &quot;(% 6&quot; MO_FMT_INT &quot;):&quot;, index, index);\n      TChar* pWrite = pResult + position + 18;\n      TChar* pChars = pWrite + (3 * columns);\n      *pChars++ = ' ';\n      *pChars++ = '[';\n      for(int n = 0; n &lt; columns; n++){\n         *pWrite++ = ' ';\n         if(index &lt; count){\n            TChar ch = pBytes[index++];\n            TInt byte = (ch &gt;= 0) ? ch : 0x100 + ch;\n            *pWrite++ = HEX_CHARS[byte &gt;&gt; 4];\n            *pWrite++ = HEX_CHARS[byte &amp; 0x0F];\n            *pChars++ = (byte &gt;= 32 &amp;&amp; byte &lt; 127 ) ? byte : '.';\n         }else{\n            *pWrite++ = ' ';\n            *pWrite++ = ' ';\n            *pChars++ = ' ';\n         }\n      }\n      *pChars++ = ']';\n      if(index &gt;= count){\n         *pChars = 0;\n         break;\n      }\n      length -= size;\n      if(length &lt; size + 4){\n         MO_LIB_STRCPY(pChars, length - (pChars - pResult), &quot; &gt;&gt;&quot;);\n      }else{\n         *pChars = '\n';\n      }\n      position += size;\n   }\n   return pResult;\n}</Source>
                  </Method>
                  <Method name="Dump" type="static" description="字节流格式化。" note="输出格式：地址: 十六进制数据 文本">
                     <Parameters>
                        <Parameter type="TByteC*" name="pBytes" description="输入字节流首地址"/>
                        <Parameter type="TInt" name="count" description="输入字节流的长度"/>
                        <Parameter type="TChar*" name="pResult" description="结果字符串缓存"/>
                        <Parameter type="TInt" name="length" description="结果字符串缓存长度"/>
                     </Parameters>
                     <Return type="TChar*" description="格式化后的字符串指针"/>
                     <Source>//============================================================\n// &lt;T&gt;字节流格式化。&lt;/T&gt;\n//\n// &lt;P&gt;输出格式：地址: 十六进制数据 文本&lt;/P&gt;\n// @param pBytes 输入字节流首地址\n// @param count 输入字节流的长度\n// @param pResult 结果字符串缓存\n// @param length  结果字符串缓存长度\n// @return 格式化后的字符串指针\n//============================================================\n\nTChar* RByte::Dump(TByteC* pBytes, TInt count, TChar* pResult, TInt length){\n   return FormatMemory(pBytes, count, 16, pResult, length);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RChar16">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="IsAlphaNumber" type="static" description="判断一个字符是否为英文字母或数字。">
                     <Parameters>
                        <Parameter type="TChar16" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为英文字母或数字。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar16::IsAlphaNumber(TChar16 value){\n   return iswalnum(value);\n}</Source>
                  </Method>
                  <Method name="IsAlpha" type="static" description="判断一个字符是否为英文字母或数字。">
                     <Parameters>
                        <Parameter type="TChar16" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为英文字母或数字。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar16::IsAlpha(TChar16 value){\n   return iswalpha(value);\n}</Source>
                  </Method>
                  <Method name="IsControl" type="static" description="判断一个字符是否为控制字符。">
                     <Parameters>
                        <Parameter type="TChar16" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为控制字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar16::IsControl(TChar16 value){\n   return iswcntrl(value);\n}</Source>
                  </Method>
                  <Method name="IsDigit" type="static" description="判断一个字符是否为数字字符。">
                     <Parameters>
                        <Parameter type="TChar16" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为数字字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar16::IsDigit(TChar16 value){\n   return iswdigit(value);\n}</Source>
                  </Method>
                  <Method name="IsDigitX" type="static" description="判断一个字符是否为16进制字符。">
                     <Parameters>
                        <Parameter type="TChar16" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为16进制字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar16::IsDigitX(TChar16 value){\n   return iswxdigit(value);\n}</Source>
                  </Method>
                  <Method name="IsLower" type="static" description="判断一个字符是否为小写字符。">
                     <Parameters>
                        <Parameter type="TChar16" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为小写字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar16::IsLower(TChar16 value){\n   return iswlower(value);\n}</Source>
                  </Method>
                  <Method name="IsUpper" type="static" description="判断一个字符是否为大写字符。">
                     <Parameters>
                        <Parameter type="TChar16" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为大写字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar16::IsUpper(TChar16 value){\n   return iswupper(value);\n}</Source>
                  </Method>
                  <Method name="IsGraphics" type="static" description="判断一个字符是否为可绘制字符。">
                     <Parameters>
                        <Parameter type="TChar16" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为可绘制字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar16::IsGraphics(TChar16 value){\n   return iswgraph(value);\n}</Source>
                  </Method>
                  <Method name="IsPrint" type="static" description="判断一个字符是否为可打印字符。">
                     <Parameters>
                        <Parameter type="TChar16" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为可打印字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar16::IsPrint(TChar16 value){\n   return iswprint(value);\n}</Source>
                  </Method>
                  <Method name="IsPunct" type="static" description="判断一个字符是否为标点符号。">
                     <Parameters>
                        <Parameter type="TChar16" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为标点符号。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar16::IsPunct(TChar16 value){\n   return iswpunct(value);\n}</Source>
                  </Method>
                  <Method name="IsSpace" type="static" description="判断一个字符是否为空格字符。">
                     <Parameters>
                        <Parameter type="TChar16" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为空格字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar16::IsSpace(TChar16 value){\n   return iswspace(value);\n}</Source>
                  </Method>
                  <Method name="ToLower" type="static" description="将内部字符串转换为小写。">
                     <Parameters>
                        <Parameter type="TChar16*" name="pValues"/>
                        <Parameter type="TInt" name="length" description="字符串长度"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将内部字符串转换为小写。&lt;/T&gt;\n//\n// @param pSource 字符串指针\n// @param length 字符串长度\n//============================================================\n\nvoid RChar16::ToLower(TChar16* pValues, TInt length){\n   while(--length &gt;= 0){\n      pValues[length] = towlower(pValues[length]);\n   }\n}</Source>
                  </Method>
                  <Method name="ToUpper" type="static" description="将内部字符串转换为大写。">
                     <Parameters>
                        <Parameter type="TChar16*" name="pValues"/>
                        <Parameter type="TInt" name="length" description="字符串长度"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将内部字符串转换为大写。&lt;/T&gt;\n//\n// @param pSource 字符串指针\n// @param length 字符串长度\n//============================================================\n\nvoid RChar16::ToUpper(TChar16* pValues, TInt length){\n   while(--length &gt;= 0){\n      pValues[length] = towupper(pValues[length]);\n   }\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RChar32">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="IsAlphaNumber" type="static" description="判断一个字符是否为英文字母或数字。">
                     <Parameters>
                        <Parameter type="TChar32" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为英文字母或数字。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar32::IsAlphaNumber(TChar32 value){\n   return isalnum(value);\n}</Source>
                  </Method>
                  <Method name="IsAlpha" type="static" description="判断一个字符是否为英文字母或数字。">
                     <Parameters>
                        <Parameter type="TChar32" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为英文字母或数字。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar32::IsAlpha(TChar32 value){\n   return isalpha(value);\n}</Source>
                  </Method>
                  <Method name="IsControl" type="static" description="判断一个字符是否为控制字符。">
                     <Parameters>
                        <Parameter type="TChar32" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为控制字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar32::IsControl(TChar32 value){\n   return iscntrl(value);\n}</Source>
                  </Method>
                  <Method name="IsDigit" type="static" description="判断一个字符是否为数字字符。">
                     <Parameters>
                        <Parameter type="TChar32" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为数字字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar32::IsDigit(TChar32 value){\n   return isdigit(value);\n}</Source>
                  </Method>
                  <Method name="IsDigitX" type="static" description="判断一个字符是否为16进制字符。">
                     <Parameters>
                        <Parameter type="TChar32" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为16进制字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar32::IsDigitX(TChar32 value){\n   return isxdigit(value);\n}</Source>
                  </Method>
                  <Method name="IsLower" type="static" description="判断一个字符是否为小写字符。">
                     <Parameters>
                        <Parameter type="TChar32" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为小写字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar32::IsLower(TChar32 value){\n   return islower(value);\n}</Source>
                  </Method>
                  <Method name="IsUpper" type="static" description="判断一个字符是否为大写字符。">
                     <Parameters>
                        <Parameter type="TChar32" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为大写字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar32::IsUpper(TChar32 value){\n   return isupper(value);\n}</Source>
                  </Method>
                  <Method name="IsGraphics" type="static" description="判断一个字符是否为可绘制字符。">
                     <Parameters>
                        <Parameter type="TChar32" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为可绘制字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar32::IsGraphics(TChar32 value){\n   return isgraph(value);\n}</Source>
                  </Method>
                  <Method name="IsPrint" type="static" description="判断一个字符是否为可打印字符。">
                     <Parameters>
                        <Parameter type="TChar32" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为可打印字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar32::IsPrint(TChar32 value){\n   return isprint(value);\n}</Source>
                  </Method>
                  <Method name="IsPunct" type="static" description="判断一个字符是否为标点符号。">
                     <Parameters>
                        <Parameter type="TChar32" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为标点符号。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar32::IsPunct(TChar32 value){\n   return ispunct(value);\n}</Source>
                  </Method>
                  <Method name="IsSpace" type="static" description="判断一个字符是否为空格字符。">
                     <Parameters>
                        <Parameter type="TChar32" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为空格字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar32::IsSpace(TChar32 value){\n   return isspace(value);\n}</Source>
                  </Method>
                  <Method name="ToLower" type="static" description="将内部字符串转换为小写。">
                     <Parameters>
                        <Parameter type="TChar32*" name="pValues"/>
                        <Parameter type="TInt" name="length" description="字符串长度"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将内部字符串转换为小写。&lt;/T&gt;\n//\n// @param pSource 字符串指针\n// @param length 字符串长度\n//============================================================\n\nvoid RChar32::ToLower(TChar32* pValues, TInt length){\n   while(--length &gt;= 0){\n      pValues[length] = tolower(pValues[length]);\n   }\n}</Source>
                  </Method>
                  <Method name="ToUpper" type="static" description="将内部字符串转换为大写。">
                     <Parameters>
                        <Parameter type="TChar32*" name="pValues"/>
                        <Parameter type="TInt" name="length" description="字符串长度"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将内部字符串转换为大写。&lt;/T&gt;\n//\n// @param pSource 字符串指针\n// @param length 字符串长度\n//============================================================\n\nvoid RChar32::ToUpper(TChar32* pValues, TInt length){\n   while(--length &gt;= 0){\n      pValues[length] = toupper(pValues[length]);\n   }\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RChar8">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="IsAlphaNumber" type="static" description="判断一个字符是否为英文字母或数字。">
                     <Parameters>
                        <Parameter type="TChar8" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为英文字母或数字。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar8::IsAlphaNumber(TChar8 value){\n   return isalnum(value);\n}</Source>
                  </Method>
                  <Method name="IsAlpha" type="static" description="判断一个字符是否为英文字母或数字。">
                     <Parameters>
                        <Parameter type="TChar8" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为英文字母或数字。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar8::IsAlpha(TChar8 value){\n   return isalpha(value);\n}</Source>
                  </Method>
                  <Method name="IsControl" type="static" description="判断一个字符是否为控制字符。">
                     <Parameters>
                        <Parameter type="TChar8" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为控制字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar8::IsControl(TChar8 value){\n   return iscntrl(value);\n}</Source>
                  </Method>
                  <Method name="IsDigit" type="static" description="判断一个字符是否为数字字符。">
                     <Parameters>
                        <Parameter type="TChar8" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为数字字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar8::IsDigit(TChar8 value){\n   return isdigit(value);\n}</Source>
                  </Method>
                  <Method name="IsDigitX" type="static" description="判断一个字符是否为16进制字符。">
                     <Parameters>
                        <Parameter type="TChar8" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为16进制字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar8::IsDigitX(TChar8 value){\n   return isxdigit(value);\n}</Source>
                  </Method>
                  <Method name="IsLower" type="static" description="判断一个字符是否为小写字符。">
                     <Parameters>
                        <Parameter type="TChar8" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为小写字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar8::IsLower(TChar8 value){\n   return islower(value);\n}</Source>
                  </Method>
                  <Method name="IsUpper" type="static" description="判断一个字符是否为大写字符。">
                     <Parameters>
                        <Parameter type="TChar8" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为大写字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar8::IsUpper(TChar8 value){\n   return isupper(value);\n}</Source>
                  </Method>
                  <Method name="IsGraphics" type="static" description="判断一个字符是否为可绘制字符。">
                     <Parameters>
                        <Parameter type="TChar8" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为可绘制字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar8::IsGraphics(TChar8 value){\n   return isgraph(value);\n}</Source>
                  </Method>
                  <Method name="IsPrint" type="static" description="判断一个字符是否为可打印字符。">
                     <Parameters>
                        <Parameter type="TChar8" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为可打印字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar8::IsPrint(TChar8 value){\n   return isprint(value);\n}</Source>
                  </Method>
                  <Method name="IsPunct" type="static" description="判断一个字符是否为标点符号。">
                     <Parameters>
                        <Parameter type="TChar8" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为标点符号。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar8::IsPunct(TChar8 value){\n   return ispunct(value);\n}</Source>
                  </Method>
                  <Method name="IsSpace" type="static" description="判断一个字符是否为空格字符。">
                     <Parameters>
                        <Parameter type="TChar8" name="value" description="字符"/>
                     </Parameters>
                     <Return type="TBool">
                        <L value="value='ETrue'&gt;是"/>
                        <L value="value='EFalse'&gt;否"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;判断一个字符是否为空格字符。&lt;/T&gt;\n//\n// @param value 字符\n// @return\n//    &lt;L value='ETrue'&gt;是&lt;/L&gt;\n//    &lt;L value='EFalse'&gt;否&lt;/L&gt;\n//============================================================\n\nTBool RChar8::IsSpace(TChar8 value){\n   return isspace(value);\n}</Source>
                  </Method>
                  <Method name="ToLower" type="static" description="将内部字符串转换为小写。">
                     <Parameters>
                        <Parameter type="TChar8*" name="pValues"/>
                        <Parameter type="TInt" name="length" description="字符串长度"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将内部字符串转换为小写。&lt;/T&gt;\n//\n// @param pSource 字符串指针\n// @param length 字符串长度\n//============================================================\n\nvoid RChar8::ToLower(TChar8* pValues, TInt length){\n   while(--length &gt;= 0){\n      pValues[length] = tolower(pValues[length]);\n   }\n}</Source>
                  </Method>
                  <Method name="ToUpper" type="static" description="将内部字符串转换为大写。">
                     <Parameters>
                        <Parameter type="TChar8*" name="pValues"/>
                        <Parameter type="TInt" name="length" description="字符串长度"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将内部字符串转换为大写。&lt;/T&gt;\n//\n// @param pSource 字符串指针\n// @param length 字符串长度\n//============================================================\n\nvoid RChar8::ToUpper(TChar8* pValues, TInt length){\n   while(--length &gt;= 0){\n      pValues[length] = toupper(pValues[length]);\n   }\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RCharEncoding">
               <Attributes>
                  <Attribute type="TCharC*" name="Gb2312"/>
                  <Attribute type="TCharC*" name="Gbk"/>
                  <Attribute type="TCharC*" name="Gb18030"/>
                  <Attribute type="TCharC*" name="Default"/>
               </Attributes>
            </Class>
            <Class name="RCharSet">
               <Attributes>
                  <Attribute type="TCharC*" name="Utf8"/>
                  <Attribute type="TCharC*" name="Utf16"/>
                  <Attribute type="TCharC*" name="Utf32"/>
               </Attributes>
            </Class>
            <Class name="RComparerSort">
               <Methods>
                  <Method name="InsertSort" type="static" description="用于元素比较少的数组的插入排序。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="b"/>
                        <Parameter type="TInt" name="e"/>
                        <Parameter type="e,IComparer&lt;T&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void InsertSort(T* pMemory, TInt b, TInt e,IComparer&lt;T&gt;* pComparer){\n      if(b &lt; e) {\n         T tmp;\n         for(TInt i = b + 1; i &lt;= e; ++i) {\n            for(TInt j = i; j &gt; b; --j) {\n               if(pComparer-&gt;Compare(pMemory[j], pMemory[j-1]) &lt; 0){\n                  MO_SORT_SWAP(tmp, pMemory[j], pMemory[j-1]);\n               } else{\n                  break;\n               }\n            }\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="QuickSort" type="static" description="用于元素比较多的数组的快速排序。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="b"/>
                        <Parameter type="TInt" name="e"/>
                        <Parameter type="IComparer&lt;T&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void QuickSort(T* pMemory, TInt b, TInt e, IComparer&lt;T&gt;* pComparer){\n      if(b &lt; e) {\n         T tmp;\n         TInt pivot = (b + e) / 2;\n         T data = pMemory[pivot];\n         MO_SORT_SWAP(tmp, pMemory[b], pMemory[pivot]);\n         TInt last = b;\n\n         for(TInt i = b+1; i &lt;= e; ++i) {\n            if(pComparer-&gt;Compare(pMemory[i], data) &lt; 0) {\n               ++last;\n               MO_SORT_SWAP(tmp, pMemory[last], pMemory[i]);\n            }\n         }\n\n         MO_SORT_SWAP(tmp, pMemory[last], pMemory[b]);\n\n         QuickSort(pMemory, b, last-1, pComparer);\n         QuickSort(pMemory, last+1, e, pComparer);\n      }\n   }</Source>
                  </Method>
                  <Method name="ListInsertSort" type="static" description="用于元素比较少的双向链表的插入排序。">
                     <Parameters>
                        <Parameter type="E" name="*pHead"/>
                        <Parameter type="E" name="*pTail"/>
                        <Parameter type="IComparer&lt;T&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void ListInsertSort(E *pHead, E *pTail, IComparer&lt;T&gt;* pComparer) {\n      if(pTail &amp;&amp; pHead &amp;&amp; pHead != pTail) {\n         T tmp;\n         for(E *p = pHead-&gt;pNext; p != pTail-&gt;pNext; p = p-&gt;pNext) {\n            for(E *pp = p; pp != pHead; pp = pp-&gt;pPrior) {\n               if(pComparer-&gt;Compare(pp-&gt;value, pp-&gt;pPrior-&gt;value) &lt; 0) {\n                  MO_SORT_SWAP(tmp, pp-&gt;value, pp-&gt;pPrior-&gt;value);\n                } else {\n                    break;\n                }\n            }\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="ListQuickSort" type="static" description="用于元素比较多的双向链表的快速排序。">
                     <Parameters>
                        <Parameter type="E" name="*pHead"/>
                        <Parameter type="E" name="*pTail"/>
                        <Parameter type="*pTail,IComparer&lt;T&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void ListQuickSort(E *pHead, E *pTail,IComparer&lt;T&gt;* pComparer){\n      if(pTail &amp;&amp; pHead &amp;&amp; pHead != pTail) {\n         T tmp;\n         T data = pHead-&gt;value;\n         E *last = pHead;\n\n         for(E *p = pHead-&gt;pNext; p != pTail-&gt;pNext; p = p-&gt;pNext) {\n            if(pComparer-&gt;Compare(p-&gt;value, data) &lt; 0) {\n               last = last-&gt;pNext;\n               MO_SORT_SWAP(tmp, last-&gt;value, p-&gt;value);\n            }\n         }\n\n         MO_SORT_SWAP(tmp, last-&gt;value, pHead-&gt;value);\n\n         if(last != pHead){\n            ListQuickSort(pHead, last-&gt;pPrior, pComparer);\n         }\n         if(last != pTail){\n            ListQuickSort(last-&gt;pNext, pTail, pComparer);\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="SetInsertSort" type="static" description="用于元素比较少的双向链表的插入排序。">
                     <Parameters>
                        <Parameter type="E" name="*&amp;pHead"/>
                        <Parameter type="E" name="*&amp;pTail"/>
                        <Parameter type="IComparer&lt;T&gt;*" name="pComparer"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void SetInsertSort(E *&amp;pHead, E *&amp;pTail, IComparer&lt;T&gt;* pComparer) {\n       E *tmp;\n      if(pHead != pTail) {\n         for(E *p = pHead-&gt;pNext; p != pTail-&gt;pNext; p = p-&gt;pNext) {\n            for(E *pp = p; pp != pHead; /*pp = pp-&gt;pPrior*/) {\n                  //MO_SORT_SWAP(tmp, pp-&gt;value, pp-&gt;pPrior-&gt;value);\n                  SLItemSwap(pHead, pTail, pp, pp-&gt;pPrior);\n                } else {\n                    break;\n                }\n            }\n         }\n      }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RDate">
               <Methods>
                  <Method name="Current" type="static">
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\n//============================================================\n\n\n\n//============================================================\n\n\n\n//============================================================\n\nTDateTime RDate::Current(){\n   return 0;\n}</Source>
                  </Method>
                  <Method name="Parse" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\nTDateTime RDate::Parse(TCharC* pValue){\n   MO_ASSERT(pValue);\n   return 0;\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\nTDateTime RDate::ParseNvl(TCharC* pValue){\n   return 0;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RDateTime">
               <Methods>
                  <Method name="Current" type="static" description="获得当前时间戳。">
                     <Return type="TDateTime" description="时间戳"/>
                     <Source>//============================================================\n\n//============================================================\n// &lt;T&gt;获得当前时间戳。&lt;/T&gt;\n//\n// @return 时间戳\n//============================================================\n\nTDateTime RDateTime::Current(){\n   struct timeb time;\n   ftime(&amp;time);\n   TDateTime second = time.time;\n   TDateTime millisecond = time.millitm;\n   return second * 1000000 + millisecond * 1000;\n}</Source>
                  </Method>
                  <Method name="Parse" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\nTDateTime RDateTime::Parse(TCharC* pValue){\n   MO_ASSERT(pValue);\n   return 0;\n}</Source>
                  </Method>
                  <Method name="Parse" type="static" description="根据格式化的格式解析字符串时间。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串时间"/>
                        <Parameter type="TCharC*" name="pFormat" description="格式"/>
                     </Parameters>
                     <Return type="TDateTime" description="时间戳"/>
                     <Source>//============================================================\n// &lt;T&gt;根据格式化的格式解析字符串时间。&lt;/T&gt;\n//\n// @param pValue 字符串时间\n// @param pFormat 格式\n// @return 时间戳\n//============================================================\n\nTDateTime RDateTime::Parse(TCharC* pValue, TCharC* pFormat){\n   MO_ASSERT(pValue);\n   struct tm data;\n   TCharC* pTempV = pValue;\n   TCharC* pTempF = pFormat;\n   TChar buffer[5];\n   TSize length = strlen(pFormat);\n   MO_ASSERT(length &gt; 0);\n   TSize tempLen = 0;\n   TInt iMsec = 0;\n   while(tempLen &lt; length){\n      if(*pTempF == '%'){\n         pTempF++;\n         switch(*pTempF){\n            case 'Y':{\n               // 格式化为4位年\n               for(TInt n = 0;n&lt;4;n++){\n                  buffer[n] = pTempV[n];\n               }\n               buffer[4] = '\0';\n               TInt iYear = atoi(buffer);\n               data.tm_year = iYear - 1900;\n               pTempV = pTempV + 4;\n               tempLen++;\n               break;\n            }\n            case 'y':{\n               // 格式为2位年\n               buffer[0] = pTempV[0];\n               buffer[1] = pTempV[1];\n               buffer[2] = '\0';\n               TInt iYear = atoi(buffer);\n               if(iYear &gt;= 80){\n                  data.tm_year = iYear;\n               }else{\n                  data.tm_year = iYear + 100;\n               }\n               pTempV = pTempV + 2;\n               tempLen++;\n               break;\n            }\n            case 'm':{\n               // 格式为月\n               buffer[0] = pTempV[0];\n               buffer[1] = pTempV[1];\n               buffer[2] = '\0';\n               TInt iMon = atoi(buffer);\n               MO_ASSERT_RANGE(iMon, 0, 13);\n               data.tm_mon = iMon - 1;\n               pTempV = pTempV + 2;\n               tempLen++;\n               break;\n            }\n            case 'd':{\n               // 格式为天（日）\n               buffer[0] = pTempV[0];\n               buffer[1] = pTempV[1];\n               buffer[2] = '\0';\n               TInt iDay = atoi(buffer);\n               MO_ASSERT_RANGE(iDay, 0, 32);\n               data.tm_mday = iDay;\n               pTempV = pTempV + 2;\n               tempLen++;\n               break;\n            }\n            case 'j':{\n               pTempV = pTempV + 3;\n               tempLen++;\n               break;\n            }\n            case 'H':{\n               // 格式为24小时制小时\n               buffer[0] = pTempV[0];\n               buffer[1] = pTempV[1];\n               buffer[2] = '\0';\n               TInt iHour = atoi(buffer);\n               MO_ASSERT_RANGE(iHour, 0, 24);\n               data.tm_hour = iHour;\n               pTempV = pTempV + 2;\n               tempLen++;\n               break;\n            }\n            case 'M':{\n               // 格式为分钟\n               buffer[0] = pTempV[0];\n               buffer[1] = pTempV[1];\n               buffer[2] = '\0';\n               TInt iMin = atoi(buffer);\n               MO_ASSERT_RANGE(iMin, 0, 60);\n               data.tm_min = iMin;\n               pTempV = pTempV + 2;\n               tempLen++;\n               break;\n            }\n            case 'S':{\n               // 格式为秒\n               buffer[0] = pTempV[0];\n               buffer[1] = pTempV[1];\n               buffer[2] = '\0';\n               TInt iSec = atoi(buffer);\n               MO_ASSERT_RANGE(iSec, 0, 60);\n               data.tm_sec = iSec;\n               pTempV = pTempV + 2;\n               tempLen++;\n               break;\n            }\n            case 's':{\n               // 格式为毫秒\n               buffer[0] = pTempV[0];\n               buffer[1] = pTempV[1];\n               buffer[2] = pTempV[2];\n               buffer[3] = '\0';\n               iMsec = atoi(buffer);\n               pTempV = pTempV + 3;\n               tempLen++;\n               break;\n            }\n         }\n      }else{\n         pTempV++;\n      }\n      pTempF++;\n      tempLen++;\n   }\n   TDateTime result = mktime(&amp;data);\n   return result * 1000000 + iMsec * 1000;\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\nTDateTime RDateTime::ParseNvl(TCharC* pValue){\n   if(NULL == pValue){\n      return 0;\n   }\n   return Parse(pValue);\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                        <Parameter type="TCharC*" name="pFormat"/>
                     </Parameters>
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\nTDateTime RDateTime::ParseNvl(TCharC* pValue, TCharC* pFormat){\n   if(NULL == pValue){\n      return 0;\n   }\n   return Parse(pValue, pFormat);\n}</Source>
                  </Method>
                  <Method name="ToString" type="static" description="格式化时间为指定方式字符串。">
                     <Parameters>
                        <Parameter type="TChar*" name="pBuffer" description="格式化后的时间"/>
                        <Parameter type="TSize" name="length" description="pBuffer长度"/>
                        <Parameter type="TDateTime" name="dateTime" description="时间戳"/>
                        <Parameter type="TCharC*" name="pFormat" description="格式"/>
                     </Parameters>
                     <Return type="TCharC*" description="格式化后的时间"/>
                     <Source>//============================================================\n// &lt;T&gt;格式化时间为指定方式字符串。&lt;/T&gt;\n//\n// @param pBuffer 格式化后的时间\n// @param length  pBuffer长度\n// @param pFormat 格式\n// @param dateTime 时间戳\n// @return 格式化后的时间\n//============================================================\n\nTCharC* RDateTime::ToString(TChar* pBuffer, TSize length, TDateTime dateTime, TCharC* pFormat){\n   struct tm data;\n   time_t time = dateTime / 1000000;\n#ifdef _WINDOWS\n   MO_ASSERT_ERRNO(localtime_s(&amp;data, &amp;time));\n#else\n   data = *localtime(&amp;time);\n#endif\n   TSize lengthF = strlen(pFormat);\n   TChar* pWrite = pBuffer;\n   TChar buffer[4];\n   TSize tempLenV = 0;\n   TSize tempLenF = 0;\n\n   while(tempLenF &lt; lengthF&amp;&amp;tempLenV &lt; length){\n      if(*pFormat == '%'){\n         pFormat++;\n         switch(*pFormat++){\n            case 'Y':{\n               // 格式化为4位年（如：2005）\n               TInt iYear = data.tm_year + 1900;\n               RInt::ToString(iYear, buffer, 4);\n               for(TInt n = 0;n&lt;4;n++){\n                  *pWrite++ = buffer[n];\n               }\n               tempLenF++;\n               tempLenV = tempLenV + 4;\n               break;\n            }\n            case 'y':{\n               // 格式化为2位年（如05）\n               TInt iYear;\n               TInt temp = data.tm_year;\n               if(temp &gt;= 100){\n                  iYear = temp - 100;\n               }else{\n                  iYear = temp;\n               }\n               RInt::ToString(iYear, buffer, 2);\n               if(iYear &lt; 10){\n                  *pWrite++ = '0';\n                  *pWrite++ = buffer[0];\n               }else{\n                  *pWrite++ = buffer[0];\n                  *pWrite++ = buffer[1];\n               }\n               tempLenF++;\n               tempLenV = tempLenV + 2;\n               break;\n            }\n            case 'm':{\n               // 格式化为月\n               TInt iMon = data.tm_mon + 1;\n               RInt::ToString(iMon, buffer, 2);\n               if(iMon &lt; 10){\n                  *pWrite++ = '0';\n                  *pWrite++ = buffer[0];\n               }else{\n                  *pWrite++ = buffer[0];\n                  *pWrite++ = buffer[1];\n               }\n               tempLenF++;\n               tempLenV = tempLenV + 2;\n               break;\n            }\n            case 'd':{\n               // 格式化为天（日）\n               TInt iDay = data.tm_mday;\n               RInt::ToString(iDay, buffer, 2);\n               if(iDay &lt; 10){\n                  *pWrite++ = '0';\n                  *pWrite++ = buffer[0];\n               }else{\n                  *pWrite++ = buffer[0];\n                  *pWrite++ = buffer[1];\n               }\n               tempLenF++;\n               tempLenV = tempLenV + 2;\n               break;\n            }\n            //case 'j':{\n            //   pTempV = pTempV + 3;\n            //   break;\n            //         }\n            case 'H':{\n               // 格式化为24小时制小时\n               TInt iHour = data.tm_hour;\n               RInt::ToString(iHour, buffer, 2);\n               if(iHour &lt; 10){\n                  *pWrite++ = '0';\n                  *pWrite++ = buffer[0];\n               }else{\n                  *pWrite++ = buffer[0];\n                  *pWrite++ = buffer[1];\n               }\n               tempLenF++;\n               tempLenV = tempLenV + 2;\n               break;\n            }\n            //case 'h':{\n            //   break;\n            //         }\n            case 'M':{\n               // 格式化为分\n               TInt iMin = data.tm_min;\n               RInt::ToString(iMin, buffer, 2);\n               if(iMin &lt; 10){\n                  *pWrite++ = '0';\n                  *pWrite++ = buffer[0];\n               }else{\n                  *pWrite++ = buffer[0];\n                  *pWrite++ = buffer[1];\n               }\n               tempLenF++;\n               tempLenV = tempLenV + 2;\n               break;\n            }\n            case 'S':{\n               // 格式化为秒\n               TInt iSec = data.tm_sec;\n               RInt::ToString(iSec, buffer, 2);\n               if(iSec &lt; 10){\n                  *pWrite++ = '0';\n                  *pWrite++ = buffer[0];\n               }else{\n                  *pWrite++ = buffer[0];\n                  *pWrite++ = buffer[1];\n               }\n               tempLenF++;\n               tempLenV = tempLenV + 2;\n               break;\n            }\n            case 's':{\n               // 格式化为毫秒\n               TInt iMsec = (dateTime % 1000000) / 1000;\n               RInt::ToString(iMsec, buffer, 3);\n               if(iMsec &lt; 10){\n                  *pWrite++ = '0';\n                  *pWrite++ = '0';\n                  *pWrite++ = buffer[0];\n               }else if(iMsec &lt; 100){\n                  *pWrite++ = '0';\n                  *pWrite++ = buffer[0];\n                  *pWrite++ = buffer[1];\n               }else{\n                  *pWrite++ = buffer[0];\n                  *pWrite++ = buffer[1];\n                  *pWrite++ = buffer[2];\n               }\n               tempLenF++;\n               tempLenV = tempLenV + 3;\n               break;\n            }\n         }\n      }else{\n         *pWrite++ = *pFormat++;\n         tempLenV++;\n      }\n      tempLenF++;\n   }\n   *pWrite = '\0';\n   return pBuffer;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TCharC*" name="DefaultFormat"/>
               </Attributes>
            </Class>
            <Class name="RDouble">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static" description="将字符串变换为双精度数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TDouble" description="双精度数"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为双精度数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 双精度数\n//============================================================\n\nTDouble RDouble::Parse(TCharC* pValue){\n	MO_ASSERT(pValue);\n   return (TDouble)atof(pValue);\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static" description="将字符串变换为双精度数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TDouble" description="双精度数"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为双精度数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 双精度数\n//============================================================\n\nTDouble RDouble::ParseNvl(TCharC* pValue){\n	return (pValue== NULL) ? (TDouble)0.0f : (TDouble)atof(pValue);\n}</Source>
                  </Method>
                  <Method name="ParseHex" type="static" description="将16进制字符串变换为双精度数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TDouble" description="双精度数"/>
                     <Source>//============================================================\n// &lt;T&gt;将16进制字符串变换为双精度数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 双精度数\n//============================================================\n\nTDouble RDouble::ParseHex(TCharC* pValue){\n	MO_ASSERT(pValue);\n   TByte result[sizeof(TDouble)];\n   // 读取字符串\n   for(TInt n=0; n&lt;sizeof(TDouble); n++){\n      // 读取高4位\n      TChar8 hbyte = *pValue++;\n      if(hbyte &gt;= '0' &amp;&amp; hbyte &lt;= '9'){\n         hbyte = hbyte - '0';\n      }else if(hbyte &gt;= 'a' &amp;&amp; hbyte &lt;= 'f'){\n         hbyte = hbyte - 'a' + 10;\n      }else if(hbyte &gt;= 'A' &amp;&amp; hbyte &lt;= 'F'){\n         hbyte = hbyte - 'A' + 10;\n      }else{\n         MO_THROW(&quot;Unknown Double format.&quot;);\n      }\n      // 读取低4位\n      TChar8 lbyte = *pValue++;\n      if(lbyte &gt;= '0' &amp;&amp; lbyte &lt;= '9'){\n         lbyte = lbyte - '0';\n      }else if(lbyte &gt;= 'a' &amp;&amp; lbyte &lt;= 'f'){\n         lbyte = lbyte - 'a' + 10;\n      }else if(lbyte &gt;= 'A' &amp;&amp; lbyte &lt;= 'F'){\n         lbyte = lbyte - 'A' + 10;\n      }else{\n         MO_THROW(&quot;Unknown Double format.&quot;);\n      }\n      // 设置内容\n      result[n] = (hbyte &lt;&lt; 4) + lbyte;\n   }\n   return *(TDouble*)result;\n}</Source>
                  </Method>
                  <Method name="ParseHexNvl" type="static" description="将16进制字符串变换为双精度数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TDouble" description="双精度数"/>
                     <Source>//============================================================\n// &lt;T&gt;将16进制字符串变换为双精度数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 双精度数\n//============================================================\n\nTDouble RDouble::ParseHexNvl(TCharC* pValue){\n	return (NULL == pValue) ? (TDouble)0.0f : ParseHex(pValue);\n}</Source>
                  </Method>
                  <Method name="ToString" type="static" description="将双精度数变换为字符串。">
                     <Parameters>
                        <Parameter type="TDouble" name="value" description="双精度数"/>
                        <Parameter type="TChar*" name="pBuffer" description="缓冲区"/>
                        <Parameter type="TSize" name="length" description="缓冲长度"/>
                     </Parameters>
                     <Return type="TCharC*" description="字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;将双精度数变换为字符串。&lt;/T&gt;\n//\n// @param value 双精度数\n// @param pBuffer 缓冲区\n// @param length 缓冲长度\n// @return 字符串\n//============================================================\n\nTCharC* RDouble::ToString(TDouble value, TChar* pBuffer, TSize length){\n#ifdef _WINDOWS\n   sprintf_s(pBuffer, length - 1, &quot;%f&quot;, value);\n#else\n   sprintf(pBuffer, &quot;%f&quot;, value);\n#endif\n   return pBuffer;\n}</Source>
                  </Method>
                  <Method name="ToHexString" type="static" description="将双精度数变换为16进制字符串。">
                     <Parameters>
                        <Parameter type="TDouble" name="value" description="双精度数"/>
                        <Parameter type="TChar*" name="pBuffer" description="缓冲区"/>
                        <Parameter type="TSize" name="length" description="缓冲长度"/>
                     </Parameters>
                     <Return type="TCharC*" description="字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;将双精度数变换为16进制字符串。&lt;/T&gt;\n//\n// @param value 双精度数\n// @param pBuffer 缓冲区\n// @param length 缓冲长度\n// @return 字符串\n//============================================================\n\nTCharC* RDouble::ToHexString(TDouble value, TChar* pBuffer, TSize length){\n   TByte* pValue = (TByte*)&amp;value;\n   TChar* pWrite = pBuffer;\n   // 输出字符串\n   for(TInt n=0; n&lt;sizeof(TDouble); n++){\n      TChar ch = pValue[n];\n      TInt byte = (ch &gt;= 0) ? ch : 0x100 + ch;\n      *pWrite++ = RByte::HEX_CHARS[byte &gt;&gt; 4];\n      *pWrite++ = RByte::HEX_CHARS[byte &amp; 0x0F];\n   }\n   // 设置结束字符\n   *pWrite = 0;\n   return pBuffer;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="REnvironment">
               <Methods>
                  <Method name="MappingPath" type="static" description="根据相对路径计算绝对路径。" note="根路径是由-home参数传入的。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pPath" description="相对路径"/>
                        <Parameter type="pPath," name="..." description="参数"/>
                     </Parameters>
                     <Return type="TFsPath" description="绝对路径"/>
                     <Source>//============================================================\n// &lt;T&gt;根据相对路径计算绝对路径。&lt;/T&gt;\n// &lt;P&gt;根路径是由-home参数传入的。&lt;/P&gt;\n//\n// @param pPath 相对路径\n// @param ... 参数\n// @return 绝对路径\n//============================================================\n\nTFsPath REnvironment::MappingPath(TCharC* pPath, ...){\n   MO_ASSERT(pPath);\n#ifdef _WINDOWS\n   TFsPath path = RApplication::GetCurrentDirectory();\n#else\n   // 获得主目录\n   TCharC* pHome = RApplication::FindArgument(MO_ARG_HOME);\n   MO_ASSERT(pHome);\n   TFsPath path = pHome;\n#endif\n   // 格式化可变参数字符串信息\n   va_list params;\n   va_start(params, pPath);\n   // 生成路径\n   path.AppendFormat(pPath, params);\n   // 输出内容\n   va_end(params);\n   // 格式化\n   path.Replace('\\', '/');\n   return path;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RFile">
               <Methods>
                  <Method name="ListAll" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pDirectory"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="ExistPath" type="static" description="获得管道以被占用长度。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pPath"/>
                     </Parameters>
                     <Return type="TBool" description="被占用长度。"/>
                     <Source>//============================================================\n\n//============================================================\n// &lt;T&gt;获得管道以被占用长度。&lt;/T&gt;\n//\n// @return 被占用长度。\n//============================================================\n\nTBool RFile::ExistPath(TCharC* pPath){\n   TBool result = EFalse;\n#ifdef _WINDOWS\n   struct _stat st;\n   if(0 == _stat(pPath, &amp;st)){\n      result = st.st_mode &amp; _S_IFDIR;\n   }\n#else\n   if(0 == access(pPath, F_OK)){\n      result = ETrue;\n   }\n#endif\n   return result;\n}</Source>
                  </Method>
                  <Method name="IsPathReadable" type="static" description="获得管道以被占用长度。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pPath"/>
                     </Parameters>
                     <Return type="TBool" description="被占用长度。"/>
                     <Source>//============================================================\n// &lt;T&gt;获得管道以被占用长度。&lt;/T&gt;\n//\n// @return 被占用长度。\n//============================================================\n\nTBool RFile::IsPathReadable(TCharC* pPath){\n   TBool result = EFalse;\n#ifdef _WINDOWS\n   struct _stat st;\n   if(0 == _stat(pPath, &amp;st)){\n      result = st.st_mode &amp; _S_IREAD;\n   }\n#else\n   if(0 == access(pPath, R_OK)){\n      result = ETrue;\n   }\n#endif\n   return result;\n}</Source>
                  </Method>
                  <Method name="IsPathWritable" type="static" description="获得管道以被占用长度。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pPath"/>
                     </Parameters>
                     <Return type="TBool" description="被占用长度。"/>
                     <Source>//============================================================\n// &lt;T&gt;获得管道以被占用长度。&lt;/T&gt;\n//\n// @return 被占用长度。\n//============================================================\n\nTBool RFile::IsPathWritable(TCharC* pPath){\n   TBool result = EFalse;\n#ifdef _WINDOWS\n   struct _stat st;\n   if(0 == _stat(pPath, &amp;st)){\n      result = st.st_mode &amp; _S_IWRITE;\n   }\n#else\n   if(0 == access(pPath,W_OK)){\n      result = ETrue;\n   }\n#endif\n   return result;\n}</Source>
                  </Method>
                  <Method name="IsPathExcutable" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pPath"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool RFile::IsPathExcutable(TCharC* pPath){\n   TBool result = EFalse;\n#ifdef _WINDOWS\n   struct _stat st;\n   if(0 == _stat(pPath, &amp;st)){\n      result = st.st_mode &amp; _S_IEXEC;\n   }\n#else\n   if(0 == access(pPath,X_OK)){\n      result = ETrue;\n   }\n#endif\n   return result;\n}</Source>
                  </Method>
                  <Method name="ExistFile" type="static" description="获得管道以被占用长度。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TBool" description="被占用长度。"/>
                     <Source>//============================================================\n// &lt;T&gt;获得管道以被占用长度。&lt;/T&gt;\n//\n// @return 被占用长度。\n//============================================================\n\nTBool RFile::ExistFile(TCharC* pFileName){\n   TBool result = EFalse;\n#ifdef _WINDOWS\n   struct _stat st;\n   if(0 == _stat(pFileName, &amp;st)){\n      result = st.st_mode &amp; _S_IFMT;\n   }\n#else\n   if(0 == access(pFileName,F_OK)){\n      result = ETrue;\n   }\n#endif\n   return result;\n}</Source>
                  </Method>
                  <Method name="FileSize" type="static" description="获得管道以被占用长度。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="TInt" description="被占用长度。"/>
                     <Source>//============================================================\n// &lt;T&gt;获得管道以被占用长度。&lt;/T&gt;\n//\n// @return 被占用长度。\n//============================================================\n\nTInt RFile::FileSize(TCharC* pFileName){\n   TInt size = -1;\n   if(RFile::ExistFile(pFileName)){\n#ifdef _WINDOWS\n      struct _stat st;\n      if(0 != _stat(pFileName, &amp;st)){\n         MO_STATIC_ERROR(&quot;stat error:%d&quot;, errno);\n      }else{\n         size = st.st_size;\n      }\n#else\n      struct stat st;\n      if(0 != stat(pFileName, &amp;st)){\n         MO_STATIC_ERROR(&quot;stat error:%d&quot;, errno);\n      }else{\n         size = st.st_size;\n      }\n#endif\n   }\n   return size;\n}</Source>
                  </Method>
                  <Method name="CreateFullDirectory" type="static" description="创建目录。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pPath" description="路径字符串指针"/>
                     </Parameters>
                     <Return type="TBool" description="是否创建成功。"/>
                     <Source>//============================================================\n// &lt;T&gt;创建目录。&lt;/T&gt;\n//\n// @param pPath 路径字符串指针\n// @return 是否创建成功。\n//============================================================\n\nTBool RFile::CreateFullDirectory(TCharC* pPath){\n   TFsPath path = pPath;\n   TInt index = path.IndexOf('\\');\n   while(ENotFound != index){\n      TFsPath parentDir = path.LeftPtrC(index);\n      if(!RFile::ExistPath(parentDir)){\n#ifdef _WINDOWS\n         if(!CreateDirectory(parentDir.MemoryC(),NULL)){\n            MO_STATIC_PERROR(&quot;CreateDirectory&quot;);\n            return EFalse;\n         }\n#else\n         if(-1 == mkdir(parentDir.MemoryC(), DEFAULT_DIR_PERMISION)){\n            MO_STATIC_PERROR(&quot;mkdir&quot;);\n            return EFalse;\n         }\n#endif\n      }\n      index = path.IndexOf('\\', index + 1);\n   }\n   // 不是以&quot;\\&quot;结尾\n   if(!path.EndsWith(&quot;\\&quot;)){\n#ifdef _WINDOWS\n      if(!CreateDirectory(pPath,NULL)){\n         MO_STATIC_PERROR(&quot;CreateDirectory&quot;);\n         return EFalse;\n      }\n#else\n      if(-1 == mkdir(pPath, DEFAULT_DIR_PERMISION)){\n         MO_STATIC_PERROR(&quot;mkdir&quot;);\n         return EFalse;\n      }\n#endif\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="CopyTo" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pSourceName"/>
                        <Parameter type="TCharC*" name="pTargetName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool RFile::CopyTo(TCharC* pSourceName, TCharC* pTargetName){\n	FFileStream* pSourceFile = MO_CREATE(FFileStream);\n	if(!pSourceFile-&gt;Open(pSourceName, EFileAccessMode_Read)){\n		MO_STATIC_ERROR(&quot;Open file falied.(name=%s)&quot;, pSourceName);\n		return EFalse;\n	}\n	FFileStream* pTargetFile = MO_CREATE(FFileStream);\n	if(!pTargetFile-&gt;Create(pTargetName)){\n		MO_STATIC_ERROR(&quot;Create file falied.(name=%s)&quot;, pTargetName);\n		return EFalse;\n	}\n	TByte buffer[4096];\n	TInt byteReaded = 0;\n	while( (byteReaded = pSourceFile-&gt;Read(buffer, 4096)) &gt; 0 ){\n		pTargetFile-&gt;Write(buffer, byteReaded);\n	}\n	pSourceFile-&gt;Close();\n	pTargetFile-&gt;Close();\n	MO_DELETE(pSourceFile);\n	MO_DELETE(pTargetFile);\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RFloat">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static" description="将字符串变换为浮点数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TFloat" description="浮点数"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为浮点数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 浮点数\n//============================================================\n\nTFloat RFloat::Parse(TCharC* pValue){\n	MO_ASSERT(pValue);\n   return (TFloat)atof(pValue);\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static" description="将字符串变换为浮点数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TFloat" description="浮点数"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为浮点数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 浮点数\n//============================================================\n\nTFloat RFloat::ParseNvl(TCharC* pValue){\n	return (NULL == pValue) ? 0.0f : (TFloat)atof(pValue);\n}</Source>
                  </Method>
                  <Method name="ParseHex" type="static" description="将16进制字符串变换为浮点数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TFloat" description="浮点数"/>
                     <Source>//============================================================\n// &lt;T&gt;将16进制字符串变换为浮点数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 浮点数\n//============================================================\n\nTFloat RFloat::ParseHex(TCharC* pValue){\n	MO_ASSERT(pValue);\n   TByte result[sizeof(TFloat)];\n   // 读取字符串\n   for(TInt n=0; n&lt;sizeof(TFloat); n++){\n      // 读取高4位\n      TChar8 hbyte = *pValue++;\n      if(hbyte &gt;= '0' &amp;&amp; hbyte &lt;= '9'){\n         hbyte = hbyte - '0';\n      }else if(hbyte &gt;= 'a' &amp;&amp; hbyte &lt;= 'f'){\n         hbyte = hbyte - 'a' + 10;\n      }else if(hbyte &gt;= 'A' &amp;&amp; hbyte &lt;= 'F'){\n         hbyte = hbyte - 'A' + 10;\n      }else{\n         MO_THROW(&quot;Unknown float format.&quot;);\n      }\n      // 读取低4位\n      TChar8 lbyte = *pValue++;\n      if(lbyte &gt;= '0' &amp;&amp; lbyte &lt;= '9'){\n         lbyte = lbyte - '0';\n      }else if(lbyte &gt;= 'a' &amp;&amp; lbyte &lt;= 'f'){\n         lbyte = lbyte - 'a' + 10;\n      }else if(lbyte &gt;= 'A' &amp;&amp; lbyte &lt;= 'F'){\n         lbyte = lbyte - 'A' + 10;\n      }else{\n         MO_THROW(&quot;Unknown float format.&quot;);\n      }\n      // 设置内容\n      result[n] = (hbyte &lt;&lt; 4) + lbyte;\n   }\n   return *(TFloat*)result;\n}</Source>
                  </Method>
                  <Method name="ParseHexNvl" type="static" description="将16进制字符串变换为浮点数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TFloat" description="浮点数"/>
                     <Source>//============================================================\n// &lt;T&gt;将16进制字符串变换为浮点数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 浮点数\n//============================================================\n\nTFloat RFloat::ParseHexNvl(TCharC* pValue){\n	return (NULL == pValue) ? 0.0f : ParseHex(pValue);\n}</Source>
                  </Method>
                  <Method name="ToString" type="static" description="将浮点数变换为字符串。">
                     <Parameters>
                        <Parameter type="TFloat" name="value" description="浮点数"/>
                        <Parameter type="TChar*" name="pBuffer" description="缓冲区"/>
                        <Parameter type="TSize" name="length" description="缓冲长度"/>
                     </Parameters>
                     <Return type="TCharC*" description="字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;将浮点数变换为字符串。&lt;/T&gt;\n//\n// @param value 浮点数\n// @param pBuffer 缓冲区\n// @param length 缓冲长度\n// @return 字符串\n//============================================================\n\nTCharC* RFloat::ToString(TFloat value, TChar* pBuffer, TSize length){\n#ifdef _WINDOWS\n   sprintf_s(pBuffer, length - 1, &quot;%f&quot;, value);\n#else\n   sprintf(pBuffer, &quot;%f&quot;, value);\n#endif\n   return pBuffer;\n}</Source>
                  </Method>
                  <Method name="ToHexString" type="static" description="将浮点数变换为16进制字符串。">
                     <Parameters>
                        <Parameter type="TFloat" name="value" description="浮点数"/>
                        <Parameter type="TChar*" name="pBuffer" description="缓冲区"/>
                        <Parameter type="TSize" name="length" description="缓冲长度"/>
                     </Parameters>
                     <Return type="TCharC*" description="字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;将浮点数变换为16进制字符串。&lt;/T&gt;\n//\n// @param value 浮点数\n// @param pBuffer 缓冲区\n// @param length 缓冲长度\n// @return 字符串\n//============================================================\n\nTCharC* RFloat::ToHexString(TFloat value, TChar* pBuffer, TSize length){\n   TByte* pValue = (TByte*)&amp;value;\n   TChar* pWrite = pBuffer;\n   // 输出字符串\n   for(TInt n=0; n&lt;sizeof(TFloat); n++){\n      TChar ch = pValue[n];\n      TInt byte = (ch &gt;= 0) ? ch : 0x100 + ch;\n      *pWrite++ = RByte::HEX_CHARS[byte &gt;&gt; 4];\n      *pWrite++ = RByte::HEX_CHARS[byte &amp; 0x0F];\n   }\n   // 设置结束字符\n   *pWrite = 0;\n   return pBuffer;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RHashCode">
               <Methods>
                  <Method name="MakeHashCode" type="inline">
                     <Parameters>
                        <Parameter type="TInt8" name="value"/>
                     </Parameters>
                     <Return type="THashCode"/>
                     <Source>\nfriend inline THashCode MakeHashCode(TInt8 value){\n      return value;\n   }</Source>
                  </Method>
                  <Method name="MakeHashCode" type="inline">
                     <Parameters>
                        <Parameter type="TInt16" name="value"/>
                     </Parameters>
                     <Return type="THashCode"/>
                     <Source>\nfriend inline THashCode MakeHashCode(TInt16 value){\n      return value;\n   }</Source>
                  </Method>
                  <Method name="MakeHashCode" type="inline">
                     <Parameters>
                        <Parameter type="TInt32" name="value"/>
                     </Parameters>
                     <Return type="THashCode"/>
                     <Source>\nfriend inline THashCode MakeHashCode(TInt32 value){\n      return value;\n   }</Source>
                  </Method>
                  <Method name="MakeHashCode" type="inline">
                     <Parameters>
                        <Parameter type="TInt64" name="value"/>
                     </Parameters>
                     <Return type="THashCode"/>
                     <Source>\nfriend inline THashCode MakeHashCode(TInt64 value){\n      return value;\n   }</Source>
                  </Method>
                  <Method name="MakeHashCode" type="inline">
                     <Parameters>
                        <Parameter type="TUint8" name="value"/>
                     </Parameters>
                     <Return type="THashCode"/>
                     <Source>\nfriend inline THashCode MakeHashCode(TUint8 value){\n      return value;\n   }</Source>
                  </Method>
                  <Method name="MakeHashCode" type="inline">
                     <Parameters>
                        <Parameter type="TUint16" name="value"/>
                     </Parameters>
                     <Return type="THashCode"/>
                     <Source>\nfriend inline THashCode MakeHashCode(TUint16 value){\n      return value;\n   }</Source>
                  </Method>
                  <Method name="MakeHashCode" type="inline">
                     <Parameters>
                        <Parameter type="TUint32" name="value"/>
                     </Parameters>
                     <Return type="THashCode"/>
                     <Source>\nfriend inline THashCode MakeHashCode(TUint32 value){\n      return value;\n   }</Source>
                  </Method>
                  <Method name="MakeHashCode" type="inline">
                     <Parameters>
                        <Parameter type="TUint64" name="value"/>
                     </Parameters>
                     <Return type="THashCode"/>
                     <Source>\nfriend inline THashCode MakeHashCode(TUint64 value){\n      return value;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RInput"/>
            <Class name="RInt">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static" description="将字符串变换为整数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TInt" description="整数"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为整数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 整数\n//============================================================\n\nTInt RInt::Parse(TCharC* pValue){\n   MO_ASSERT(pValue);\n   return (NULL == pValue) ? 0 : atoi(pValue);\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static" description="将字符串变换为整数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TInt" description="整数"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为整数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 整数\n//============================================================\n\nTInt RInt::ParseNvl(TCharC* pValue){\n	 return (NULL == pValue) ? 0 : atoi(pValue);\n}</Source>
                  </Method>
                  <Method name="ToString" type="static" description="将数字格式化为字符串。">
                     <Parameters>
                        <Parameter type="TInt" name="value" description="数字"/>
                        <Parameter type="TChar*" name="pBuffer" description="输出字符串"/>
                        <Parameter type="TInt" name="length" description="输出长度"/>
                     </Parameters>
                     <Return type="TChar*" description="输出字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;将数字格式化为字符串。&lt;/T&gt;\n//\n// @param value 数字\n// @param pBuffer 输出字符串\n// @param length 输出长度\n// @return 输出字符串\n//============================================================\n\nTChar* RInt::ToString(TInt value, TChar* pBuffer, TInt length){\n   MO_ASSERT(pBuffer);\n   return RRuntime::IntToString(value, pBuffer, length);\n}</Source>
                  </Method>
                  <Method name="ToHexString" type="static">
                     <Parameters>
                        <Parameter type="TInt" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TChar*"/>
                     <Source>//============================================================\n\nTChar* RInt::ToHexString(TInt value, TChar* pBuffer, TInt length){\n	MO_ASSERT(pBuffer);\n	TInt n = -1;\n	TChar* pResult = pBuffer;\n	do{\n		// 循环转换每一个数字，直到结束\n		pResult[++n] = RByte::HEX_CHARS[value % 16];\n		value /= 16;\n	}while(value &gt; 0);\n	// 转换结束后字符串是翻的，计算出一半的长度\n	TInt position = (n + 1) / 2;\n	while(position-- &gt; 0){\n		// 将字符串的字符序翻转\n		TChar temp = pResult[position];\n		pResult[position] = pResult[n - position];\n		pResult[n - position] = temp;\n	}\n	// 置结束符\n	pResult[n + 1] = '\0';\n	return pBuffer;\n}</Source>
                  </Method>
                  <Method name="FormatCapacity" type="static" description="格式化为内存大小。">
                     <Parameters>
                        <Parameter type="TSize" name="size" description="尺寸"/>
                        <Parameter type="TChar*" name="pBuffer" description="输出字符串"/>
                        <Parameter type="TInt" name="length" description="输出长度"/>
                     </Parameters>
                     <Return type="TCharC*" description="输出字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;格式化为内存大小。&lt;/T&gt;\n//\n// @param size 尺寸\n// @param pBuffer 输出字符串\n// @param length 输出长度\n// @return 输出字符串\n//============================================================\n\nTCharC* RInt::FormatCapacity(TSize size, TChar* pBuffer, TInt length){\n   // 格式化数据\n   TFsCode format;\n   TInt gBytes = (size &gt;&gt; 30);\n   if(gBytes &gt; 0){\n      format.AppendFormat(&quot;%3dG.&quot;, gBytes);\n   }\n   TInt mBytes = (size &gt;&gt; 20) % 1024;\n   if(gBytes || mBytes &gt; 0){\n      if(gBytes){\n         format.AppendFormat(&quot;%03dM.&quot;, mBytes);\n      }else{\n         format.AppendFormat(&quot;%3dM.&quot;, mBytes);\n		}\n	}\n	TInt kBytes = (size &gt;&gt; 10) % 1024;\n   if(gBytes || mBytes || kBytes &gt; 0){\n      if(gBytes || mBytes){\n         format.AppendFormat(&quot;%03dK.&quot;, kBytes);\n      }else{\n         format.AppendFormat(&quot;%3dK.&quot;, kBytes);\n      }\n   }\n   if(gBytes || mBytes || kBytes){\n      format.AppendFormat(&quot;%03dB&quot;, size % 1024);\n   }else{\n      format.AppendFormat(&quot;%3dB&quot;, size % 1024);\n   }\n   // 复制数据\n   TInt copied = MO_MIN(format.Length() + 1, length - 1);\n   memcpy(pBuffer, format.MemoryC(), copied);\n   return pBuffer;\n}</Source>
                  </Method>
                  <Method name="CountDigit" type="static" description="计数一个整数有多少位。">
                     <Parameters>
                        <Parameter type="TInt" name="value" description="整数"/>
                     </Parameters>
                     <Return type="TInt" description="位数"/>
                     <Source>//============================================================\n// &lt;T&gt;计数一个整数有多少位。&lt;/T&gt;\n//\n// @param value 整数\n// @return 位数\n//============================================================\n\nTInt RInt::CountDigit(TInt value){\n	TInt result = 0;\n	while(value){\n		++result;\n		value /= 10;\n	}\n	return result;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RInt16">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static" description="16位整数操作的引用类。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt16"/>
                     <Source>//============================================================\n// &lt;T&gt;16位整数操作的引用类。&lt;/T&gt;\n//============================================================\n\nTInt16 RInt16::Parse(TCharC* pValue){\n	MO_ASSERT(pValue);\n	return (TInt16)atoi(pValue);\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static" description="16位整数操作的引用类。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt16"/>
                     <Source>//============================================================\n// &lt;T&gt;16位整数操作的引用类。&lt;/T&gt;\n//============================================================\n\nTInt16 RInt16::ParseNvl(TCharC* pValue){\n	return (pValue == NULL) ? 0 : (TInt16)atoi(pValue);\n}</Source>
                  </Method>
                  <Method name="ToString" type="static" description="16位整数操作的引用类。">
                     <Parameters>
                        <Parameter type="TInt16" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TChar*"/>
                     <Source>//============================================================\n// &lt;T&gt;16位整数操作的引用类。&lt;/T&gt;\n//============================================================\n\nTChar* RInt16::ToString(TInt16 value, TChar* pBuffer, TInt length){\n	MO_ASSERT(pBuffer);\n	return RInt::ToString((TInt)value, pBuffer, length);\n}</Source>
                  </Method>
                  <Method name="ToHexString" type="static" description="16位整数操作的引用类。">
                     <Parameters>
                        <Parameter type="TInt16" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TChar*"/>
                     <Source>//============================================================\n// &lt;T&gt;16位整数操作的引用类。&lt;/T&gt;\n//============================================================\n\nTChar* RInt16::ToHexString(TInt16 value, TChar* pBuffer, TInt length){\n	MO_ASSERT(pBuffer);\n	return RInt::ToHexString((TInt)value, pBuffer, length);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RInt32">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt32"/>
                     <Source>//============================================================\n\nTInt32 RInt32::Parse(TCharC* pValue){\n	MO_ASSERT(pValue);\n	TInt value = atoi(pValue);\n	return (TInt32)value;\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt32"/>
                     <Source>//============================================================\n\nTInt32 RInt32::ParseNvl(TCharC* pValue){\n	TInt value = atoi(pValue);\n	return (TInt32)value;\n}</Source>
                  </Method>
                  <Method name="ParseHex" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt32"/>
                     <Source>//============================================================\n\nTInt32 RInt32::ParseHex(TCharC* pValue){\n	MO_ASSERT(pValue);\n	TInt value = strtol(pValue, NULL, 16);\n	return (TInt32)value;\n}</Source>
                  </Method>
                  <Method name="ParseHexNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt32"/>
                     <Source>//============================================================\n\nTInt32 RInt32::ParseHexNvl(TCharC* pValue){\n	TInt value = strtol(pValue, NULL, 16);\n	return (TInt32)value;\n}</Source>
                  </Method>
                  <Method name="ToString" type="static">
                     <Parameters>
                        <Parameter type="TInt32" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RInt32::ToString(TInt32 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	return RInt::ToString((TInt)value, pBuffer, length);\n}</Source>
                  </Method>
                  <Method name="ToHexString" type="static">
                     <Parameters>
                        <Parameter type="TInt32" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RInt32::ToHexString(TInt32 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	return RInt::ToHexString((TInt)value, pBuffer, length);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RInt64">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static" description="将字符串变换为长整数,字符串为空时产生例外。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TInt64" description="长整数"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为长整数,字符串为空时产生例外。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 长整数\n//============================================================\n\nTInt64 RInt64::Parse(TCharC* pValue){\n   MO_ASSERT(pValue);\n#ifdef _WINDOWS\n   return _atoi64(pValue);\n#else\n	return atoll(pValue);\n#endif\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static" description="将字符串变换为长整数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TInt64" description="长整数"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为长整数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 长整数\n//============================================================\n\nTInt64 RInt64::ParseNvl(TCharC* pValue){\n	if(NULL == pValue){\n		return 0;\n	}\n#ifdef _WINDOWS\n	return _atoi64(pValue);\n#else\n	return atoll(pValue);\n#endif\n}</Source>
                  </Method>
                  <Method name="ToString" type="static" description="将长整数变换为字符串。">
                     <Parameters>
                        <Parameter type="TInt64" name="value" description="长整数"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*" description="字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;将长整数变换为字符串。&lt;/T&gt;\n//\n// @param value 长整数\n// @return 字符串\n//============================================================\n\nTCharC* RInt64::ToString(TInt64 value, TChar* pBuffer, TSize length){\n   MO_ASSERT(pBuffer);\n#ifdef _WINDOWS\n   sprintf_s(pBuffer, length, &quot;%lld&quot;, value);\n#else\n   sprintf(pBuffer, &quot;%lld&quot;, value);\n#endif\n   return pBuffer;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RInt8">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt8"/>
                     <Source>//============================================================\n\nTInt8 RInt8::Parse(TCharC* pValue){\n	MO_ASSERT(pValue);\n	TInt value = atoi(pValue);\n	MO_ASSERT(value &lt;= 127 &amp;&amp; value &gt;= -128);\n	return (TInt8)value;\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt8"/>
                     <Source>//============================================================\n\nTInt8 RInt8::ParseNvl(TCharC* pValue){\n	if(pValue){\n		TInt value = atoi(pValue);\n		MO_ASSERT(value &lt;= 127 &amp;&amp; value &gt;= -128);\n		return (TInt8)value;\n	}\n	return (TInt8)0;\n}</Source>
                  </Method>
                  <Method name="ParseHex" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt8"/>
                     <Source>//============================================================\n\nTInt8 RInt8::ParseHex(TCharC* pValue){\n	MO_ASSERT(pValue);\n	TInt value = strtol(pValue, NULL, 16);\n	MO_ASSERT(value &lt;= 127 &amp;&amp; value &gt;= -128);\n	return (TInt8)value;\n}</Source>
                  </Method>
                  <Method name="ParseHexNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TInt8"/>
                     <Source>//============================================================\n\nTInt8 RInt8::ParseHexNvl(TCharC* pValue){\n	TInt value = strtol(pValue, NULL, 16);\n	MO_ASSERT(value &lt;= 127 &amp;&amp; value &gt;= -128);\n	return (TInt8)value;\n}</Source>
                  </Method>
                  <Method name="ToString" type="static">
                     <Parameters>
                        <Parameter type="TInt8" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RInt8::ToString(TInt8 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	return RInt::ToString((TInt)value, pBuffer, length);\n}</Source>
                  </Method>
                  <Method name="ToHexString" type="static">
                     <Parameters>
                        <Parameter type="TInt8" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RInt8::ToHexString(TInt8 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	return RInt::ToHexString((TInt)value, pBuffer, length);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RLogger">
               <Methods>
                  <Method name="Link" type="static" description="关联日志输出器。">
                     <Parameters>
                        <Parameter type="ILoggerConsole*" name="pConsole"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\n//============================================================\n// &lt;T&gt;关联日志输出器。&lt;/T&gt;\n//============================================================\n\nvoid RLogger::Link(ILoggerConsole* pConsole){\n   _pConsole = pConsole;\n}</Source>
                  </Method>
                  <Method name="Console" type="static" description="获得日志控制台。">
                     <Return type="ILoggerConsole*" description="日志控制台"/>
                     <Source>//============================================================\n// &lt;T&gt;获得日志控制台。&lt;/T&gt;\n//\n// @return 日志控制台\n//============================================================\n\nILoggerConsole* RLogger::Console(){\n   return _pConsole;\n}</Source>
                  </Method>
                  <Method name="Output" type="static" description="输出信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type" description="消息类型"/>
                        <Parameter type="TLoggerLevel" name="level" description="消息级别"/>
                        <Parameter type="TAny*" name="pSender" description="发送者"/>
                        <Parameter type="TCharC*" name="pMethod"/>
                        <Parameter type="TDateTime" name="start" description="开始时间"/>
                        <Parameter type="TCharC*" name="pMessage" description="消息内容"/>
                        <Parameter type="va_list" name="params"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;输出信息。&lt;/T&gt;\n//\n// @param type 消息类型\n// @param level 消息级别\n// @param pSender 发送者\n// @param start 开始时间\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid RLogger::Output(TInt type, TLoggerLevel level, TAny* pSender, TCharC* pMethod, TDateTime start, TCharC* pMessage, va_list params){\n   if(NULL != _pConsole){\n      // 使用管理器输出信息\n      _pConsole-&gt;Output(type, level, pSender, pMethod, start, pMessage, params);\n   }else{\n      // 直接输出信息\n      //vprintf(pMessage, params);\n   }\n}</Source>
                  </Method>
                  <Method name="Debug" type="static" description="输出调试信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type" description="消息类型"/>
                        <Parameter type="TAny*" name="pSender" description="发送者"/>
                        <Parameter type="TCharC*" name="pMethod" description="调用函数"/>
                        <Parameter type="TCharC*" name="pMessage" description="消息内容"/>
                        <Parameter type="pMessage," name="..." description="消息参数"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;输出调试信息。&lt;/T&gt;\n//\n// @param type 消息类型\n// @param pSender 发送者\n// @param pMethod 调用函数\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid RLogger::Debug(TInt type, TAny* pSender, TCharC* pMethod, TCharC* pMessage, ...){\n   // 格式化可变参数字符串信息\n   va_list params;\n   va_start(params, pMessage);\n   // 输出日志信息\n   Output(type, ELoggerLevel_Debug, pSender, pMethod, 0, pMessage, params);\n   va_end(params);\n}</Source>
                  </Method>
                  <Method name="Debug" type="static" description="输出调试信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type" description="消息类型"/>
                        <Parameter type="TAny*" name="pSender" description="发送者"/>
                        <Parameter type="TCharC*" name="pMethod" description="调用函数"/>
                        <Parameter type="TDateTime" name="start" description="开始时间"/>
                        <Parameter type="TCharC*" name="pMessage" description="消息内容"/>
                        <Parameter type="pMessage," name="..." description="消息参数"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;输出调试信息。&lt;/T&gt;\n//\n// @param type 消息类型\n// @param pSender 发送者\n// @param pMethod 调用函数\n// @param start 开始时间\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid RLogger::Debug(TInt type, TAny* pSender, TCharC* pMethod, TDateTime start, TCharC* pMessage, ...){\n   // 格式化可变参数字符串信息\n   va_list params;\n   va_start(params, pMessage);\n   // 输出日志信息\n   Output(type, ELoggerLevel_Debug, pSender, pMethod, start, pMessage, params);\n   va_end(params);\n}</Source>
                  </Method>
                  <Method name="Info" type="static" description="输出提示信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type" description="消息类型"/>
                        <Parameter type="TAny*" name="pSender" description="发送者"/>
                        <Parameter type="TCharC*" name="pMethod" description="调用函数"/>
                        <Parameter type="TCharC*" name="pMessage" description="消息内容"/>
                        <Parameter type="pMessage," name="..." description="消息参数"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;输出提示信息。&lt;/T&gt;\n//\n// @param type 消息类型\n// @param pSender 发送者\n// @param pMethod 调用函数\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid RLogger::Info(TInt type, TAny* pSender, TCharC* pMethod, TCharC* pMessage, ...){\n   // 格式化可变参数字符串信息\n   va_list params;\n   va_start(params, pMessage);\n   // 输出日志信息\n   Output(type, ELoggerLevel_Info, pSender, pMethod, 0, pMessage, params);\n   va_end(params);\n}</Source>
                  </Method>
                  <Method name="Info" type="static" description="输出提示信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type" description="消息类型"/>
                        <Parameter type="TAny*" name="pSender" description="发送者"/>
                        <Parameter type="TCharC*" name="pMethod" description="调用函数"/>
                        <Parameter type="TDateTime" name="start" description="开始时间"/>
                        <Parameter type="TCharC*" name="pMessage" description="消息内容"/>
                        <Parameter type="pMessage," name="..." description="消息参数"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;输出提示信息。&lt;/T&gt;\n//\n// @param type 消息类型\n// @param pSender 发送者\n// @param pMethod 调用函数\n// @param start 开始时间\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid RLogger::Info(TInt type, TAny* pSender, TCharC* pMethod, TDateTime start, TCharC* pMessage, ...){\n   // 格式化可变参数字符串信息\n   va_list params;\n   va_start(params, pMessage);\n   // 输出日志信息\n   Output(type, ELoggerLevel_Info, pSender, pMethod, start, pMessage, params);\n   va_end(params);\n}</Source>
                  </Method>
                  <Method name="Warn" type="static" description="输出警告信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type" description="消息类型"/>
                        <Parameter type="TAny*" name="pSender" description="发送者"/>
                        <Parameter type="TCharC*" name="pMethod" description="调用函数"/>
                        <Parameter type="TCharC*" name="pMessage" description="消息内容"/>
                        <Parameter type="pMessage," name="..." description="消息参数"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;输出警告信息。&lt;/T&gt;\n//\n// @param type 消息类型\n// @param pSender 发送者\n// @param pMethod 调用函数\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid RLogger::Warn(TInt type, TAny* pSender, TCharC* pMethod, TCharC* pMessage, ...){\n   // 格式化可变参数字符串信息\n   va_list params;\n   va_start(params, pMessage);\n   // 输出日志信息\n   Output(type, ELoggerLevel_Warn, pSender, pMethod, 0, pMessage, params);\n   va_end(params);\n}</Source>
                  </Method>
                  <Method name="Warn" type="static" description="输出警告信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type" description="消息类型"/>
                        <Parameter type="TAny*" name="pSender" description="发送者"/>
                        <Parameter type="TCharC*" name="pMethod" description="调用函数"/>
                        <Parameter type="TDateTime" name="start" description="开始时间"/>
                        <Parameter type="TCharC*" name="pMessage" description="消息内容"/>
                        <Parameter type="pMessage," name="..." description="消息参数"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;输出警告信息。&lt;/T&gt;\n//\n// @param type 消息类型\n// @param pSender 发送者\n// @param pMethod 调用函数\n// @param start 开始时间\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid RLogger::Warn(TInt type, TAny* pSender, TCharC* pMethod, TDateTime start, TCharC* pMessage, ...){\n   // 格式化可变参数字符串信息\n   va_list params;\n   va_start(params, pMessage);\n   // 输出日志信息\n   Output(type, ELoggerLevel_Warn, pSender, pMethod, start, pMessage, params);\n   va_end(params);\n}</Source>
                  </Method>
                  <Method name="Error" type="static" description="输出错误信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type" description="消息类型"/>
                        <Parameter type="TAny*" name="pSender" description="发送者"/>
                        <Parameter type="TCharC*" name="pMethod" description="调用函数"/>
                        <Parameter type="TCharC*" name="pMessage" description="消息内容"/>
                        <Parameter type="pMessage," name="..." description="消息参数"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;输出错误信息。&lt;/T&gt;\n//\n// @param type 消息类型\n// @param pSender 发送者\n// @param pMethod 调用函数\n// @param start 开始时间\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid RLogger::Error(TInt type, TAny* pSender, TCharC* pMethod, TCharC* pMessage, ...){\n   // 格式化可变参数字符串信息\n   va_list params;\n   va_start(params, pMessage);\n   // 输出日志信息\n   Output(type, ELoggerLevel_Error, pSender, pMethod, 0, pMessage, params);\n   va_end(params);\n}</Source>
                  </Method>
                  <Method name="Error" type="static" description="输出错误信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type" description="消息类型"/>
                        <Parameter type="TAny*" name="pSender" description="发送者"/>
                        <Parameter type="TCharC*" name="pMethod" description="调用函数"/>
                        <Parameter type="TDateTime" name="start" description="开始时间"/>
                        <Parameter type="TCharC*" name="pMessage" description="消息内容"/>
                        <Parameter type="pMessage," name="..." description="消息参数"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;输出错误信息。&lt;/T&gt;\n//\n// @param type 消息类型\n// @param pSender 发送者\n// @param pMethod 调用函数\n// @param start 开始时间\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid RLogger::Error(TInt type, TAny* pSender, TCharC* pMethod, TDateTime start, TCharC* pMessage, ...){\n   // 格式化可变参数字符串信息\n   va_list params;\n   va_start(params, pMessage);\n   // 输出日志信息\n   Output(type, ELoggerLevel_Error, pSender, pMethod, start, pMessage, params);\n   va_end(params);\n}</Source>
                  </Method>
                  <Method name="Fatal" type="static" description="输出系统错误信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type" description="消息类型"/>
                        <Parameter type="TAny*" name="pSender" description="发送者"/>
                        <Parameter type="TCharC*" name="pMethod" description="调用函数"/>
                        <Parameter type="TCharC*" name="pMessage" description="消息内容"/>
                        <Parameter type="pMessage," name="..." description="消息参数"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;输出系统错误信息。&lt;/T&gt;\n//\n// @param type 消息类型\n// @param pSender 发送者\n// @param pMethod 调用函数\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid RLogger::Fatal(TInt type, TAny* pSender, TCharC* pMethod, TCharC* pMessage, ...){\n   // 格式化可变参数字符串信息\n   va_list params;\n   va_start(params, pMessage);\n   // 输出日志信息\n   Output(type, ELoggerLevel_Fatal, pSender, pMethod, 0, pMessage, params);\n   va_end(params);\n}</Source>
                  </Method>
                  <Method name="Fatal" type="static" description="输出系统错误信息。">
                     <Parameters>
                        <Parameter type="TInt" name="type" description="消息类型"/>
                        <Parameter type="TAny*" name="pSender" description="发送者"/>
                        <Parameter type="TCharC*" name="pMethod" description="调用函数"/>
                        <Parameter type="TDateTime" name="start" description="开始时间"/>
                        <Parameter type="TCharC*" name="pMessage" description="消息内容"/>
                        <Parameter type="pMessage," name="..." description="消息参数"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;输出系统错误信息。&lt;/T&gt;\n//\n// @param type 消息类型\n// @param pSender 发送者\n// @param pMethod 调用函数\n// @param start 开始时间\n// @param pMessage 消息内容\n// @param ... 消息参数\n//============================================================\n\nvoid RLogger::Fatal(TInt type, TAny* pSender, TCharC* pMethod, TDateTime start, TCharC* pMessage, ...){\n   // 格式化可变参数字符串信息\n   va_list params;\n   va_start(params, pMessage);\n   // 输出日志信息\n   Output(type, ELoggerLevel_Fatal, pSender, pMethod, start, pMessage, params);\n   va_end(params);\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="ILoggerConsole*" name="_pConsole"/>
               </Attributes>
            </Class>
            <Class name="RMemory">
               <Methods>
                  <Method name="Alloc" type="static" description="收集指定大小的内存。">
                     <Parameters>
                        <Parameter type="TUint" name="size" description="指定大小"/>
                     </Parameters>
                     <Return type="TAny*" description="收集好的内存"/>
                     <Source>//============================================================\n// &lt;T&gt;收集指定大小的内存。&lt;/T&gt;\n//\n// @param size 指定大小\n// @return 收集好的内存\n//============================================================\n\nTAny* RMemory::Alloc(TUint size){\n   TAny* pAlloc = malloc(size);\n   MO_ASSERT(pAlloc);\n   return pAlloc;\n}</Source>
                  </Method>
                  <Method name="Alloc" type="static" description="收集指定大小的内存，并初始化内容。">
                     <Parameters>
                        <Parameter type="TUint" name="size" description="指定大小"/>
                        <Parameter type="TInt" name="value" description="初始化内容"/>
                     </Parameters>
                     <Return type="TAny*" description="收集好的内存"/>
                     <Source>//============================================================\n// &lt;T&gt;收集指定大小的内存，并初始化内容。&lt;/T&gt;\n//\n// @param size 指定大小\n// @param value 初始化内容\n// @return 收集好的内存\n//============================================================\n\nTAny* RMemory::Alloc(TUint size, TInt value){\n   TAny* pAlloc = malloc(size);\n   MO_ASSERT(pAlloc);\n   memset(pAlloc, value, size);\n   return pAlloc;\n}</Source>
                  </Method>
                  <Method name="Realloc" type="static" description="重新收集指定大小的内存。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory" description="原始内存定大小"/>
                        <Parameter type="TUint" name="size" description="指定大小"/>
                     </Parameters>
                     <Return type="TAny*" description="收集好的内存"/>
                     <Source>//============================================================\n// &lt;T&gt;重新收集指定大小的内存。&lt;/T&gt;\n//\n// @param pMemory 原始内存定大小\n// @param size 指定大小\n// @return 收集好的内存\n//============================================================\n\nTAny* RMemory::Realloc(TAny* pMemory, TUint size){\n   TAny* pAlloc = realloc(pMemory, size);\n   MO_ASSERT(pAlloc);\n   return pAlloc;\n}</Source>
                  </Method>
                  <Method name="Fill" type="static" description="填充指定的内存区域。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory" description="待填充的内存"/>
                        <Parameter type="TUint" name="size" description="指定大小"/>
                        <Parameter type="TInt" name="value" description="填充值"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;填充指定的内存区域。&lt;/T&gt;\n//\n// @param pMemory 待填充的内存\n// @param value 填充值\n// @param size 指定大小\n//============================================================\n\nvoid RMemory::Fill(TAny* pMemory, TUint size, TInt value){\n   MO_ASSERT(pMemory);\n   memset(pMemory, value, size);\n}</Source>
                  </Method>
                  <Method name="Copy" type="static" description="复制内存区域到指定位置。">
                     <Parameters>
                        <Parameter type="TAny*" name="pSource" description="源内存"/>
                        <Parameter type="TAny*" name="pTarget" description="目标内存"/>
                        <Parameter type="TUint" name="size" description="指定大小"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;复制内存区域到指定位置。&lt;/T&gt;\n//\n// @param pSource 源内存\n// @param pTarget 目标内存\n// @param size 指定大小\n//============================================================\n\nvoid RMemory::Copy(const TAny* pSource, TAny* pTarget, TUint size){\n   MO_ASSERT(pSource);\n   MO_ASSERT(pTarget);\n   memcpy(pTarget, pSource, size);\n}</Source>
                  </Method>
                  <Method name="Clear" type="static" description="重置指定的内存区域。" note="当前内存内全部用0进行填充。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory" description="待填充的内存"/>
                        <Parameter type="TUint" name="size" description="指定大小"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;重置指定的内存区域。&lt;/T&gt;\n// &lt;P&gt;当前内存内全部用0进行填充。&lt;/P&gt;\n//\n// @param pMemory 待填充的内存\n// @param size 指定大小\n//============================================================\n\nvoid RMemory::Clear(TAny* pMemory, TUint size){\n   MO_ASSERT(pMemory);\n   memset(pMemory, 0, size);\n}</Source>
                  </Method>
                  <Method name="Free" type="static" description="释放内存。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory" description="内存"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放内存。&lt;/T&gt;\n//\n// @param pMemory 内存\n//============================================================\n\nvoid RMemory::Free(TAny* pMemory){\n   MO_ASSERT(pMemory);\n   free(pMemory);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RNetSocket">
               <Methods>
                  <Method name="Startup" type="static">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid RNetSocket::Startup(){\n#ifdef _WINDOWS\n   TUint16 wVersionRequested = MAKEWORD( 2, 2 );\n   WSADATA wsaData;\n   RMemory::Clear(&amp;wsaData, sizeof(wsaData));\n   MO_STATIC_DEBUG(&quot;Socket environment startup (version=2.2)&quot;);\n   TInt error = WSAStartup(wVersionRequested, &amp;wsaData);\n   MO_ASSERT(0 == error);\n#endif\n}</Source>
                  </Method>
                  <Method name="Cleanup" type="static">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid RNetSocket::Cleanup(){\n#ifdef _WINDOWS\n   MO_STATIC_DEBUG(&quot;Socket environment cleanup&quot;);\n   WSACleanup();\n#endif\n}</Source>
                  </Method>
                  <Method name="Connect" type="static">
                     <Parameters>
                        <Parameter type="SNetSocketInfo&amp;" name="info"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool RNetSocket::Connect(SNetSocketInfo&amp; info){\n   // 创建链接\n   TSocket handle = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n   if(INVALID_SOCKET == handle){\n      MO_STATIC_PERROR(socket);\n      return EFalse;\n   }\n   MO_STATIC_DEBUG(&quot;Connect net socket. (host=%s, port=%d)&quot;, info.host, info.port);\n   // 绑定链接\n   sockaddr_in address;\n   address.sin_family = AF_INET;\n   address.sin_port = htons(info.port);\n   address.sin_addr.s_addr = inet_addr(info.host);\n   memset(address.sin_zero, 0, sizeof(address.sin_zero));\n   if(ESuccess != connect(handle, (struct sockaddr*)&amp;address, sizeof(sockaddr_in))){\n      MO_STATIC_PERROR(connect);\n      // 关闭已经打开的链接句柄\n#ifdef _WINDOWS\n      if(ESuccess != closesocket(handle)){\n         MO_STATIC_PERROR(close);\n      }\n#else\n      if(ESuccess != close(handle)){\n         MO_STATIC_PERROR(close);\n      }\n#endif\n      return EFalse;\n   }\n   info.handle = handle;\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Disconnect" type="static">
                     <Parameters>
                        <Parameter type="SNetSocketInfo&amp;" name="info"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool RNetSocket::Disconnect(SNetSocketInfo&amp; info){\n   TUint32 handle = info.handle;\n   // 关闭已经打开的链接句柄\n   MO_STATIC_DEBUG(&quot;Disconnect net socket. (host=%s, port=%d, handle=%d)&quot;,\n         info.host, info.port, handle);\n#ifdef _WINDOWS\n   if(ESuccess != closesocket(handle)){\n      MO_STATIC_PERROR(close);\n   }\n#else\n   if(ESuccess != close(handle)){\n      MO_STATIC_PERROR(close);\n   }\n#endif\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="ROutput">
               <Methods>
                  <Method name="CalculateStringCapacity" type="static">
                     <Parameters>
                        <Parameter type="MStringC&amp;" name="value"/>
                     </Parameters>
                     <Return type="TSize"/>
                     <Source>//============================================================\n\nTSize ROutput::CalculateStringCapacity(const MStringC&amp; value){\n   return sizeof(TUint32) + value.Length();\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RProcess">
               <Methods>
                  <Method name="CurrentId" type="static">
                     <Parameters>
                        <Parameter type="TInt" name="CurrentId(void"/>
                     </Parameters>
                     <Return type="TInt"/>
                  </Method>
                  <Method name="CurrentId">
                     <Return type="TInt"/>
                     <Source>\nTInt RProcess::CurrentId(){\n#ifdef _WINDOWS\n	TInt processId = GetCurrentProcessId();\n#else\n	TInt processId = 0;\n#endif\n   return processId;\n}</Source>
                  </Method>
                  <Method name="AdjustProcessPrivileges" type="static">
                     <Parameters>
                        <Parameter type="EProcessPrivileges" name="privileges"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool RProcess::AdjustProcessPrivileges(EProcessPrivileges privileges){\n#ifdef _WINDOWS\n	// 得到进程的令牌句柄\n	TAny* hToken = NULL;\n   TAny* hProcess = GetCurrentProcess();\n   if(!OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) {\n		return EFalse;\n	}\n	// 查询进程的权限\n   LPCWSTR szPrivilegesName = NULL;\n   switch(privileges){\n      case EProcessPrivileges_Debug:\n         //szPrivilegesName = SE_DEBUG_NAME;\n         break;\n   }\n	TOKEN_PRIVILEGES tokenPrivileges;\n	//if(!LookupPrivilegeValue(NULL, szPrivilegesName, &amp;tokenPrivileges.Privileges[0].Luid)){\n		//CloseHandle(hToken);\n		//return EFalse;\n	//}\n	// 判断令牌权限\n	tokenPrivileges.PrivilegeCount = 1;\n	tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n	if(!AdjustTokenPrivileges(hToken, EFalse, &amp;tokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL)){\n		CloseHandle(hToken);\n		return EFalse;\n	}\n	CloseHandle(hToken);\n#endif\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RRandom">
               <Methods>
                  <Method name="Initialize" type="static" description="初始化RRandom对象，产生一个种子。">
                     <Return type="void"/>
                     <Source>//============================================================\n//&lt;T&gt;初始化RRandom对象，产生一个种子。&lt;/T&gt;\n//============================================================\n\nvoid RRandom::Initialize(){\n   srand((TUint)time(NULL));\n}</Source>
                  </Method>
                  <Method name="Get" type="static" description="获得一个随机数。">
                     <Return type="TInt" description="产生的随机数。"/>
                     <Source>//============================================================\n\nTInt RRandom::Get(){\n   return rand();\n}</Source>
                  </Method>
                  <Method name="Get" type="static" description="获得指定区间内的随机数。">
                     <Parameters>
                        <Parameter type="TInt" name="min"/>
                        <Parameter type="TInt" name="max"/>
                     </Parameters>
                     <Return type="TInt" description="产生的随机数。"/>
                     <Source>//============================================================\n//&lt;T&gt;获得指定区间内的随机数。&lt;/T&gt;\n//\n//@return 产生的随机数。\n//============================================================\n\nTInt RRandom::Get(TInt min, TInt max){\n   return (rand() % max) + min;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RResource">
               <Methods>
                  <Method name="GetString" type="static">
                     <Parameters>
                        <Parameter type="TInt" name="id"/>
                     </Parameters>
                     <Return type="TChar*"/>
                  </Method>
               </Methods>
            </Class>
            <Class name="RRuntime">
               <Methods>
                  <Method name="IntToString8" type="static">
                     <Parameters>
                        <Parameter type="TInt" name="value"/>
                        <Parameter type="TChar8*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TChar8*"/>
                     <Source>//============================================================\n\nTChar8* RRuntime::IntToString8(TInt value, TChar8* pBuffer, TSize length){\n   TInt n = -1;\n   TChar* pResult = pBuffer;\n   if(value &lt; 0){\n      // 如果是负数就在首位添加负号，并将字符串前移\n      *pResult++ = '-';\n      // 转为正数\n      value = -value;\n   }\n   do{\n      // 循环转换每一个数字，直到结束\n      pResult[++n] = value % 10 + '0';\n      value /= 10;\n   }while(value &gt; 0);\n   // 转换结束后字符串是翻的，计算出一半的长度\n   TInt position = (n + 1) / 2;\n   while(position-- &gt; 0){\n      // 将字符串的字符序翻转\n      TChar temp = pResult[position];\n      pResult[position] = pResult[n - position];\n      pResult[n - position] = temp;\n   }\n   // 置结束符\n   pResult[n + 1] = '\0';\n   return pBuffer;\n}</Source>
                  </Method>
                  <Method name="IntToString16" type="static">
                     <Parameters>
                        <Parameter type="TInt" name="value"/>
                        <Parameter type="TChar16*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TChar16*"/>
                     <Source>//============================================================\n\nTChar16* RRuntime::IntToString16(TInt value, TChar16* pBuffer, TSize length){\n   TInt n = -1;\n   TChar16* pResult = pBuffer;\n   if(value &lt; 0){\n      // 如果是负数就在首位添加负号，并将字符串前移\n      *pResult++ = '-';\n      // 转为正数\n      value = -value;\n   }\n   do{\n      // 循环转换每一个数字，直到结束\n      pResult[++n] = value % 10 + '0';\n      value /= 10;\n   }while(value &gt; 0);\n   // 转换结束后字符串是翻的，计算出一半的长度\n   TInt position = (n + 1) / 2;\n   while(position-- &gt; 0){\n      // 将字符串的字符序翻转\n      TChar16 temp = pResult[position];\n      pResult[position] = pResult[n - position];\n      pResult[n - position] = temp;\n   }\n   // 置结束符\n   pResult[n + 1] = '\0';\n   return pBuffer;\n}</Source>
                  </Method>
                  <Method name="IntToString32" type="static">
                     <Parameters>
                        <Parameter type="TInt" name="value"/>
                        <Parameter type="TChar32*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TChar32*"/>
                     <Source>//============================================================\n\nTChar32* RRuntime::IntToString32(TInt value, TChar32* pBuffer, TSize length){\n   TInt n = -1;\n   TChar32* pResult = pBuffer;\n   if(value &lt; 0){\n      // 如果是负数就在首位添加负号，并将字符串前移\n      *pResult++ = '-';\n      // 转为正数\n      value = -value;\n   }\n   do{\n      // 循环转换每一个数字，直到结束\n      pResult[++n] = value % 10 + '0';\n      value /= 10;\n   }while(value &gt; 0);\n   // 转换结束后字符串是翻的，计算出一半的长度\n   TInt position = (n + 1) / 2;\n   while(position-- &gt; 0){\n      // 将字符串的字符序翻转\n      TChar32 temp = pResult[position];\n      pResult[position] = pResult[n - position];\n      pResult[n - position] = temp;\n   }\n   // 置结束符\n   pResult[n + 1] = '\0';\n   return pBuffer;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RShareMemory">
               <Methods>
                  <Method name="InnerCreate" type="static" description="创建一块共享内存。" note="如果以前存在，则产生例外退出。">
                     <Parameters>
                        <Parameter type="TShareKey" name="key" description="共享内存键值"/>
                        <Parameter type="TSize" name="size" description="内存大小"/>
                     </Parameters>
                     <Return type="TAny*" description="共享内存"/>
                     <Source>//============================================================\n// &lt;T&gt;创建一块共享内存。&lt;/T&gt;\n// &lt;P&gt;如果以前存在，则产生例外退出。&lt;/P&gt;\n//\n// @param key 共享内存键值\n// @param size 内存大小\n// @return 共享内存\n//============================================================\n\nTAny* RShareMemory::InnerCreate(TShareKey key, TSize size){\n#ifdef _LINUX\n   // 创建共享内存\n   TChar format[MO_MEMORY_FORMATLENGTH];\n   MO_STATIC_DEBUG(&quot;Create share memory. (key=0x%08X, size=%s)&quot;,\n         key, RInt::FormatCapacity(size, format, MO_MEMORY_FORMATLENGTH));\n   // 包含共享内存头信息的大小\n   size += sizeof(SShareMemoryInfo);\n   TInt handle = shmget(key, size, IPC_CREAT | IPC_EXCL | MO_SHARE_MEMORY_ACCESS);\n   if(handle &lt; 0){\n      MO_STATIC_PFATAL(shmget);\n   }\n   // 获得当前线程可以访问的内存\n   TByte* pMemory = (TByte*)shmat(handle, NULL, 0);\n   MO_ASSERT(pMemory);\n   // 设置信息\n   SShareMemoryInfo* pInfo = (SShareMemoryInfo*)pMemory;\n   memcpy(pInfo-&gt;flag, MO_SHARE_MEMORY_FLAG, sizeof(pInfo-&gt;flag));\n   pInfo-&gt;size = size;\n   pInfo-&gt;createDate = RDateTime::Current();\n   pInfo-&gt;updateDate = pInfo-&gt;createDate;\n   // 获得结果指针\n   TByte* pResult = pMemory + sizeof(SShareMemoryInfo);\n   memset(pResult, 0, size - sizeof(SShareMemoryInfo));\n   return pResult;\n#endif\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="MakeKey" type="static" description="生成一块共享内存的键值。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName" description="文件名称"/>
                        <Parameter type="TInt" name="id" description="标识"/>
                     </Parameters>
                     <Return type="TShareKey"/>
                     <Source>//============================================================\n// &lt;T&gt;生成一块共享内存的键值。&lt;/T&gt;\n//\n// @param pFileName 文件名称\n// @param id 标识\n//============================================================\n\nTShareKey RShareMemory::MakeKey(TCharC* pFileName, TInt id){\n#ifdef _LINUX\n   TShareKey key = ftok(pFileName, id);\n   if(key &lt; 0){\n      MO_STATIC_PFATAL(ftok);\n   }\n   return key;\n#endif\n   return -1;\n}</Source>
                  </Method>
                  <Method name="FetchInfo" type="static" description="获取共享内存的定义信息。">
                     <Parameters>
                        <Parameter type="TShareKey" name="key" description="共享内存键值"/>
                        <Parameter type="SShareMemoryInfo&amp;" name="info"/>
                     </Parameters>
                     <Return type="TBool" description="是否获取成功"/>
                     <Source>//============================================================\n// &lt;T&gt;获取共享内存的定义信息。&lt;/T&gt;\n//\n// @param key 共享内存键值\n// @param [out] info 定义信息\n// @return 是否获取成功\n//============================================================\n\nTBool RShareMemory::FetchInfo(TShareKey key, SShareMemoryInfo&amp; info){\n#ifdef _LINUX\n   MO_STATIC_DEBUG(&quot;Fetch info share memory info. (key=0x%08X)&quot;, key);\n   // 关联一块共享内存\n   TInt handle = shmget(key, 0, MO_SHARE_MEMORY_ACCESS);\n   if(handle &lt; 0){\n      return EFalse;\n   }\n   // 获得当前线程可以访问的内存\n   TByte* pMemory = (TByte*)shmat(handle, NULL, 0);\n   MO_ASSERT(pMemory);\n   SShareMemoryInfo* pInfo = (SShareMemoryInfo*)pMemory;\n   // 验证标志\n   if(0 != memcmp(pInfo-&gt;flag, MO_SHARE_MEMORY_FLAG, sizeof(pInfo-&gt;flag))){\n      MO_STATIC_DEBUG(&quot;Share memory is not system type memory. (key=0x%08X)&quot;, key);\n      return EFalse;\n   }\n   // 获取信息\n   info = *pInfo;\n   TChar format[MO_MEMORY_FORMATLENGTH];\n   MO_STATIC_DEBUG(&quot;Fetch share memory info success. (key=0x%08X, size=%s)&quot;,\n         key, RInt::FormatCapacity(info.size, format, MO_MEMORY_FORMATLENGTH));\n#endif\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="Create" type="static" description="创建一块指定大小的共享内存。" note="如果共享内存存在，则删除旧共享内存，重新创建指定大小的共享内存。">
                     <Parameters>
                        <Parameter type="TShareKey" name="key" description="共享内存键值"/>
                        <Parameter type="TSize" name="size" description="内存大小"/>
                     </Parameters>
                     <Return type="TAny*" description="共享内存"/>
                     <Source>//============================================================\n// &lt;T&gt;创建一块指定大小的共享内存。&lt;/T&gt;\n// &lt;P&gt;如果共享内存存在，则删除旧共享内存，重新创建指定大小的共享内存。&lt;/P&gt;\n//\n// @param key 共享内存键值\n// @param size 内存大小\n// @return 共享内存\n//============================================================\n\nTAny* RShareMemory::Create(TShareKey key, TSize size){\n#ifdef _LINUX\n   // 关联一块共享内存\n   TInt handle = shmget(key, 0, MO_SHARE_MEMORY_ACCESS);\n   if(handle &lt; 0){\n      MO_STATIC_PERROR(shmget);\n   }else{\n      // 获得当前线程可以访问的内存\n      TByte* pMemory = (TByte*)shmat(handle, NULL, 0);\n      MO_ASSERT(pMemory);\n      // 禁止本进程访问这块共享内存\n      if(ESuccess != shmdt(pMemory)){\n         MO_STATIC_PFATAL(shmdt);\n      }\n      // 删除共享内存句柄\n      MO_STATIC_DEBUG(&quot;Remove old share memory. (key=0x%08X)&quot;, key);\n      if(ESuccess != shmctl(handle, IPC_RMID, NULL)){\n         MO_STATIC_PFATAL(shmctl);\n      }\n   }\n#endif\n   // 创建共享内存\n   return InnerCreate(key, size);\n}</Source>
                  </Method>
                  <Method name="TryCreate" type="static" description="尝试创建一块共享内存。" note="如果共享内存大小一致，则直接使用旧共享内存。如果共享内存大小不一致，则删除旧共享内存，重新创建指定大小的共享内存。">
                     <Parameters>
                        <Parameter type="TShareKey" name="key" description="共享内存键值"/>
                        <Parameter type="TSize" name="size" description="内存大小"/>
                        <Parameter type="TBool&amp;" name="created" description="是否创建"/>
                     </Parameters>
                     <Return type="TAny*" description="共享内存"/>
                     <Source>//============================================================\n// &lt;T&gt;尝试创建一块共享内存。&lt;/T&gt;\n// &lt;P&gt;如果共享内存大小一致，则直接使用旧共享内存。&lt;/P&gt;\n// &lt;P&gt;如果共享内存大小不一致，则删除旧共享内存，重新创建指定大小的共享内存。&lt;/P&gt;\n//\n// @param key 共享内存键值\n// @param size 内存大小\n// @param created 是否创建\n// @return 共享内存\n//============================================================\n\nTAny* RShareMemory::TryCreate(TShareKey key, TSize size, TBool&amp; created){\n#ifdef _LINUX\n   MO_STATIC_DEBUG(&quot;Fetch info share memory info. (key=0x%08X)&quot;, key);\n   // 关联一块共享内存\n   TInt handle = shmget(key, 0, MO_SHARE_MEMORY_ACCESS);\n   if(handle &gt;= 0){\n      // 获得当前线程可以访问的内存\n      TByte* pMemory = (TByte*)shmat(handle, NULL, 0);\n      MO_ASSERT(pMemory);\n      SShareMemoryInfo* pInfo = (SShareMemoryInfo*)pMemory;\n      // 验证标志\n      if(memcmp(pInfo-&gt;flag, MO_SHARE_MEMORY_FLAG, sizeof(pInfo-&gt;flag))){\n         // 使用当前内存\n         if(pInfo-&gt;size == size){\n            created = EFalse;\n            return pMemory + sizeof(SShareMemoryInfo);\n         }\n      }\n      // 禁止本进程访问这块共享内存\n      if(ESuccess != shmdt(pMemory)){\n         MO_STATIC_PFATAL(shmdt);\n      }\n      // 删除共享内存句柄\n      MO_STATIC_DEBUG(&quot;Remove share memory. (key=0x%08X)&quot;, key);\n      if(ESuccess != shmctl(handle, IPC_RMID, NULL)){\n         MO_STATIC_PFATAL(shmctl);\n      }\n   }\n#endif\n   // 创建共享内存\n   created = ETrue;\n   return InnerCreate(key, size);\n}</Source>
                  </Method>
                  <Method name="Connect" type="static" description="链接一块共享内存。">
                     <Parameters>
                        <Parameter type="TShareKey" name="key" description="共享内存键值"/>
                     </Parameters>
                     <Return type="TAny*" description="共享内存"/>
                     <Source>//============================================================\n// &lt;T&gt;链接一块共享内存。&lt;/T&gt;\n//\n// @param key 共享内存键值\n// @return 共享内存\n//============================================================\n\nTAny* RShareMemory::Connect(TShareKey key){\n#ifdef _LINUX\n   MO_STATIC_DEBUG(&quot;Connect share memory. (key=0x%08X)&quot;, key);\n   // 关联一块共享内存\n   TInt handle = shmget(key, 0, MO_SHARE_MEMORY_ACCESS);\n   if(handle &lt; 0){\n      MO_STATIC_PFATAL(shmget);\n   }\n   // 获得当前线程可以访问的内存\n   TByte* pMemory = (TByte*)shmat(handle, NULL, 0);\n   MO_ASSERT(pMemory);\n   SShareMemoryInfo* pInfo = (SShareMemoryInfo*)pMemory;\n   // 验证标志\n   if(memcmp(pInfo-&gt;flag, MO_SHARE_MEMORY_FLAG, sizeof(pInfo-&gt;flag))){\n      MO_STATIC_DEBUG(&quot;Connect share memory failure. (key=0x%08X)&quot;, key);\n      return NULL;\n   }\n   TChar format[MO_MEMORY_FORMATLENGTH];\n   MO_STATIC_DEBUG(&quot;Connect share memory success. (key=0x%08X, memory=0x%08X, size=%s)&quot;,\n         key, pMemory, RInt::FormatCapacity(pInfo-&gt;size, format, MO_MEMORY_FORMATLENGTH));\n   return pMemory + sizeof(SShareMemoryInfo);\n#endif\n   return NULL;\n}</Source>
                  </Method>
                  <Method name="Free" type="static" description="释放一块共享内存。">
                     <Parameters>
                        <Parameter type="TShareKey" name="key" description="共享内存键值"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放一块共享内存。&lt;/T&gt;\n//\n// @param key 共享内存键值\n//============================================================\n\nvoid RShareMemory::Free(TShareKey key){\n#ifdef _LINUX\n   // 关联一块共享内存\n   TInt handle = shmget(key, 0, MO_SHARE_MEMORY_ACCESS);\n   if(handle &lt; 0){\n      MO_STATIC_PFATAL(shmget);\n   }\n   // 删除共享内存句柄\n   if(ESuccess != shmctl(handle, IPC_RMID, NULL)){\n      MO_STATIC_PFATAL(shmctl);\n   }\n   MO_STATIC_DEBUG(&quot;Free share memory. (key=0x%08X)&quot;, key);\n#endif\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RSharedSingleton">
               <Inherits>
                  <Inherit name="RSingleton" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Initialize" type="static" description="初始化对象的实例。">
                     <Return type="T*"/>
                     <Source>\nstatic T* Initialize(){\n      RSingleton&lt;T&gt;::Initialize();\n      RSingletonManager::Register(RSingleton&lt;T&gt;::_pInstance);\n   }</Source>
                  </Method>
                  <Method name="Release" type="static" description="释放对象的实例。">
                     <Return type="void"/>
                     <Source>\nstatic void Release(){\n      RSingletonManager::Unregister(RSingleton&lt;T&gt;::_pInstance);\n      RSingleton&lt;T&gt;::Release();\n   }</Source>
                  </Method>
                  <Method name="SharedCapacity" type="static" description="计算需要共享内存的大小。">
                     <Return type="TSize"/>
                     <Source>\nstatic TSize SharedCapacity(){\n      return RSingleton&lt;T&gt;::_pInstance-&gt;SharedCapacity();\n   }</Source>
                  </Method>
                  <Method name="SharedLink" type="static" description="初始化对象的实例。">
                     <Parameters>
                        <Parameter type="TShareSegment" name="segment"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void SharedLink(TShareSegment segment){\n      RSingleton&lt;T&gt;::_pInstance-&gt;SharedLink(segment);\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RSingleton">
               <Methods>
                  <Method name="Instance" type="static" description="获得对象的实例。">
                     <Return type="T&amp;"/>
                     <Source>\nstatic T&amp; Instance(){\n      return *_pInstance;\n   }</Source>
                  </Method>
                  <Method name="InstancePtr" type="static" description="获得对象的实例指针。">
                     <Return type="T*"/>
                     <Source>\nstatic T* InstancePtr(){\n      return _pInstance;\n   }</Source>
                  </Method>
                  <Method name="Create" type="static" description="初始化对象的实例。">
                     <Return type="void"/>
                     <Source>\nstatic void Create(){\n      MO_ASSERT(NULL == _pInstance);\n      _pInstance = MO_PTR_CREATE(T);\n      TClassInfo info = typeid(T).name();\n      MO_STATIC_DEBUG(&quot;Initialize singleton instance. (instance=0x%08X, class=%s)&quot;,\n            _pInstance, info.FullName());\n      RSingletonManager::Register(_pInstance);\n   }</Source>
                  </Method>
                  <Method name="Destroy" type="static" description="释放对象的实例。">
                     <Return type="void"/>
                     <Source>\nstatic void Destroy(){\n      MO_ASSERT(_pInstance);\n      RSingletonManager::Unregister(_pInstance);\n      TClassInfo info = typeid(T).name();\n      MO_STATIC_DEBUG(&quot;Release singleton instance. (instance=0x%08X, class=%s)&quot;,\n            _pInstance, info.FullName());\n      MO_PTR_DELETE(_pInstance);\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T*" name="_pInstance"/>
               </Attributes>
            </Class>
            <Class name="RSingletonManager">
               <Methods>
                  <Method name="Instance" type="static" description="获得对象的实例。">
                     <Return type="FSingletonConsole&amp;" description="实例"/>
                     <Source>//============================================================\n\n//============================================================\n// &lt;T&gt;获得对象的实例。&lt;/T&gt;\n//\n// @return 实例\n//============================================================\n\nFSingletonConsole&amp; RSingletonManager::Instance(){\n   return *_pInstance;\n}</Source>
                  </Method>
                  <Method name="InstancePtr" type="static" description="获得对象的实例指针。">
                     <Return type="FSingletonConsole*" description="实例指针"/>
                     <Source>//============================================================\n// &lt;T&gt;获得对象的实例指针。&lt;/T&gt;\n//\n// @return 实例指针\n//============================================================\n\nFSingletonConsole* RSingletonManager::InstancePtr(){\n   return _pInstance;\n}</Source>
                  </Method>
                  <Method name="Create" type="static" description="初始化对象的实例。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;初始化对象的实例。&lt;/T&gt;\n//============================================================\n\nvoid RSingletonManager::Create(){\n   _pInstance = MO_PTR_CREATE(FSingletonConsole);\n}</Source>
                  </Method>
                  <Method name="Destroy" type="static" description="释放对象的实例。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放对象的实例。&lt;/T&gt;\n//============================================================\n\nvoid RSingletonManager::Destroy(){\n   MO_PTR_DELETE(_pInstance);\n}</Source>
                  </Method>
                  <Method name="Register" type="static" description="注册唯一对象。">
                     <Parameters>
                        <Parameter type="ISingleton*" name="pSingleton" description="唯一对象列表"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;注册唯一对象。&lt;/T&gt;\n//\n// @param pSingleton 唯一对象列表\n//============================================================\n\nvoid RSingletonManager::Register(ISingleton* pSingleton){\n   _pInstance-&gt;Register(pSingleton);\n}</Source>
                  </Method>
                  <Method name="Unregister" type="static" description="注销唯一对象列表。">
                     <Parameters>
                        <Parameter type="ISingleton*" name="pSingleton" description="唯一对象列表"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;注销唯一对象列表。&lt;/T&gt;\n//\n// @param pSingleton 唯一对象列表\n//============================================================\n\nvoid RSingletonManager::Unregister(ISingleton* pSingleton){\n   _pInstance-&gt;Unregister(pSingleton);\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FSingletonConsole*" name="_pInstance"/>
               </Attributes>
            </Class>
            <Class name="RString16">
               <Methods>
                  <Method name="Empty" type="static" description="空字符串。将数字变换为字符串。">
                     <Return type="MString16C&amp;" description="字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;空字符串。&lt;/T&gt;\n//============================================================\n\n//============================================================\n// &lt;T&gt;将数字变换为字符串。&lt;/T&gt;\n//\n// @param value ANSI字符串\n// @return 字符串\n//============================================================\n\nMString16C&amp; RString16::Empty(){\n   return _empty;\n}</Source>
                  </Method>
                  <Method name="Length" type="static" description="获取ANSI字符串的长度。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValues"/>
                     </Parameters>
                     <Return type="TInt" description="长度"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的长度。&lt;/T&gt;\n//\n// @param pSource ANSI字符串\n// @return 长度\n//============================================================\n\nTInt RString16::Length(TChar16C* pValues){\n   MO_ASSERT(pValues);\n   return wcslen(pValues);\n}</Source>
                  </Method>
                  <Method name="MakeHashCode" type="static" description="获取ANSI字符串的哈希值。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValues" description="ANSI字符串"/>
                     </Parameters>
                     <Return type="THashCode" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的哈希值。&lt;/T&gt;\n//\n// @param pValues ANSI字符串\n// @return 哈希值\n//============================================================\n\nTHashCode RString16::MakeHashCode(TChar16C* pValues){\n   MO_ASSERT(pValues);\n   return RTypes&lt;TChar16&gt;::MakeHashCode(pValues, wcslen(pValues));\n}</Source>
                  </Method>
                  <Method name="MakeNocaseHashCode" type="static" description="获取ANSI字符串的不区分大小写的哈希值。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValues" description="ANSI字符串"/>
                     </Parameters>
                     <Return type="THashCode" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的不区分大小写的哈希值。&lt;/T&gt;\n//\n// @param pValues ANSI字符串\n// @return 哈希值\n//============================================================\n\nTHashCode RString16::MakeNocaseHashCode(TChar16C* pValues){\n   MO_ASSERT(pValues);\n   THashCode hash = 0;\n   TInt length = wcslen(pValues);\n   while(--length &gt;= 0){\n      hash += (hash &lt;&lt; 4) + (hash &lt;&lt; 3) + (hash &lt;&lt; 2) + (hash &lt;&lt; 1) + tolower(pValues[length]);\n   }\n   return hash;\n}</Source>
                  </Method>
                  <Method name="AllocCopy" type="static" description="获取ANSI字符串的哈希值。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValues"/>
                        <Parameter type="TChar16**" name="ppTarget"/>
                     </Parameters>
                     <Return type="TBool" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的哈希值。&lt;/T&gt;\n//\n// @param ptr ANSI字符串指针\n// @return 哈希值\n//============================================================\n\nTBool RString16::AllocCopy(TChar16C* pValues, TChar16** ppTarget){\n   if(NULL != pValues){\n      TSize length = wcslen(pValues) + 1;\n      TChar16* pAlloc = RTypeMemory&lt;TChar16&gt;::Alloc(length);\n      MO_ASSERT(pAlloc);\n      MO_LIB_MEMCPY(pAlloc, length, pValues, length);\n      *ppTarget = pAlloc;\n   }\n	return ETrue;\n}</Source>
                  </Method>
                  <Method name="AllocFree" type="static">
                     <Parameters>
                        <Parameter type="TChar16*" name="pValues"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool RString16::AllocFree(TChar16* pValues){\n   RTypeMemory&lt;TChar16&gt;::Free(pValues);\n	return ETrue;\n}</Source>
                  </Method>
                  <Method name="SafeCopy" type="static" description="安全复制字符串到目标字符串。" note="如果目标字符串或值字符串为空，则不进行复制。如果目标字符串长度不足，则只复制能复制的部分数据。复制后，末尾字符总是留空。">
                     <Parameters>
                        <Parameter type="TChar16*" name="pTarget" description="目标字符串指针"/>
                        <Parameter type="TSize" name="size" description="目标字符窜长度"/>
                        <Parameter type="TChar16C*" name="pValue" description="值字符串指针"/>
                     </Parameters>
                     <Return type="TInt" description="复制长度"/>
                     <Source>//============================================================\n// &lt;T&gt;安全复制字符串到目标字符串。&lt;/T&gt;\n// &lt;P&gt;如果目标字符串或值字符串为空，则不进行复制。&lt;/P&gt;\n// &lt;P&gt;如果目标字符串长度不足，则只复制能复制的部分数据。&lt;/P&gt;\n// &lt;P&gt;复制后，末尾字符总是留空。&lt;/P&gt;\n//\n// @param pTarget 目标字符串指针\n// @param size 目标字符窜长度\n// @param pValue 值字符串指针\n// @return 复制长度\n//============================================================\n\nTInt RString16::SafeCopy(TChar16* pTarget, TSize size, TChar16C* pValue){\n   if((NULL != pTarget) &amp;&amp; (size &gt; 0) &amp;&amp; (NULL != pValue)){\n      TSize length = wcslen(pValue);\n      if(length &gt; 0){\n         if(length &gt;= size){\n            length = size - 1;\n         }\n         memcpy(pTarget, pValue, length);\n         pTarget[length] = 0;\n      }else{\n         pTarget[0] = 0;\n      }\n      return length;\n   }\n   return 0;\n}</Source>
                  </Method>
                  <Method name="ForceCopy" type="static" description="强制复制字符串到目标字符串。" note="如果目标字符串为空，产生例外。如果值字符串为空，返回成功。如果目标字符串长度不足，产生例外。复制后，末尾字符总是留空。">
                     <Parameters>
                        <Parameter type="TChar16*" name="pTarget" description="目标字符串指针"/>
                        <Parameter type="TSize" name="size" description="目标字符窜长度"/>
                        <Parameter type="TChar16C*" name="pValue" description="值字符串指针"/>
                     </Parameters>
                     <Return type="TInt" description="复制长度"/>
                     <Source>//============================================================\n// &lt;T&gt;强制复制字符串到目标字符串。&lt;/T&gt;\n// &lt;P&gt;如果目标字符串为空，产生例外。&lt;/P&gt;\n// &lt;P&gt;如果值字符串为空，返回成功。&lt;/P&gt;\n// &lt;P&gt;如果目标字符串长度不足，产生例外。&lt;/P&gt;\n// &lt;P&gt;复制后，末尾字符总是留空。&lt;/P&gt;\n//\n// @param pTarget 目标字符串指针\n// @param size 目标字符窜长度\n// @param pValue 值字符串指针\n// @return 复制长度\n//============================================================\n\nTInt RString16::ForceCopy(TChar16* pTarget, TSize size, TChar16C* pValue){\n   MO_ASSERT(pTarget);\n   MO_ASSERT(size &gt; 0);\n   if(NULL != pValue){\n      TSize length = wcslen(pValue);\n      if(length &gt; 0){\n         MO_ASSERT(length &lt; size);\n         memcpy(pTarget, pValue, length);\n         pTarget[length] = 0;\n         return length;\n      }\n   }\n   return 0;\n}</Source>
                  </Method>
                  <Method name="ConvertToString8" type="static" description="获得将宽字符字符串转化为8位字符串所需要的长度">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue" description="被转换字符串"/>
                     </Parameters>
                     <Return type="TInt" description="所需要长度失败返回0"/>
                     <Source>//============================================================\n// &lt;T&gt;获得将宽字符字符串转化为8位字符串所需要的长度&lt;/T&gt;\n//\n// @param pValue 被转换字符串\n// @return 所需要长度失败返回0\n//============================================================\n\nTInt RString16::ConvertToString8(TChar16C* pValue){\n   MO_ASSERT(pValue);\n   TSize length = wcslen(pValue);\n   TSize tempLen = length;\n   WideCharToMultiByte(MO_CP_ACP, 0, pValue, tempLen, NULL, 0, NULL, FALSE);\n   return length;\n}</Source>
                  </Method>
                  <Method name="ConvertToString8" type="static" description="将宽字符字符串转化为8位字符串">
                     <Parameters>
                        <Parameter type="TChar8*" name="pTarget"/>
                        <Parameter type="TSize" name="size" description="pTarget容量"/>
                        <Parameter type="TChar16C*" name="pValue" description="被转换字符串"/>
                     </Parameters>
                     <Return type="TInt" description="所需要长度，如果失败返回0"/>
                     <Source>//============================================================\n// &lt;T&gt;将宽字符字符串转化为8位字符串&lt;/T&gt;\n//\n// @param pTarget转换后的字符串\n// @param size pTarget容量\n// @param pValue 被转换字符串\n// @return 所需要长度，如果失败返回0\n//============================================================\n\nTInt RString16::ConvertToString8(TChar8* pTarget, TSize size, TChar16C* pValue){\n   MO_ASSERT(pTarget);\n   MO_ASSERT(pValue);\n   TSize length = wcslen(pValue);\n   return WideCharToMultiByte(MO_CP_ACP, 0, pValue, length, pTarget, size, NULL, FALSE);\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TString16" name="_empty"/>
               </Attributes>
            </Class>
            <Class name="RString32">
               <Methods>
                  <Method name="Empty" type="static" description="空字符串。将数字变换为字符串。">
                     <Return type="MString32C&amp;" description="字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;空字符串。&lt;/T&gt;\n//============================================================\n\n//============================================================\n// &lt;T&gt;将数字变换为字符串。&lt;/T&gt;\n//\n// @param value ANSI字符串\n// @return 字符串\n//============================================================\n\nMString32C&amp; RString32::Empty(){\n   return _empty;\n}</Source>
                  </Method>
                  <Method name="Length" type="static" description="获取ANSI字符串的长度。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValues"/>
                     </Parameters>
                     <Return type="TInt" description="长度"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的长度。&lt;/T&gt;\n//\n// @param pSource ANSI字符串\n// @return 长度\n//============================================================\n\nTInt RString32::Length(TChar32C* pValues){\n   MO_ASSERT(pValues);\n   return wcslen(pValues);\n}</Source>
                  </Method>
                  <Method name="MakeHashCode" type="static" description="获取ANSI字符串的哈希值。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValues" description="ANSI字符串"/>
                     </Parameters>
                     <Return type="THashCode" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的哈希值。&lt;/T&gt;\n//\n// @param pValues ANSI字符串\n// @return 哈希值\n//============================================================\n\nTHashCode RString32::MakeHashCode(TChar32C* pValues){\n   MO_ASSERT(pValues);\n   return RTypes&lt;TChar32&gt;::MakeHashCode(pValues, wcslen(pValues));\n}</Source>
                  </Method>
                  <Method name="MakeNocaseHashCode" type="static" description="获取ANSI字符串的不区分大小写的哈希值。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValues" description="ANSI字符串"/>
                     </Parameters>
                     <Return type="THashCode" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的不区分大小写的哈希值。&lt;/T&gt;\n//\n// @param pValues ANSI字符串\n// @return 哈希值\n//============================================================\n\nTHashCode RString32::MakeNocaseHashCode(TChar32C* pValues){\n   MO_ASSERT(pValues);\n   THashCode hash = 0;\n   TInt length = wcslen(pValues);\n   while(--length &gt;= 0){\n      hash += (hash &lt;&lt; 4) + (hash &lt;&lt; 3) + (hash &lt;&lt; 2) + (hash &lt;&lt; 1) + towlower(pValues[length]);\n   }\n   return hash;\n}</Source>
                  </Method>
                  <Method name="AllocCopy" type="static" description="获取ANSI字符串的哈希值。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValues"/>
                        <Parameter type="TChar32**" name="ppTarget"/>
                     </Parameters>
                     <Return type="TBool" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的哈希值。&lt;/T&gt;\n//\n// @param ptr ANSI字符串指针\n// @return 哈希值\n//============================================================\n\nTBool RString32::AllocCopy(TChar32C* pValues, TChar32** ppTarget){\n   if(NULL != pValues){\n      TSize length = wcslen(pValues) + 1;\n      TChar32* pAlloc = RTypeMemory&lt;TChar32&gt;::Alloc(length);\n      MO_ASSERT(pAlloc);\n      MO_LIB_MEMCPY(pAlloc, length, pValues, length);\n      *ppTarget = pAlloc;\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="AllocFree" type="static">
                     <Parameters>
                        <Parameter type="TChar32*" name="pValues"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool RString32::AllocFree(TChar32* pValues){\n   RTypeMemory&lt;TChar32&gt;::Free(pValues);\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="SafeCopy" type="static" description="安全复制字符串到目标字符串。" note="如果目标字符串或值字符串为空，则不进行复制。如果目标字符串长度不足，则只复制能复制的部分数据。复制后，末尾字符总是留空。">
                     <Parameters>
                        <Parameter type="TChar32*" name="pTarget" description="目标字符串指针"/>
                        <Parameter type="TSize" name="size" description="目标字符窜长度"/>
                        <Parameter type="TChar32C*" name="pValue" description="值字符串指针"/>
                     </Parameters>
                     <Return type="TInt" description="复制长度"/>
                     <Source>//============================================================\n// &lt;T&gt;安全复制字符串到目标字符串。&lt;/T&gt;\n// &lt;P&gt;如果目标字符串或值字符串为空，则不进行复制。&lt;/P&gt;\n// &lt;P&gt;如果目标字符串长度不足，则只复制能复制的部分数据。&lt;/P&gt;\n// &lt;P&gt;复制后，末尾字符总是留空。&lt;/P&gt;\n//\n// @param pTarget 目标字符串指针\n// @param size 目标字符窜长度\n// @param pValue 值字符串指针\n// @return 复制长度\n//============================================================\n\nTInt RString32::SafeCopy(TChar32* pTarget, TSize size, TChar32C* pValue){\n   if((NULL != pTarget) &amp;&amp; (size &gt; 0) &amp;&amp; (NULL != pValue)){\n      TSize length = wcslen(pValue);\n      if(length &gt; 0){\n         if(length &gt;= size){\n            length = size - 1;\n         }\n         memcpy(pTarget, pValue, length);\n         pTarget[length] = 0;\n      }else{\n         pTarget[0] = 0;\n      }\n      return length;\n   }\n   return 0;\n}</Source>
                  </Method>
                  <Method name="ForceCopy" type="static" description="强制复制字符串到目标字符串。" note="如果目标字符串为空，产生例外。如果值字符串为空，返回成功。如果目标字符串长度不足，产生例外。复制后，末尾字符总是留空。">
                     <Parameters>
                        <Parameter type="TChar32*" name="pTarget" description="目标字符串指针"/>
                        <Parameter type="TSize" name="size" description="目标字符窜长度"/>
                        <Parameter type="TChar32C*" name="pValue" description="值字符串指针"/>
                     </Parameters>
                     <Return type="TInt" description="复制长度"/>
                     <Source>//============================================================\n// &lt;T&gt;强制复制字符串到目标字符串。&lt;/T&gt;\n// &lt;P&gt;如果目标字符串为空，产生例外。&lt;/P&gt;\n// &lt;P&gt;如果值字符串为空，返回成功。&lt;/P&gt;\n// &lt;P&gt;如果目标字符串长度不足，产生例外。&lt;/P&gt;\n// &lt;P&gt;复制后，末尾字符总是留空。&lt;/P&gt;\n//\n// @param pTarget 目标字符串指针\n// @param size 目标字符窜长度\n// @param pValue 值字符串指针\n// @return 复制长度\n//============================================================\n\nTInt RString32::ForceCopy(TChar32* pTarget, TSize size, TChar32C* pValue){\n   MO_ASSERT(pTarget);\n   MO_ASSERT(size &gt; 0);\n   if(NULL != pValue){\n      TSize length = wcslen(pValue);\n      if(length &gt; 0){\n         MO_ASSERT(length &lt; size);\n         memcpy(pTarget, pValue, length);\n         pTarget[length] = 0;\n         return length;\n      }\n   }\n   return 0;\n}</Source>
                  </Method>
                  <Method name="ConvertToString8" type="static" description="获得将字符串转化为8位字符串所需要的长度">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue" description="被转换字符串"/>
                     </Parameters>
                     <Return type="TInt" description="所需要长度"/>
                     <Source>//============================================================\n// &lt;T&gt;获得将字符串转化为8位字符串所需要的长度&lt;/T&gt;\n//\n// @param pValue 被转换字符串\n// @return 所需要长度\n//============================================================\n\nTInt RString32::ConvertToString8(TChar32C* pValue){\n   MO_ASSERT(pValue);\n   TSize length = wcslen(pValue) + 1;\n   return length;\n}</Source>
                  </Method>
                  <Method name="ConvertToString8" type="static" description="将字符串转化为8位字符串">
                     <Parameters>
                        <Parameter type="TChar8*" name="pTarget"/>
                        <Parameter type="TSize" name="size" description="pTarget容量"/>
                        <Parameter type="TChar32C*" name="pValue" description="被转换字符串"/>
                     </Parameters>
                     <Return type="TInt" description="所需要长度，如果失败返回-1"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串转化为8位字符串&lt;/T&gt;\n//\n// @param pTarget转换后的字符串\n// @param size pTarget容量\n// @param pValue 被转换字符串\n// @return 所需要长度，如果失败返回-1\n//============================================================\n\nTInt RString32::ConvertToString8(TChar8* pTarget, TSize size, TChar32C* pValue){\n   // 打开转换器\n   iconv_t cd = iconv_open(&quot;ASCII&quot;, &quot;WCHAR_T&quot;);\n   if(iconv_t(-1) == cd){\n      MO_STATIC_ERROR(&quot;iconv_open fail!&quot;);\n   }\n   // 转换字符串\n   TChar8* pInput = (TChar8*)&amp;pValue;\n   TChar8* pOutput = pTarget;\n   TUint convertCount;\n   TUint length = wcslen(pValue);\n   TInt result = iconv(cd, &amp;pInput, &amp;length, &amp;pOutput, &amp;convertCount);\n   if(-1 == result){\n      MO_STATIC_ERROR(&quot;iconv error!&quot;);\n   }\n   pTarget[convertCount] = 0;\n   // 关闭转换器\n   iconv_close(cd);\n   return result;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TString32" name="_empty"/>
               </Attributes>
            </Class>
            <Class name="RString8">
               <Methods>
                  <Method name="Empty" type="static" description="空字符串。将数字变换为字符串。">
                     <Return type="MString8C&amp;" description="字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;空字符串。&lt;/T&gt;\n//============================================================\n\n//============================================================\n// &lt;T&gt;将数字变换为字符串。&lt;/T&gt;\n//\n// @param value ANSI字符串\n// @return 字符串\n//============================================================\n\nMString8C&amp; RString8::Empty(){\n   return _empty;\n}</Source>
                  </Method>
                  <Method name="Length" type="static" description="获取ANSI字符串的长度。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValues"/>
                     </Parameters>
                     <Return type="TInt" description="长度"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的长度。&lt;/T&gt;\n//\n// @param pSource ANSI字符串\n// @return 长度\n//============================================================\n\nTInt RString8::Length(TChar8C* pValues){\n   MO_ASSERT(pValues);\n   return strlen(pValues);\n}</Source>
                  </Method>
                  <Method name="MakeHashCode" type="static" description="获取ANSI字符串的哈希值。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValues" description="ANSI字符串"/>
                     </Parameters>
                     <Return type="THashCode" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的哈希值。&lt;/T&gt;\n//\n// @param pValues ANSI字符串\n// @return 哈希值\n//============================================================\n\nTHashCode RString8::MakeHashCode(TChar8C* pValues){\n   MO_ASSERT(pValues);\n   return RTypes&lt;TChar8&gt;::MakeHashCode(pValues, strlen(pValues));\n}</Source>
                  </Method>
                  <Method name="MakeNocaseHashCode" type="static" description="获取ANSI字符串的不区分大小写的哈希值。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValues" description="ANSI字符串"/>
                     </Parameters>
                     <Return type="THashCode" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的不区分大小写的哈希值。&lt;/T&gt;\n//\n// @param pValues ANSI字符串\n// @return 哈希值\n//============================================================\n\nTHashCode RString8::MakeNocaseHashCode(TChar8C* pValues){\n   MO_ASSERT(pValues);\n   THashCode hash = 0;\n   TInt length = strlen(pValues);\n   while(--length &gt;= 0){\n      hash += (hash &lt;&lt; 4) + (hash &lt;&lt; 3) + (hash &lt;&lt; 2) + (hash &lt;&lt; 1) + tolower(pValues[length]);\n   }\n   return hash;\n}</Source>
                  </Method>
                  <Method name="AllocCopy" type="static" description="获取ANSI字符串的哈希值。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValues"/>
                        <Parameter type="TChar8**" name="ppTarget"/>
                     </Parameters>
                     <Return type="TBool" description="哈希值"/>
                     <Source>//============================================================\n// &lt;T&gt;获取ANSI字符串的哈希值。&lt;/T&gt;\n//\n// @param ptr ANSI字符串指针\n// @return 哈希值\n//============================================================\n\nTBool RString8::AllocCopy(TChar8C* pValues, TChar8** ppTarget){\n   if(NULL != pValues){\n      TSize length = strlen(pValues) + 1;\n      TChar8* pAlloc = RTypeMemory&lt;TChar8&gt;::Alloc(length);\n      MO_ASSERT(pAlloc);\n      MO_LIB_MEMCPY(pAlloc, length, pValues, length);\n      *ppTarget = pAlloc;\n   }\n	return ETrue;\n}</Source>
                  </Method>
                  <Method name="AllocFree" type="static">
                     <Parameters>
                        <Parameter type="TChar8*" name="pValues"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool RString8::AllocFree(TChar8* pValues){\n   RTypeMemory&lt;TChar8&gt;::Free(pValues);\n	return ETrue;\n}</Source>
                  </Method>
                  <Method name="SafeCopy" type="static" description="安全复制字符串到目标字符串。" note="如果目标字符串或值字符串为空，则不进行复制。如果目标字符串长度不足，则只复制能复制的部分数据。复制后，末尾字符总是留空。">
                     <Parameters>
                        <Parameter type="TChar8*" name="pTarget" description="目标字符串指针"/>
                        <Parameter type="TSize" name="size" description="目标字符窜长度"/>
                        <Parameter type="TChar8C*" name="pValue" description="值字符串指针"/>
                     </Parameters>
                     <Return type="TInt" description="复制长度"/>
                     <Source>//============================================================\n// &lt;T&gt;安全复制字符串到目标字符串。&lt;/T&gt;\n// &lt;P&gt;如果目标字符串或值字符串为空，则不进行复制。&lt;/P&gt;\n// &lt;P&gt;如果目标字符串长度不足，则只复制能复制的部分数据。&lt;/P&gt;\n// &lt;P&gt;复制后，末尾字符总是留空。&lt;/P&gt;\n//\n// @param pTarget 目标字符串指针\n// @param size 目标字符窜长度\n// @param pValue 值字符串指针\n// @return 复制长度\n//============================================================\n\nTInt RString8::SafeCopy(TChar8* pTarget, TSize size, TChar8C* pValue){\n   if((NULL != pTarget) &amp;&amp; (size &gt; 0) &amp;&amp; (NULL != pValue)){\n      TSize length = strlen(pValue);\n      if(length &gt; 0){\n         if(length &gt;= size){\n            length = size - 1;\n         }\n         memcpy(pTarget, pValue, length);\n         pTarget[length] = 0;\n      }else{\n         pTarget[0] = 0;\n      }\n      return length;\n   }\n   return 0;\n}</Source>
                  </Method>
                  <Method name="ForceCopy" type="static" description="强制复制字符串到目标字符串。" note="如果目标字符串为空，产生例外。如果值字符串为空，返回成功。如果目标字符串长度不足，产生例外。复制后，末尾字符总是留空。">
                     <Parameters>
                        <Parameter type="TChar8*" name="pTarget" description="目标字符串指针"/>
                        <Parameter type="TSize" name="size" description="目标字符窜长度"/>
                        <Parameter type="TChar8C*" name="pValue" description="值字符串指针"/>
                     </Parameters>
                     <Return type="TInt" description="复制长度"/>
                     <Source>//============================================================\n// &lt;T&gt;强制复制字符串到目标字符串。&lt;/T&gt;\n// &lt;P&gt;如果目标字符串为空，产生例外。&lt;/P&gt;\n// &lt;P&gt;如果值字符串为空，返回成功。&lt;/P&gt;\n// &lt;P&gt;如果目标字符串长度不足，产生例外。&lt;/P&gt;\n// &lt;P&gt;复制后，末尾字符总是留空。&lt;/P&gt;\n//\n// @param pTarget 目标字符串指针\n// @param size 目标字符窜长度\n// @param pValue 值字符串指针\n// @return 复制长度\n//============================================================\n\nTInt RString8::ForceCopy(TChar8* pTarget, TSize size, TChar8C* pValue){\n   MO_ASSERT(pTarget);\n   MO_ASSERT(size &gt; 0);\n   if(NULL != pValue){\n      TSize length = strlen(pValue);\n      if(length &gt; 0){\n         MO_ASSERT(length &lt; size);\n         memcpy(pTarget, pValue, length);\n         pTarget[length] = 0;\n         return length;\n      }\n   }\n   return 0;\n}</Source>
                  </Method>
                  <Method name="ConvertToString16" type="static" description="获得将字符串转化为16位字符串所需要的长度">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue" description="被转换字符串"/>
                     </Parameters>
                     <Return type="TInt" description="所需要长度"/>
                     <Source>//============================================================\n// &lt;T&gt;获得将字符串转化为16位字符串所需要的长度&lt;/T&gt;\n//\n// @param pValue 被转换字符串\n// @return 所需要长度\n//============================================================\n\nTInt RString8::ConvertToString16(TChar8C* pValue){\n   MO_ASSERT(pValue);\n   TSize length = strlen(pValue);\n   TSize tempLen = length;\n   MultiByteToWideChar(MO_CP_ACP, 0, pValue, tempLen, NULL, 0);\n   return length;\n}</Source>
                  </Method>
                  <Method name="ConvertToString16" type="static" description="将字符串转化为16位字符串">
                     <Parameters>
                        <Parameter type="TChar16*" name="pTarget"/>
                        <Parameter type="TSize" name="size" description="pTarget容量"/>
                        <Parameter type="TChar8C*" name="pValue" description="被转换字符串"/>
                     </Parameters>
                     <Return type="TInt" description="所需要长度，如果失败返回-1"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串转化为16位字符串&lt;/T&gt;\n//\n// @param pTarget转换后的字符串\n// @param size pTarget容量\n// @param pValue 被转换字符串\n// @return 所需要长度，如果失败返回-1\n//============================================================\n\nTInt RString8::ConvertToString16(TChar16* pTarget, TSize size, TChar8C* pValue){\n   MO_ASSERT(pTarget);\n   MO_ASSERT(pValue);\n   TSize length = strlen(pValue);\n   return MultiByteToWideChar(MO_CP_ACP, 0, pValue, length, pTarget, size);\n}</Source>
                  </Method>
                  <Method name="ConvertToString32" type="static" description="获得将字符串转化为32位字符串所需要的长度">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue" description="被转换字符串"/>
                     </Parameters>
                     <Return type="TInt" description="所需要长度"/>
                     <Source>//============================================================\n// &lt;T&gt;获得将字符串转化为32位字符串所需要的长度&lt;/T&gt;\n//\n// @param pValue 被转换字符串\n// @return 所需要长度\n//============================================================\n\nTInt RString8::ConvertToString32(TChar8C* pValue){\n   MO_ASSERT(pValue);\n   TSize outLength = strlen(pValue) + 1;\n   return outLength;\n}</Source>
                  </Method>
                  <Method name="ConvertToString32" type="static" description="将字符串转化为16位字符串">
                     <Parameters>
                        <Parameter type="TChar32*" name="pTarget"/>
                        <Parameter type="TSize" name="size" description="pTarget容量"/>
                        <Parameter type="TChar8C*" name="pValue" description="被转换字符串"/>
                     </Parameters>
                     <Return type="TInt" description="所需要长度，如果失败返回-1"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串转化为16位字符串&lt;/T&gt;\n//\n// @param pTarget转换后的字符串\n// @param size pTarget容量\n// @param pValue 被转换字符串\n// @return 所需要长度，如果失败返回-1\n//============================================================\n\nTInt RString8::ConvertToString32(TChar32* pTarget, TSize size, TChar8C* pValue){\n   TUint inLength = strlen(pValue);\n   TUint outLength = inLength + 1;\n   TUint tempLength = outLength * 4;//iconv最后一个参数表示pOut的字节数，所以要乘以4\n   MO_ASSERT(size &gt;= outLength);\n   TChar8* pIn = (TChar8*)&amp;pValue;\n   TChar32* pOut = pTarget;\n\n   iconv_t cd = iconv_open(&quot;WCHAR_T&quot;, &quot;ASSII&quot;);\n   if(iconv_t(-1) == cd){\n      MO_STATIC_ERROR(&quot;iconv_open fail!&quot;);\n   }\n   int result = iconv(cd, &amp;pIn, &amp;inLength, (TChar8**)&amp;pOut, &amp;tempLength);\n   if(-1 == result){\n      MO_STATIC_ERROR(&quot;iconv error!&quot;);\n      return -1;\n   }\n   pTarget[outLength] = 0;\n   iconv_close(cd);\n   return outLength;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TString8" name="_empty"/>
               </Attributes>
            </Class>
            <Class name="RThread">
               <Methods>
                  <Method name="CurrentId" type="static" description="获得线程标识。">
                     <Return type="TThreadId" description="线程标识"/>
                     <Source>//============================================================\n// &lt;T&gt;获得线程标识。&lt;/T&gt;\n//\n// @static\n// @return 线程标识\n//============================================================\n\nTThreadId RThread::CurrentId(){\n#ifdef _WINDOWS\n   TThreadId id = GetCurrentThreadId();\n#else\n   TThreadId id = pthread_self();\n#endif\n   return id;\n}</Source>
                  </Method>
                  <Method name="Process" type="static" description="在线程中运行指定函数。">
                     <Parameters>
                        <Parameter type="CRunable" name="cRunable" description="可运行函数"/>
                     </Parameters>
                     <Return type="IThread*"/>
                     <Source>//============================================================\n// &lt;T&gt;在线程中运行指定函数。&lt;/T&gt;\n//\n// @static\n// @param cRunable 可运行函数\n//============================================================\n\nIThread* RThread::Process(CRunable cRunable){\n   FThreadRunable* pThread = MO_CREATE(FThreadRunable, cRunable);\n   pThread-&gt;Start();\n   return pThread;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RTime">
               <Methods>
                  <Method name="Current" type="static">
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\nTDateTime RTime::Current(){\n   return 0;\n}</Source>
                  </Method>
                  <Method name="Parse" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\nTDateTime RTime::Parse(TCharC* pValue){\n   MO_ASSERT(pValue);\n   return 0;\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\nTDateTime RTime::ParseNvl(TCharC* pValue){\n   return 0;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RTimeSpan"/>
            <Class name="RTimeTick">
               <Methods>
                  <Method name="Current" type="static" description="获得当前时间刻度(微秒)。">
                     <Return type="TTimeTick" description="时间刻度"/>
                     <Source>//============================================================\n// &lt;T&gt;获得当前时间刻度(微秒)。&lt;/T&gt;\n//\n// @return 时间刻度\n//============================================================\n\nTTimeTick RTimeTick::Current(){\n#ifdef _WINDOWS\n   // TODO: 暂时毫秒级别\n   TTimeTick result = clock() * 1000;\n   return result;\n#else\n   timeval current;\n   gettimeofday(&amp;current, NULL);\n   TTimeTick result = current.tv_sec;\n   result *= 1000000;\n   result += current.tv_usec;\n   return result;\n#endif\n}</Source>
                  </Method>
                  <Method name="Format" type="static" description="格式化时间刻度。">
                     <Parameters>
                        <Parameter type="TTimeTick" name="tick"/>
                     </Parameters>
                     <Return type="TFsTimeTick" description="格式化字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;格式化时间刻度。&lt;/T&gt;\n//\n// @return 格式化字符串\n//============================================================\n\nTFsTimeTick RTimeTick::Format(TTimeTick tick){\n   TFsTimeTick result;\n   MO_LIB_SPRINTF(result.Memory(), TFsTimeTick::Size(), &quot;%llu.%06llus&quot;, tick/1000000, tick%1000000);\n   result.Fix();\n   return result;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RTrap">
               <Methods>
                  <Constructor name="RTrap" description="创建陷阱管理对象。"/>
                  <Destructor name="~RTrap" description="释放陷阱管理对象。"/>
                  <Method name="Static" type="static" description="陷阱管理对象实例声明。获得静态对象。">
                     <Return type="RTrap&amp;"/>
                     <Source>//============================================================\n// &lt;T&gt;陷阱管理对象实例声明。&lt;/T&gt;\n//============================================================\n\n//============================================================\n// &lt;T&gt;获得静态对象。&lt;/T&gt;\n//============================================================\n\nRTrap&amp; RTrap::Static(){\n   return _instance;\n}</Source>
                  </Method>
                  <Method name="CurrentThreadTrap" description="获得当前线程陷阱对象。">
                     <Return type="FThreadTrap*" description="线程陷阱对象"/>
                     <Source>//============================================================\n// &lt;T&gt;获得当前线程陷阱对象。&lt;/T&gt;\n//\n// @return 线程陷阱对象\n//============================================================\n\nFThreadTrap* RTrap::CurrentThreadTrap(){\n   return RThreadManager::Instance().Current()-&gt;ThreadTrap();\n}</Source>
                  </Method>
                  <Method name="CurrentTrap" description="获得当前线程激活的陷阱对象。">
                     <Return type="FTrap*" description="陷阱对象"/>
                     <Source>//============================================================\n// &lt;T&gt;获得当前线程激活的陷阱对象。&lt;/T&gt;\n//\n// @return 陷阱对象\n//============================================================\n\nFTrap* RTrap::CurrentTrap(){\n   return CurrentThreadTrap()-&gt;CurrentTrap();\n}</Source>
                  </Method>
                  <Method name="Link" description="关联线程陷阱。">
                     <Return type="FThreadTrap*"/>
                     <Source>//============================================================\n// &lt;T&gt;关联线程陷阱。&lt;/T&gt;\n//============================================================\n\nFThreadTrap* RTrap::Link(){\n   // 获得线程陷阱\n   FThreadTrap* pThreadTrap = CurrentThreadTrap();\n   MO_ASSERT(pThreadTrap);\n   // 增加一层\n   pThreadTrap-&gt;Push();\n   return pThreadTrap;\n}</Source>
                  </Method>
                  <Method name="Unlink" description="取消关联线程陷阱。">
                     <Parameters>
                        <Parameter type="FThreadTrap*" name="pThreadTrap" description="线程陷阱对象"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;取消关联线程陷阱。&lt;/T&gt;\n//\n// @param pThreadTrap 线程陷阱对象\n//============================================================\n\nvoid RTrap::Unlink(FThreadTrap* pThreadTrap){\n   // 回退一层陷阱\n   pThreadTrap-&gt;Pop();\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="RTrap" name="_instance"/>
               </Attributes>
            </Class>
            <Class name="RType">
               <Methods>
                  <Method name="Default" type="static">
                     <Return type="T&amp;"/>
                     <Source>\nstatic T&amp; Default() {\n      return _default;\n   }</Source>
                  </Method>
                  <Method name="Nvl" type="static">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                        <Parameter type="T" name="other"/>
                     </Parameters>
                     <Return type="T"/>
                     <Source>\nstatic T Nvl(T value, T other) {\n      return (_default == value) ? other : _default;\n   }</Source>
                  </Method>
                  <Method name="Clear" type="static">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void Clear(TAny* pMemory) {\n      memset(pMemory, 0, sizeof(T));\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T" name="_default"/>
               </Attributes>
            </Class>
            <Class name="RTypeMemory">
               <Methods>
                  <Method name="Alloc" type="static">
                     <Parameters>
                        <Parameter type="TUint" name="size"/>
                     </Parameters>
                     <Return type="T*"/>
                     <Source>\nstatic T* Alloc(TUint size){\n      TUint total = sizeof(T) * size;\n      T* pAlloc = (T*)malloc(total);\n      MO_ASSERT(NULL != pAlloc);\n      return pAlloc;\n   }</Source>
                  </Method>
                  <Method name="Alloc" type="static">
                     <Parameters>
                        <Parameter type="TUint" name="size"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="T*"/>
                     <Source>\nstatic T* Alloc(TUint size, T value){\n      TInt total = sizeof(T) * size;\n      T* pAlloc = (T*)malloc(total);\n      MO_ASSERT(NULL != pAlloc);\n      RTypes&lt;T&gt;::Fill(pAlloc, size, value);\n      return pAlloc;\n   }</Source>
                  </Method>
                  <Method name="Realloc" type="static">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TUint" name="size"/>
                     </Parameters>
                     <Return type="T*"/>
                     <Source>\nstatic T* Realloc(T* pMemory, TUint size){\n      MO_ASSERT(pMemory);\n      TInt total = sizeof (T) * size;\n      T* pAlloc = (T*)malloc(total);\n      MO_ASSERT(pAlloc);\n      memcpy(pAlloc, pMemory, total);\n      free(pMemory);\n      return pAlloc;\n   }</Source>
                  </Method>
                  <Method name="Free" type="static">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void Free(TAny* pMemory){\n      MO_ASSERT(pMemory);\n      free(pMemory);\n   }</Source>
                  </Method>
                  <Method name="ReleaseItems" type="static">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TUint" name="offset"/>
                        <Parameter type="TUint" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void ReleaseItems(T* pMemory, TUint offset, TUint count){\n      for(TUint n = 0; n &lt; count; n++){\n         T pItem = pMemory[offset + n];\n         if(NULL != pItem){\n            delete pItem;\n            pMemory[n] = NULL;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Release" type="static">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TUint" name="offset"/>
                        <Parameter type="TUint" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void Release(T* pMemory, TUint offset, TUint count){\n      ReleaseItems(pMemory, 0, count);\n      free(pMemory);\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RTypes">
               <Methods>
                  <Method name="Contains" type="static" description="判断一个值是否存在于指定数组中。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nstatic TBool Contains(const T* pValues, TInt length, T value){\n      MO_ASSERT(pValues);\n      while(--length &gt;= 0){\n         if(*pValues++ == value){\n            return ETrue;\n         }\n      }\n      return EFalse;\n   }</Source>
                  </Method>
                  <Method name="Equals" type="static" description="判断两个数组是否相等。">
                     <Parameters>
                        <Parameter type="T*" name="pSource"/>
                        <Parameter type="T*" name="pTarget"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nstatic TBool Equals(const T* pSource, const T* pTarget, TInt length){\n      MO_ASSERT(pSource);\n      MO_ASSERT(pTarget);\n      // 循环判断每一项是否相等\n      while(--length &gt;= 0){\n         if(*pSource++ != *pTarget++){\n            return EFalse;\n         }\n      }\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="Equals" type="static" description="判断两个数组是否相等。">
                     <Parameters>
                        <Parameter type="T*" name="pSource"/>
                        <Parameter type="TInt" name="sourceLength"/>
                        <Parameter type="T*" name="pTarget"/>
                        <Parameter type="TInt" name="targetLength"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nstatic TBool Equals(const T* pSource, TInt sourceLength, const T* pTarget, TInt targetLength){\n      MO_ASSERT(pSource);\n      MO_ASSERT(pTarget);\n      // 判断长度是否相等\n      if(sourceLength != targetLength){\n         return EFalse;\n      }\n      // 循环判断每一项是否相等\n      while(--sourceLength &gt;= 0){\n         if(*pSource++ != *pTarget++){\n            return EFalse;\n         }\n      }\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="StartsWith" type="static" description="查找指定数组是否出现在当前数组的开始位置。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="valueLength"/>
                        <Parameter type="T*" name="pFind"/>
                        <Parameter type="TInt" name="findLength"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nstatic TBool StartsWith(const T* pValues, TInt valueLength, const T* pFind, TInt findLength){\n      MO_ASSERT(pValues);\n      MO_ASSERT(pFind);\n      // 长度不足时直接返回结果\n      if(valueLength &lt; findLength){\n         return EFalse;\n      }\n      // 开始查找数据\n      return Equals(pValues, pFind, findLength);\n   }</Source>
                  </Method>
                  <Method name="EndsWith" type="static" description="查找指定数组是否出现在当前数组的结束位置。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="valueLength"/>
                        <Parameter type="T*" name="pFind"/>
                        <Parameter type="TInt" name="findLength"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nstatic TBool EndsWith(const T* pValues, TInt valueLength, const T* pFind, TInt findLength){\n      MO_ASSERT(pValues);\n      MO_ASSERT(pFind);\n      // 长度不足时直接返回结果\n      if(valueLength &lt; findLength){\n         return EFalse;\n      }\n      // 开始查找数据\n      return Equals(pValues + valueLength - findLength, pFind, findLength);\n   }</Source>
                  </Method>
                  <Method name="Compare" type="static" description="判断两个数组的大小。">
                     <Parameters>
                        <Parameter type="T*" name="pSource"/>
                        <Parameter type="TInt" name="sourceLength"/>
                        <Parameter type="T*" name="pTarget"/>
                        <Parameter type="TInt" name="targetLength"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nstatic TInt Compare(const T* pSource, TInt sourceLength, const T* pTarget, TInt targetLength){\n      MO_ASSERT(pSource);\n      MO_ASSERT(pTarget);\n      // 循环判断每一项的大小\n      TInt n = -1;\n      TInt loop = MO_MIN(sourceLength, targetLength);\n      while(++n &lt; loop){\n         if(pSource[n] != pTarget[n]){\n            return pSource[n] - pTarget[n];\n         }\n      }\n      // 全部数据一样的时候，就以长度判断数组大小\n      return sourceLength - targetLength;\n   }</Source>
                  </Method>
                  <Method name="IndexOf" type="static" description="判断一个值存在于指定数组中首次出现的索引位置。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nstatic TInt IndexOf(const T* pValues, T value){\n      MO_ASSERT(pValues);\n      const T* pSearch = pValues;\n      while(ETrue){\n         if(*pSearch == value){\n            return pSearch - pValues;\n         }\n         pSearch++;\n      }\n      return ENotFound;\n   }</Source>
                  </Method>
                  <Method name="IndexOf" type="static" description="判断一个值存在于指定数组中首次出现的索引位置。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nstatic TInt IndexOf(const T* pValues, TInt length, T value){\n      MO_ASSERT(pValues);\n      const T* pSearch = pValues;\n      while(--length &gt;= 0){\n         if(*pSearch == value){\n            return pSearch - pValues;\n         }\n         pSearch++;\n      }\n      return ENotFound;\n   }</Source>
                  </Method>
                  <Method name="LastIndexOf" type="static" description="判断一个值存在于指定数组中最后出现的索引位置。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nstatic TInt LastIndexOf(const T* pValues, TInt length, T value){\n      MO_ASSERT(pValues);\n      const T* pSearch = pValues + length;\n      while(--length &gt;= 0){\n         pSearch--;\n         if(*pSearch == value){\n            return pSearch - pValues;\n         }\n      }\n      return ENotFound;\n   }</Source>
                  </Method>
                  <Method name="Find" type="static" description="在一个数组中查找另一个数组中首次出现的索引位置。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="valueLength"/>
                        <Parameter type="T*" name="pFind"/>
                        <Parameter type="TInt" name="findLength"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nstatic TInt Find(const T* pValues, TInt valueLength, const T* pFind, TInt findLength){\n      MO_ASSERT(pValues);\n      MO_ASSERT(pFind);\n      // 取出要查找的第一个数据\n      const T&amp; first = pFind[0];\n      // 循环查找每一个数据\n      TInt position = -1;\n      TInt length = valueLength - findLength;\n      while(++position &lt;= length){\n         // 如果查到第一个则继续查找后面的数据\n         if(pValues[position] == first){\n            TInt n = 0;\n            while(++n &lt; findLength){\n               if(pValues[position + n] != pFind[n]){\n                  break;\n               }\n            }\n            // 如果符合查找长度则返回索引位置\n            if(n == findLength){\n               return position;\n            }\n         }\n      }\n      // 没有查到数据\n      return ENotFound;\n   }</Source>
                  </Method>
                  <Method name="LastFind" type="static" description="在一个数组中查找另一个数组中首次出现的索引位置。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="valueLength"/>
                        <Parameter type="T*" name="pFind"/>
                        <Parameter type="TInt" name="findLength"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>\nstatic TInt LastFind(const T* pValues, TInt valueLength, const T* pFind, TInt findLength){\n      MO_ASSERT(pValues);\n      MO_ASSERT(pFind);\n      // 取出要查找的第一个数据\n      const T&amp; first = pFind[0];\n      // 循环查找每一个数据\n      TInt position = -1;\n      TInt length = valueLength - findLength;\n      while(++position &lt;= length){\n         // 如果查到第一个则继续查找后面的数据\n         if(pValues[length - position] == first){\n            TInt n = 0;\n            while (++n &lt; findLength){\n               if (pValues[position + n] != pFind[n]){\n                  break;\n               }\n            }\n            // 如果符合查找长度则返回索引位置\n            if(n == findLength){\n               return position;\n            }\n         }\n      }\n      // 没有查到数据\n      return ENotFound;\n   }</Source>
                  </Method>
                  <Method name="Fill" type="static" description="填充一个数组的内容为填充内容。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void Fill(T* pValues, TInt length, T value){\n      MO_ASSERT(pValues);\n      while(--length &gt;= 0){\n         *pValues++ = value;\n      }\n   }</Source>
                  </Method>
                  <Method name="Copy" type="static" description="复制原数组到目标数组。">
                     <Parameters>
                        <Parameter type="T*" name="pTarget"/>
                        <Parameter type="T*" name="pSource"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void Copy(T* pTarget, const T* pSource, TInt length){\n      MO_ASSERT(pSource);\n      MO_ASSERT(pTarget);\n      memcpy(pTarget, pSource, sizeof(T) * length);\n   }</Source>
                  </Method>
                  <Method name="Move" type="static" description="移动原数组到目标数组。" note="底层代码实现，速度较慢，但不会产生复制错误。">
                     <Parameters>
                        <Parameter type="T*" name="pTarget"/>
                        <Parameter type="T*" name="pSource"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void Move(T* pTarget, const T* pSource, TInt length){\n      MO_ASSERT(pSource);\n      MO_ASSERT(pTarget);\n      memmove(pTarget, pSource, sizeof(T) * length);\n   }</Source>
                  </Method>
                  <Method name="Replace" type="static" description="替换数组中指定内容为另一个内容。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                        <Parameter type="T" name="source"/>
                        <Parameter type="T" name="target"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void Replace(T* pValues, TInt length, T source, T target){\n      MO_ASSERT(pValues);\n      while(--length &gt;= 0){\n         if(pValues[length] == source){\n            pValues[length] = target;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="MakeHashCode" type="static" description="计算根据数组内每一项值的综合哈希值。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="THashCode"/>
                     <Source>\nstatic THashCode MakeHashCode(const T* pValues, TInt length){\n      MO_ASSERT(pValues);\n      THashCode hash = 0;\n      while(--length &gt;= 0){\n         hash += (hash &lt;&lt; 4) + (hash &lt;&lt; 3) + (hash &lt;&lt; 2) + (hash &lt;&lt; 1) + pValues[length];\n      }\n      return hash;\n   }</Source>
                  </Method>
                  <Method name="Clear" type="static" description="设置一个数组的所有数据内容为零。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nstatic void Clear(T* pValues, TInt length){\n      MO_ASSERT(pValues);\n      memset(pValues, 0, sizeof(T) * length);\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RUbyte">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
            </Class>
            <Class name="RUint">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="ParseHex" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint"/>
                  </Method>
                  <Method name="ParseHexNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint"/>
                  </Method>
                  <Method name="Parse" type="static" description="将字符串变换为无符号整数,字符串空时产生例外。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TUint" description="无符号整数"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为无符号整数,字符串空时产生例外。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 无符号整数\n//============================================================\n\nTUint RUint::Parse(TCharC* pValue){\n   MO_ASSERT(pValue);\n   return atoi(pValue);\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static" description="将字符串变换为无符号整数。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue" description="字符串"/>
                     </Parameters>
                     <Return type="TUint" description="无符号整数"/>
                     <Source>//============================================================\n// &lt;T&gt;将字符串变换为无符号整数。&lt;/T&gt;\n//\n// @param pValue 字符串\n// @return 无符号整数\n//============================================================\n\nTUint RUint::ParseNvl(TCharC* pValue){\n	return (NULL == pValue) ? 0 : atoi(pValue);\n}</Source>
                  </Method>
                  <Method name="ToString" type="static" description="将无符号整数变换为字符串。">
                     <Parameters>
                        <Parameter type="TUint" name="value" description="无符号整数"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*" description="字符串"/>
                     <Source>//============================================================\n// &lt;T&gt;将无符号整数变换为字符串。&lt;/T&gt;\n//\n// @param value 无符号整数\n// @return 字符串\n//============================================================\n\nTCharC* RUint::ToString(TUint value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	TInt n = -1;\n	TChar* pResult = pBuffer;\n	do{\n		// 循环转换每一个数字，直到结束\n		pResult[++n] = value % 10 + '0';\n		value /= 10;\n	}while(value &gt; 0);\n	// 转换结束后字符串是翻的，计算出一半的长度\n	TInt position = (n + 1) / 2;\n	while(position-- &gt; 0){\n		// 将字符串的字符序翻转\n		TChar temp = pResult[position];\n		pResult[position] = pResult[n - position];\n		pResult[n - position] = temp;\n	}\n	// 置结束符\n	pResult[n + 1] = '\0';\n	return pBuffer;\n}</Source>
                  </Method>
                  <Method name="ToHexString" type="static">
                     <Parameters>
                        <Parameter type="TUint" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>\nTCharC* RUint::ToHexString(TUint value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	TInt n = -1;\n	TChar* pResult = pBuffer;\n	do{\n		// 循环转换每一个数字，直到结束\n		pResult[++n] = RByte::HEX_CHARS[value % 16];\n		value /= 16;\n	}while(value &gt; 0);\n	// 转换结束后字符串是翻的，计算出一半的长度\n	TInt position = (n + 1) / 2;\n	while(position-- &gt; 0){\n		// 将字符串的字符序翻转\n		TChar temp = pResult[position];\n		pResult[position] = pResult[n - position];\n		pResult[n - position] = temp;\n	}\n	// 置结束符\n	pResult[n + 1] = '\0';\n	return pBuffer;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RUint16">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint16"/>
                     <Source>//============================================================\n\nTUint16 RUint16::Parse(TCharC* pValue){\n	MO_ASSERT(pValue);\n	TInt value = atoi(pValue);\n	// 防止未知溢出\n	MO_ASSERT(value &lt;= 0xFFFF);\n	return (TUint16)value;\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint16"/>
                     <Source>//============================================================\n\nTUint16 RUint16::ParseNvl(TCharC* pValue){\n	TInt value = atoi(pValue);\n	// 防止未知溢出\n	MO_ASSERT(value &lt;= 0xFFFF);\n	return (TUint16)value;\n}</Source>
                  </Method>
                  <Method name="ParseHex" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint16"/>
                     <Source>//============================================================\n\nTUint16 RUint16::ParseHex(TCharC* pValue){\n	MO_ASSERT(pValue);\n	TInt value = strtol(pValue, NULL, 16);\n	MO_ASSERT(value &lt;= 0xFFFF);\n	return (TUint16)value;\n}</Source>
                  </Method>
                  <Method name="ParseHexNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint16"/>
                     <Source>//============================================================\n\nTUint16 RUint16::ParseHexNvl(TCharC* pValue){\n	TInt value = strtol(pValue, NULL, 16);\n	MO_ASSERT(value &lt;= 0xFFFF);\n	return (TUint16)value;\n}</Source>
                  </Method>
                  <Method name="ToString" type="static">
                     <Parameters>
                        <Parameter type="TUint16" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RUint16::ToString(TUint16 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	return RUint::ToString((TUint)value, pBuffer, length);\n}</Source>
                  </Method>
                  <Method name="ToHexString" type="static">
                     <Parameters>
                        <Parameter type="TUint16" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RUint16::ToHexString(TUint16 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	return RUint::ToHexString((TUint)value, pBuffer, length);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RUint32">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint32"/>
                     <Source>//============================================================\n\nTUint32 RUint32::Parse(TCharC* pValue){\n	MO_ASSERT(pValue);\n	TInt value = atoi(pValue);\n	return (TUint32)value;\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint32"/>
                     <Source>//============================================================\n\nTUint32 RUint32::ParseNvl(TCharC* pValue){\n	TInt value = atoi(pValue);\n	return (TUint32)value;\n}</Source>
                  </Method>
                  <Method name="ParseHex" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint32"/>
                     <Source>//============================================================\n\nTUint32 RUint32::ParseHex(TCharC* pValue){\n	MO_ASSERT(pValue);\n	TInt value = strtol(pValue, NULL, 16);\n	return (TUint32)value;\n}</Source>
                  </Method>
                  <Method name="ParseHexNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint32"/>
                     <Source>//============================================================\n\nTUint32 RUint32::ParseHexNvl(TCharC* pValue){\n	TInt value = strtol(pValue, NULL, 16);\n	return (TUint32)value;\n}</Source>
                  </Method>
                  <Method name="ToString" type="static">
                     <Parameters>
                        <Parameter type="TUint32" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RUint32::ToString(TUint32 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	return RUint::ToString((TUint)value, pBuffer, length);\n}</Source>
                  </Method>
                  <Method name="ToHexString" type="static">
                     <Parameters>
                        <Parameter type="TUint32" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RUint32::ToHexString(TUint32 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	return RUint::ToHexString((TUint)value, pBuffer, length);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RUint64">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint64"/>
                     <Source>//============================================================\n\nTUint64 RUint64::Parse(TCharC* pValue){\n	MO_ASSERT(pValue);\n#ifdef _WINDOWS\n	return (TUint64)_atoi64(pValue);\n#else\n	return (TUint64)atoll(pValue);\n#endif\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint64"/>
                     <Source>//============================================================\n\nTUint64 RUint64::ParseNvl(TCharC* pValue){\n	MO_ASSERT(pValue);\n#ifdef _WINDOWS\n	return (TUint64)_atoi64(pValue);\n#else\n	return (TUint64)atoll(pValue);\n#endif\n}</Source>
                  </Method>
                  <Method name="ParseHex" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint64"/>
                     <Source>//============================================================\n\nTUint64 RUint64::ParseHex(TCharC* pValue){\n	MO_ASSERT(pValue);\n#ifdef _WINDOWS\n	TUint length = strlen(pValue);\n	TUint64 temp = 0;\n	for(TUint i = 0; i &lt; length; i++){\n		for(TUint j = 0; j &lt; 16; j++){\n			if(pValue[i] == RByte::HEX_CHARS[j]){\n				temp += j;\n			}\n		}\n		temp = temp&lt;&lt;4;\n	}\n	return temp;\n#else\n	return strtoull(pValue, 0, 16);\n#endif\n\n}</Source>
                  </Method>
                  <Method name="ParseHexNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint64"/>
                     <Source>//============================================================\n\nTUint64 RUint64::ParseHexNvl(TCharC* pValue){\n#ifdef _WINDOWS\n	TInt length = strlen(pValue);\n	TUint64 temp = 0;\n	for(TInt i = 0; i &lt; length; i++){\n		for(TUint j = 0; j &lt; 16; j++){\n			if(pValue[i] == RByte::HEX_CHARS[j]){\n				temp += j;\n			}\n		}\n		temp = temp&lt;&lt;4;\n	}\n	return temp;\n#else\n	return strtoull(pValue, 0, 16);\n#endif\n}</Source>
                  </Method>
                  <Method name="ToString" type="static">
                     <Parameters>
                        <Parameter type="TUint64" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RUint64::ToString(TUint64 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	TUint32 high = (TUint32)(value &gt;&gt; 32);\n	TUint32 low = (TUint32)(value &amp; (TUint64)0x00000000FFFFFFFF);\n	RUint::ToString((TUint)high, pBuffer, length);\n	TInt offset = strlen(pBuffer);\n	RUint::ToString((TUint)low,  pBuffer + offset, length);\n	return pBuffer;\n}</Source>
                  </Method>
                  <Method name="ToHexString" type="static">
                     <Parameters>
                        <Parameter type="TUint64" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RUint64::ToHexString(TUint64 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	TUint32 high = (TUint32)(value &gt;&gt; 32);\n	TUint32 low = (TUint32)(value &amp; (TUint64)0x00000000FFFFFFFF);\n	RUint::ToHexString((TUint)high, pBuffer, length);\n	TInt offset = strlen(pBuffer);\n	RUint::ToHexString((TUint)low,  pBuffer + offset, length);\n	return pBuffer;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RUint8">
               <Inherits>
                  <Inherit name="RType" scope="public"/>
               </Inherits>
               <Methods>
                  <Method name="Parse" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint8"/>
                     <Source>//============================================================\n\nTUint8 RUint8::Parse(TCharC* pValue){\n	MO_ASSERT(pValue);\n	TInt value = atoi(pValue);\n	MO_ASSERT(value &lt;= 256);\n	return (TUint8)value;\n}</Source>
                  </Method>
                  <Method name="ParseNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint8"/>
                     <Source>//============================================================\n\nTUint8 RUint8::ParseNvl(TCharC* pValue){\n	if(pValue){\n		TInt value = atoi(pValue);\n		MO_ASSERT(value &lt;= 256);\n		return (TUint8)value;\n	}\n	return (TUint8)0;\n}</Source>
                  </Method>
                  <Method name="ParseHex" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint8"/>
                     <Source>//============================================================\n\nTUint8 RUint8::ParseHex(TCharC* pValue){\n	MO_ASSERT(pValue);\n	TInt value = strtol(pValue, NULL, 16);\n	MO_ASSERT(value &lt;= 0xFF);\n	return (TUint8)value;\n}</Source>
                  </Method>
                  <Method name="ParseHexNvl" type="static">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TUint8"/>
                     <Source>//============================================================\n\nTUint8 RUint8::ParseHexNvl(TCharC* pValue){\n	TInt value = strtol(pValue, NULL, 16);\n	MO_ASSERT(value &lt;= 0xFF);\n	return (TUint8)value;\n}</Source>
                  </Method>
                  <Method name="ToString" type="static">
                     <Parameters>
                        <Parameter type="TUint8" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RUint8::ToString(TUint8 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	return RUint::ToString((TUint)value, pBuffer, length);\n}</Source>
                  </Method>
                  <Method name="ToHexString" type="static">
                     <Parameters>
                        <Parameter type="TUint8" name="value"/>
                        <Parameter type="TChar*" name="pBuffer"/>
                        <Parameter type="TSize" name="length"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* RUint8::ToHexString(TUint8 value, TChar* pBuffer, TSize length){\n	MO_ASSERT(pBuffer);\n	return RUint::ToHexString((TUint)value, pBuffer, length);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RVirtualMemory">
               <Methods>
                  <Method name="Alloc" type="static" description="收集指定大小的内存。">
                     <Parameters>
                        <Parameter type="TUint" name="size" description="指定大小"/>
                     </Parameters>
                     <Return type="TAny*" description="收集好的内存"/>
                     <Source>//============================================================\n// &lt;T&gt;收集指定大小的内存。&lt;/T&gt;\n//\n// @param size 指定大小\n// @return 收集好的内存\n//============================================================\n\nTAny* RVirtualMemory::Alloc(TUint size){\n   TAny* pAlloc = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n   MO_ASSERT(NULL != pAlloc);\n   return pAlloc;\n}</Source>
                  </Method>
                  <Method name="Lock" type="static" description="锁定指定的内存。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory" description="指定内存"/>
                        <Parameter type="TUint" name="size" description="内存大小"/>
                     </Parameters>
                     <Return type="TBool" description="是否成功"/>
                     <Source>//============================================================\n// &lt;T&gt;锁定指定的内存。&lt;/T&gt;\n//\n// @param pMemory 指定内存\n// @param size 内存大小\n// @return 是否成功\n//============================================================\n\nTBool RVirtualMemory::Lock(TAny* pMemory, TUint size){\n   return VirtualLock(pMemory, size);\n}</Source>
                  </Method>
                  <Method name="Unlock" type="static" description="解锁指定的内存。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory" description="指定内存"/>
                        <Parameter type="TUint" name="size" description="内存大小"/>
                     </Parameters>
                     <Return type="TBool" description="是否成功"/>
                     <Source>//============================================================\n// &lt;T&gt;解锁指定的内存。&lt;/T&gt;\n//\n// @param pMemory 指定内存\n// @param size 内存大小\n// @return 是否成功\n//============================================================\n\nTBool RVirtualMemory::Unlock(TAny* pMemory, TUint size){\n   return VirtualUnlock(pMemory, size);\n}</Source>
                  </Method>
                  <Method name="Write" type="static" description="向指定内存写入信息。">
                     <Parameters>
                        <Parameter type="TAny*" name="pLocation" description="基址指针"/>
                        <Parameter type="TAny*" name="pBuffer" description="缓冲指针"/>
                        <Parameter type="TUint" name="size" description="内存大小"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;向指定内存写入信息。&lt;/T&gt;\n//\n// @param pLocation 基址指针\n// @param pBuffer 缓冲指针\n// @param size 内存大小\n//============================================================\n\nvoid RVirtualMemory::Write(TAny* pLocation, TAny* pBuffer, TUint size){\n   HANDLE hProcess = GetCurrentProcess();\n   // 将内存范围从(pLocation)到(pLocation+size)的页面的保护方式改成可读写方式\n   TUint32 storeProtection;\n   VirtualProtectEx(hProcess, pLocation, size, PAGE_READWRITE, &amp;storeProtection);\n   // 写入内存\n   WriteProcessMemory(hProcess, pLocation, pBuffer, size, NULL);\n   // 恢复原来的保护方式\n   TUint32 tempProtection;\n   VirtualProtectEx(hProcess, pLocation, size, storeProtection, &amp;tempProtection);\n}</Source>
                  </Method>
                  <Method name="Read" type="static" description="从指定内存读取信息。">
                     <Parameters>
                        <Parameter type="TAny*" name="pLocation" description="基址指针"/>
                        <Parameter type="TAny*" name="pBuffer" description="缓冲指针"/>
                        <Parameter type="TUint" name="size" description="内存大小"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;从指定内存读取信息。&lt;/T&gt;\n//\n// @param pLocation 基址指针\n// @param pBuffer 缓冲指针\n// @param size 内存大小\n//============================================================\n\nvoid RVirtualMemory::Read(TAny* pLocation, TAny* pBuffer, TUint size){\n   TUint32 readSize = 0;\n   HANDLE hProcess = GetCurrentProcess();\n   MO_CHECK(ReadProcessMemory(hProcess, pLocation, pBuffer, size, &amp;readSize));\n   MO_ASSERT(readSize == size);\n}</Source>
                  </Method>
                  <Method name="Free" type="static" description="释放内存。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory" description="内存"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放内存。&lt;/T&gt;\n//\n// @param pMemory 内存\n//============================================================\n\nvoid RVirtualMemory::Free(TAny* pMemory){\n   MO_ASSERT(NULL != pMemory);\n   VirtualFree(pMemory, 0, MEM_RELEASE);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="RXml">
               <Methods>
                  <Method name="MakeNodeAttribute" type="static" description="创建配置文件实例。">
                     <Parameters>
                        <Parameter type="TString&amp;" name="target"/>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;创建配置文件实例。&lt;/T&gt;\n//============================================================\n\nTBool RXml::MakeNodeAttribute(TString&amp; target, TCharC* pValue){\n   if(NULL == pValue){\n      return EFalse;\n   }\n   TSize length = strlen(pValue);\n   if(0 == length){\n      return EFalse;\n   }\n   for(TSize n=0; n&lt;length; n++){\n      TChar value = pValue[n];\n      if('&amp;' == value){\n         target.Append(&quot;&amp;amp;&quot;);\n      }else if('&quot;' == value){\n         target.Append(&quot;&amp;quot;&quot;);\n      }else if('&lt;' == value){\n         target.Append(&quot;&amp;lt;&quot;);\n      }else if('&gt;' == value){\n         target.Append(&quot;&amp;gt;&quot;);\n      }else if('\r' == value){\n         continue;\n      }else if('\n' == value){\n         target.Append(&quot;\\n&quot;);\n      }else{\n         target.Append(value);\n      }\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="MakeNodeText" type="static" description="创建配置文件实例。">
                     <Parameters>
                        <Parameter type="TString&amp;" name="target"/>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// &lt;T&gt;创建配置文件实例。&lt;/T&gt;\n//============================================================\n\nTBool RXml::MakeNodeText(TString&amp; target, TCharC* pValue){\n   if(NULL == pValue){\n      return EFalse;\n   }\n   TSize length = strlen(pValue);\n   if(0 == length){\n      return EFalse;\n   }\n   for(TSize n=0; n&lt;length; n++){\n      TChar value = pValue[n];\n      if('&amp;' == value){\n         target.Append(&quot;&amp;amp;&quot;);\n      }else if('&quot;' == value){\n         target.Append(&quot;&amp;quot;&quot;);\n      }else if('&lt;' == value){\n         target.Append(&quot;&amp;lt;&quot;);\n      }else if('&gt;' == value){\n         target.Append(&quot;&amp;gt;&quot;);\n      }else if('\r' == value){\n         continue;\n      }else if('\n' == value){\n         target.Append(&quot;\\n&quot;);\n      }else{\n         target.Append(value);\n      }\n   }\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="SAreaTpl"/>
            <Class name="SAtomEntry">
               <Attributes>
                  <Attribute type="SAtomEntry*" name="pPrior"/>
                  <Attribute type="SAtomEntry*" name="pNext"/>
                  <Attribute type="T" name="value"/>
               </Attributes>
            </Class>
            <Class name="SAttributesEntry">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="SAttributesEntry"/>
                  <Destructor name="~SAttributesEntry"/>
                  <Method name="IsName" type="inline" description="判断名称是否相等。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsName(TCharC* pName) const{\n      MO_ASSERT(pName);\n      MO_ASSERT(this-&gt;pName);\n      return this-&gt;pName-&gt;Equals(pName);\n   }</Source>
                  </Method>
                  <Method name="IsNameIgnoreCase" type="inline" description="判断不区分大小写名称是否相等。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsNameIgnoreCase(TCharC* pName) const{\n      MO_ASSERT(pName);\n      MO_ASSERT(this-&gt;pName);\n      return this-&gt;pName-&gt;EqualsIgnoreCase(pName);\n   }</Source>
                  </Method>
                  <Method name="Name" type="inline" description="获得当前位置的数据名称。">
                     <Return type="TCharC*"/>
                     <Source>\ninline TCharC* Name() const{\n      MO_ASSERT(pName);\n      return pName-&gt;MemoryC();\n   }</Source>
                  </Method>
                  <Method name="Value" type="inline" description="获得当前位置的数据内容。">
                     <Return type="TCharC*"/>
                     <Source>\ninline TCharC* Value() const{\n      MO_ASSERT(pValue);\n      return pValue-&gt;MemoryC();\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SAttributesEntry*" name="pLink"/>
                  <Attribute type="SAttributesEntry*" name="pPrior"/>
                  <Attribute type="SAttributesEntry*" name="pNext"/>
                  <Attribute type="THashCode" name="hash"/>
                  <Attribute type="FString*" name="pName"/>
                  <Attribute type="FString*" name="pValue"/>
               </Attributes>
            </Class>
            <Class name="SDictionaryEntry">
               <Methods>
                  <Constructor name="SDictionaryEntry"/>
                  <Destructor name="~SDictionaryEntry"/>
                  <Method name="IsName">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool IsName(TCharC* pName){\n      return this-&gt;pName-&gt;Equals(pName);\n   }</Source>
                  </Method>
                  <Method name="IsNameIgnoreCase">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool IsNameIgnoreCase(TCharC* pName){\n      return this-&gt;pName-&gt;EqualsIgnoreCase(pName);\n   }</Source>
                  </Method>
                  <Method name="Hash">
                     <Return type="THashCode"/>
                     <Source>\nTHashCode Hash(){\n      return this-&gt;hash;\n   }</Source>
                  </Method>
                  <Method name="Name">
                     <Return type="TCharC*"/>
                     <Source>\nTCharC* Name(){\n      return this-&gt;pName-&gt;MemoryC();\n   }</Source>
                  </Method>
                  <Method name="SetName">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid SetName(TCharC* pName){\n      this-&gt;pName-&gt;Assign(pName);\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SDictionaryEntry*" name="pLink"/>
                  <Attribute type="SDictionaryEntry*" name="pPrior"/>
                  <Attribute type="SDictionaryEntry*" name="pNext"/>
                  <Attribute type="THashCode" name="hash"/>
                  <Attribute type="FString*" name="pName"/>
                  <Attribute type="T" name="value"/>
               </Attributes>
            </Class>
            <Class name="SHandle">
               <Attributes>
                  <Attribute type="TUint" name="Type"/>
                  <Attribute type="TUint" name="Index"/>
                  <Attribute type="TUint" name="Flag"/>
               </Attributes>
            </Class>
            <Class name="SHead">
               <Attributes>
                  <Attribute type="TInt32" name="listCount"/>
                  <Attribute type="TInt32" name="listUnused"/>
                  <Attribute type="TInt32" name="entryCount"/>
                  <Attribute type="TInt32" name="entryUnused"/>
               </Attributes>
            </Class>
            <Class name="SListEntry">
               <Attributes>
                  <Attribute type="SListEntry*" name="pPrior"/>
                  <Attribute type="SListEntry*" name="pNext"/>
                  <Attribute type="T" name="value"/>
               </Attributes>
            </Class>
            <Class name="SMapEntry">
               <Attributes>
                  <Attribute type="SMapEntry*" name="pLink"/>
                  <Attribute type="SMapEntry*" name="pPrior"/>
                  <Attribute type="SMapEntry*" name="pNext"/>
                  <Attribute type="THashCode" name="hash"/>
                  <Attribute type="N" name="name"/>
                  <Attribute type="V" name="value"/>
               </Attributes>
            </Class>
            <Class name="SMatrix2x2Tpl">
               <Methods>
                  <Constructor name="SMatrix2x2Tpl"/>
                  <Method name="operator*">
                     <Parameters>
                        <Parameter type="SMatrix2x2Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="SMatrix2x2Tpl"/>
                     <Source>\nSMatrix2x2Tpl operator*(SMatrix2x2Tpl&amp; v){\n      return Multiply(v);\n   }</Source>
                  </Method>
                  <Method name="Reset">
                     <Return type="void"/>
                     <Source>\nvoid Reset(){\n      for(TInt j=0; j&lt;2; j++){\n         for(TInt i=0; i&lt;2; i++){\n            m[j][i] = 0;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Cross" description="点乘(内积)。">
                     <Parameters>
                        <Parameter type="SMatrix2x2Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Cross(SMatrix2x2Tpl&amp; v){\n   }</Source>
                  </Method>
                  <Method name="Multiply" description="叉乘(外积)。">
                     <Parameters>
                        <Parameter type="SPoint2Tpl&lt;T&gt;&amp;" name="v"/>
                     </Parameters>
                     <Return type="SPoint2Tpl&lt;T&gt;"/>
                     <Source>\nSPoint2Tpl&lt;T&gt; Multiply(SPoint2Tpl&lt;T&gt;&amp; v){\n      SPoint2Tpl&lt;T&gt; r;\n      r.x = (v.x * m[0][0]) + (v.y * m[0][1]);\n      r.y = (v.x * m[1][0]) + (v.y * m[1][1]);\n      return r;\n   }</Source>
                  </Method>
                  <Method name="Multiply" description="叉乘(外积)。">
                     <Parameters>
                        <Parameter type="SMatrix2x2Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="SMatrix2x2Tpl"/>
                     <Source>\nSMatrix2x2Tpl Multiply(SMatrix2x2Tpl&amp; v){\n      SMatrix2x2Tpl r;\n      for(TInt j=0; j&lt;2; j++){\n         for(TInt i=0; i&lt;2; i++){\n            for(TInt k=0; k&lt;2; k++){\n               r.m[j][i] += m[j][k] * v.m[k][i];\n            }\n         }\n      }\n      return r;\n   }</Source>
                  </Method>
                  <Method name="ToValue">
                     <Return type="T"/>
                     <Source>\nT ToValue(){\n      T v = (m[0][0] * m[1][1]) - (m[0][1] * m[1][0]);\n      return v;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="SMatrix3x3Tpl">
               <Methods>
                  <Constructor name="SMatrix3x3Tpl"/>
                  <Method name="operator*">
                     <Parameters>
                        <Parameter type="SMatrix3x3Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="SMatrix3x3Tpl"/>
                     <Source>\nSMatrix3x3Tpl operator*(SMatrix3x3Tpl&amp; v){\n      return Multiply(v);\n   }</Source>
                  </Method>
                  <Method name="Reset">
                     <Return type="void"/>
                     <Source>\nvoid Reset(){\n      for(TInt j=0; j&lt;3; j++){\n         for(TInt i=0; i&lt;3; i++){\n            m[j][i] = 0;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Absolute" description="获得矩阵的模。">
                     <Return type="T"/>
                     <Source>\nT Absolute(){\n      T v = 0;\n      for(TInt j=0; j&lt;3; j++){\n         for(TInt i=0; i&lt;3; i++){\n            v += m[j][i] * m[j][i];\n         }\n      }\n      return sqrt(v);\n   }</Source>
                  </Method>
                  <Method name="Cross" description="点乘(内积)。">
                     <Parameters>
                        <Parameter type="SMatrix3x3Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Cross(SMatrix3x3Tpl&amp; v){\n   }</Source>
                  </Method>
                  <Method name="Multiply" description="叉乘(外积)。">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&lt;T&gt;&amp;" name="v"/>
                     </Parameters>
                     <Return type="SPoint3Tpl&lt;T&gt;"/>
                     <Source>\nSPoint3Tpl&lt;T&gt; Multiply(SPoint3Tpl&lt;T&gt;&amp; v){\n      SPoint3Tpl&lt;T&gt; r;\n      r.x = v.x*m[0][0] + v.y*m[0][1] + v.z*m[0][2];\n      r.y = v.x*m[1][0] + v.y*m[1][1] + v.z*m[1][2];\n      r.z = v.x*m[2][0] + v.y*m[2][1] + v.z*m[2][2];\n      return r;\n   }</Source>
                  </Method>
                  <Method name="Multiply" description="叉乘(外积)。">
                     <Parameters>
                        <Parameter type="SMatrix3x3Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="SMatrix3x3Tpl"/>
                     <Source>\nSMatrix3x3Tpl Multiply(SMatrix3x3Tpl&amp; v){\n      SMatrix3x3Tpl r;\n      for(TInt j=0; j&lt;3; j++){\n         for(TInt i=0; i&lt;3; i++){\n            for(TInt k=0; k&lt;3; k++){\n               r.m[j][i] += m[j][k] * v.m[k][i];\n            }\n         }\n      }\n      return r;\n   }</Source>
                  </Method>
                  <Method name="Normalize" description="单位化矩阵。">
                     <Return type="void"/>
                     <Source>\nvoid Normalize(){\n      T v = Absolute();\n      for(TInt j=0; j&lt;3; j++){\n         for(TInt i=0; i&lt;3; i++){\n            m[j][i] /= v;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="ToValue">
                     <Return type="T"/>
                     <Source>\nT ToValue(){\n      // 加数部分\n      T a1 = m[0][0] * m[1][1] * m[2][2];\n      T a2 = m[0][1] * m[1][2] * m[2][0];\n      T a3 = m[0][2] * m[1][0] * m[2][1];\n      // 减数部分\n      T b1 = m[0][0] * m[1][2] * m[2][1];\n      T b2 = m[0][1] * m[1][0] * m[2][2];\n      T b3 = m[0][2] * m[1][1] * m[2][0];\n      // 结果部分\n      T v = (a1 + a2 + a3) - (b1 + b2 + b3);\n      return v;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="SMatrix4x4Tpl">
               <Methods>
                  <Constructor name="SMatrix4x4Tpl"/>
                  <Method name="Reset">
                     <Parameters>
                        <Parameter type="T" name="value" default="0"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Reset(T value=0){\n      for(TInt j=0; j&lt;4; j++){\n         for(TInt i=0; i&lt;4; i++){\n            m[j][i] = value;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="SMatrix3x3Tpl&lt;T&gt;*" name="pMatrix"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(SMatrix3x3Tpl&lt;T&gt;* pMatrix){\n      for(TInt j=0; j&lt;4; j++){\n         for(TInt i=0; i&lt;4; i++){\n            if((3 == j) &amp;&amp; (3 == i)){\n               m[j][i] = 1;\n            }else if((3 == j) || (3 == i)){\n               m[j][i] = 0;\n            }else{\n               m[j][i] = pMatrix-&gt;m[j][i];\n            }\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Absolute" description="获得矩阵的模。">
                     <Return type="T"/>
                     <Source>\nT Absolute(){\n      T v = 0;\n      for(TInt j=0; j&lt;4; j++){\n         for(TInt i=0; i&lt;4; i++){\n            v += m[j][i] * m[j][i];\n         }\n      }\n      return sqrt(v);\n   }</Source>
                  </Method>
                  <Method name="Increase">
                     <Parameters>
                        <Parameter type="SMatrix4x4Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Increase(SMatrix4x4Tpl&amp; v){\n      for(TInt j=0; j&lt;4; j++){\n         for(TInt i=0; i&lt;4; i++){\n            m[j][i] += v.m[j][i];\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Subtract">
                     <Parameters>
                        <Parameter type="SMatrix4x4Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Subtract(SMatrix4x4Tpl&amp; v){\n      for(TInt j=0; j&lt;4; j++){\n         for(TInt i=0; i&lt;4; i++){\n            m[j][i] -= v.m[j][i];\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="Cross" description="点乘(内积)。">
                     <Parameters>
                        <Parameter type="SMatrix4x4Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Cross(SMatrix4x4Tpl&amp; v){\n   }</Source>
                  </Method>
                  <Method name="Multiply" description="叉乘(外积)。">
                     <Parameters>
                        <Parameter type="SPoint4Tpl&lt;T&gt;&amp;" name="v"/>
                     </Parameters>
                     <Return type="SPoint4Tpl&lt;T&gt;"/>
                     <Source>\nSPoint4Tpl&lt;T&gt; Multiply(SPoint4Tpl&lt;T&gt;&amp; v){\n      SPoint4Tpl&lt;T&gt; r;\n      r.x = (v.x * m[0][0]) + (v.y * m[0][1]) + (v.z * m[0][2]) + (v.w * m[0][3]);\n      r.y = (v.x * m[1][0]) + (v.y * m[1][1]) + (v.z * m[1][2]) + (v.w * m[1][3]);\n      r.z = (v.x * m[2][0]) + (v.y * m[2][1]) + (v.z * m[2][2]) + (v.w * m[2][3]);\n      r.w = (v.x * m[3][0]) + (v.y * m[3][1]) + (v.z * m[3][2]) + (v.w * m[3][3]);\n      return r;\n   }</Source>
                  </Method>
                  <Method name="Multiply" description="叉乘(外积)。">
                     <Parameters>
                        <Parameter type="SMatrix4x4Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="SMatrix4x4Tpl"/>
                     <Source>\nSMatrix4x4Tpl Multiply(SMatrix4x4Tpl&amp; v){\n      SMatrix4x4Tpl r;\n      for(TInt j=0; j&lt;4; j++){\n         for(TInt i=0; i&lt;4; i++){\n            for(TInt k=0; k&lt;4; k++){\n               r.m[j][i] += m[j][k] * v.m[k][i];\n            }\n         }\n      }\n      return r;\n   }</Source>
                  </Method>
                  <Method name="Normalize" description="单位化矩阵。">
                     <Return type="void"/>
                     <Source>\nvoid Normalize(){\n      T v = Absolute();\n      for(TInt j=0; j&lt;4; j++){\n         for(TInt i=0; i&lt;4; i++){\n            m[j][i] /= v;\n         }\n      }\n   }</Source>
                  </Method>
                  <Method name="ToValue">
                     <Return type="T"/>
                     <Source>\nT ToValue(){\n      // 加数部分\n      T a1 = m[0][0] * m[1][1] * m[2][2] * m[3][3];\n      T a2 = m[0][1] * m[1][2] * m[2][3] * m[3][0];\n      T a3 = m[0][2] * m[1][3] * m[2][0] * m[3][1];\n      T a4 = m[0][3] * m[1][0] * m[2][1] * m[3][2];\n      // 减数部分\n      T b1 = m[0][0] * m[1][3] * m[2][2] * m[3][1];\n      T b2 = m[0][1] * m[1][0] * m[2][3] * m[3][2];\n      T b3 = m[0][2] * m[1][1] * m[2][0] * m[3][3];\n      T b4 = m[0][3] * m[1][2] * m[2][1] * m[3][0];\n      // 结果部分\n      T v = (a1 + a2 + a3 + a4) - (b1 + b2 + b3 + b4);\n      return v;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="SMemoryEntry">
               <Inherits>
                  <Inherit name="MObject" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="SMemoryEntry" description="构造内存原子实例。">
                     <Parameters>
                        <Parameter type="IAllocator*" name="pAllocator" description="内存收集器"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~SMemoryEntry" description="析构内存原子实例。"/>
                  <Method name="SetTypeName" description="设置类名。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pTypeName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置类名。&lt;/T&gt;\n//\n// @param pClassName 类名\n//============================================================\n\nvoid SMemoryEntry::SetTypeName(TCharC* pTypeName){\n   this-&gt;pTypeName = pTypeName;\n}</Source>
                  </Method>
                  <Method name="SetFileInfo" description="设置文件信息。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pFileName" description="文件名称"/>
                        <Parameter type="TInt" name="fileLine"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置文件信息。&lt;/T&gt;\n//\n// @param pFileName 文件名称\n// @param line 文件行号\n//============================================================\n\nvoid SMemoryEntry::SetFileInfo(TChar8C* pFileName, TInt fileLine){\n   this-&gt;pFileName = pFileName;\n   this-&gt;fileLine = fileLine;\n}</Source>
                  </Method>
                  <Method name="Link" description="关联内存实例。">
                     <Parameters>
                        <Parameter type="TByte*" name="pData"/>
                        <Parameter type="TUint" name="size" description="内存大小"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;关联内存实例。&lt;/T&gt;\n//\n// @param size 内存大小\n// @param pMemory 已经收集的内存\n//============================================================\n\nvoid SMemoryEntry::Link(TByte* pData, TUint size){\n   // 初始化变量\n   size = size;\n   // 收集对齐内存\n   pAlloc = (TInt*)pData;\n   // 第一个位置存储当前对象指针\n   pAlloc[0] = (TInt)this;\n   // 第二个位置为要收集的内存\n   pMemory = pAlloc + 1;\n}</Source>
                  </Method>
                  <Method name="Alloc" description="收集内存。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;收集内存。&lt;/T&gt;\n//============================================================\n\nvoid SMemoryEntry::Alloc(){\n   ++allocCount;\n   //usedDateTime = RDateTime::Current();\n}</Source>
                  </Method>
                  <Method name="Free" description="释放内存。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;释放内存。&lt;/T&gt;\n//============================================================\n\nvoid SMemoryEntry::Free(){\n   ++freeCount;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="IAllocator*" name="pAllocator"/>
                  <Attribute type="SMemoryEntry*" name="pPrior"/>
                  <Attribute type="SMemoryEntry*" name="pNext"/>
                  <Attribute type="TInt*" name="pAlloc"/>
                  <Attribute type="TAny*" name="pMemory"/>
                  <Attribute type="TUint" name="size"/>
                  <Attribute type="TCharC*" name="pTypeName"/>
                  <Attribute type="TChar8C*" name="pFileName"/>
                  <Attribute type="TInt" name="fileLine"/>
                  <Attribute type="TUint" name="allocCount"/>
                  <Attribute type="TUint" name="freeCount"/>
                  <Attribute type="TDateTime" name="createDateTime"/>
                  <Attribute type="TDateTime" name="usedDateTime"/>
               </Attributes>
            </Class>
            <Class name="SNetSocketInfo">
               <Attributes>
                  <Attribute type="TUint16" name="type"/>
                  <Attribute type="TUint32" name="handle"/>
                  <Attribute type="TUint16" name="port"/>
                  <Attribute type="TUint64" name="sourceIp"/>
                  <Attribute type="TUint16" name="sourcePort"/>
                  <Attribute type="TUint64" name="targetIp"/>
                  <Attribute type="TUint16" name="targetPort"/>
                  <Attribute type="TUint32" name="receiveFlag"/>
                  <Attribute type="TUint64" name="receiveTotal"/>
                  <Attribute type="TUint32" name="sendFlag"/>
                  <Attribute type="TUint64" name="sendTotal"/>
                  <Attribute type="TDateTime" name="createTime"/>
                  <Attribute type="TDateTime" name="updateTime"/>
               </Attributes>
            </Class>
            <Class name="SPoint2Tpl">
               <Methods>
                  <Method name="=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator =(const TFloat value){\n		x = y = value;\n	}</Source>
                  </Method>
                  <Method name="=">
                     <Parameters>
                        <Parameter type="SPoint2Tpl&lt;T&gt;&amp;" name="point2"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator =(const SPoint2Tpl&lt;T&gt;&amp; point2){\n		x = point2.x;\n		y = point2.y;\n	}</Source>
                  </Method>
                  <Method name="+=">
                     <Parameters>
                        <Parameter type="SPoint2Tpl&lt;T&gt;&amp;" name="point2"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator +=(const SPoint2Tpl&lt;T&gt;&amp; point2){\n		x += point2.x;\n		y += point2.y;\n	}</Source>
                  </Method>
                  <Method name="-=">
                     <Parameters>
                        <Parameter type="SPoint2Tpl&lt;T&gt;&amp;" name="point2"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator -=(const SPoint2Tpl&lt;T&gt;&amp; point2){\n		x -= point2.x;\n		y -= point2.y;\n	}</Source>
                  </Method>
                  <Method name="*=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator *=(const TFloat value){\n		x *= value;\n		y *= value;\n	}</Source>
                  </Method>
                  <Method name="/=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator /=(const TFloat value){\n		MO_ASSERT(0.0f != value);\n		x /= value;\n		y /= value;\n	}</Source>
                  </Method>
                  <Method name="==">
                     <Parameters>
                        <Parameter type="SPoint2Tpl&lt;T&gt;&amp;" name="point2"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nTBool operator ==(const SPoint2Tpl&lt;T&gt;&amp; point2){\n		return ((x == point2.x) &amp;&amp; (y == point2.y));\n	}</Source>
                  </Method>
                  <Method name="!=">
                     <Parameters>
                        <Parameter type="SPoint2Tpl&lt;T&gt;&amp;" name="point2"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nTBool operator !=(const SPoint2Tpl&lt;T&gt;&amp; point2){\n		return ((x != point2.x)|| (y != point2.y));\n	}</Source>
                  </Method>
                  <Method name="Absolute">
                     <Return type="T"/>
                     <Source>\nT Absolute(){\n      return sqrt((x * x) + (y * y));\n   }</Source>
                  </Method>
                  <Method name="Normalize">
                     <Return type="void"/>
                     <Source>\nvoid Normalize(){\n      T v = Absolute();\n      x /= v;\n      y /= v;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T value){\n      this-&gt;x = value;\n      this-&gt;y = value;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="x"/>
                        <Parameter type="T" name="y"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T x, T y){\n      this-&gt;x = x;\n      this-&gt;y = y;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T" name="x"/>
                  <Attribute type="T" name="y"/>
               </Attributes>
            </Class>
            <Class name="SPoint3Tpl">
               <Methods>
                  <Constructor name="SPoint3Tpl"/>
                  <Constructor name="SPoint3Tpl">
                     <Parameters>
                        <Parameter type="T" name="x"/>
                        <Parameter type="T" name="y"/>
                        <Parameter type="T" name="z"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="SPoint3Tpl">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(T value){\n		this-&gt;x = value;\n		this-&gt;y = value;\n		this-&gt;z = value;\n	}</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const SPoint3Tpl&amp; value){\n		this-&gt;x = value.x;\n		this-&gt;y = value.y;\n		this-&gt;z = value.z;\n	}</Source>
                  </Method>
                  <Method name="operator+=">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(T value){\n      this-&gt;x += value;\n      this-&gt;y += value;\n      this-&gt;z += value;\n   }</Source>
                  </Method>
                  <Method name="operator+=">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(const SPoint3Tpl&amp; value){\n		this-&gt;x += value.x;\n		this-&gt;y += value.y;\n      this-&gt;z += value.z;\n   }</Source>
                  </Method>
                  <Method name="operator*=">
                     <Parameters>
                        <Parameter type="TFloat" name="factor"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator*=(TFloat factor){\n		this-&gt;x *= factor;\n		this-&gt;y *= factor;\n		this-&gt;z *= factor;\n	}</Source>
                  </Method>
                  <Method name="operator/=">
                     <Parameters>
                        <Parameter type="TFloat" name="factor"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator/=(TFloat factor){\n		this-&gt;x /= factor;\n		this-&gt;y /= factor;\n		this-&gt;z /= factor;\n	}</Source>
                  </Method>
                  <Method name="operator-=">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator-=(T value){\n      this-&gt;x -= value;\n      this-&gt;y -= value;\n      this-&gt;z -= value;\n   }</Source>
                  </Method>
                  <Method name="operator-=">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator-=(const SPoint3Tpl&amp; value){\n		this-&gt;x -= value.x;\n		this-&gt;y -= value.y;\n      this-&gt;z -= value.z;\n   }</Source>
                  </Method>
                  <Method name="operator==">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&amp;" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator==(const SPoint3Tpl&amp; value){\n		return (this-&gt;x == value.x &amp;&amp; this-&gt;y == value.y &amp;&amp; this-&gt;z == value.z);\n   }</Source>
                  </Method>
                  <Method name="operator!=">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&lt;T&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator!=(const SPoint3Tpl&lt;T&gt;&amp; value){\n		return (this-&gt;x != value.x || this-&gt;y != value.y || this-&gt;z != value.z);\n   }</Source>
                  </Method>
                  <Method name="Absolute">
                     <Return type="T"/>
                     <Source>\nT Absolute(){\n      return sqrt((x * x) + (y * y) + (z * z));\n   }</Source>
                  </Method>
                  <Method name="Normalize">
                     <Return type="void"/>
                     <Source>\nvoid Normalize(){\n      T v = Absolute();\n      x /= v;\n      y /= v;\n      z /= v;\n   }</Source>
                  </Method>
                  <Method name="Add">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Add(T value){\n      this-&gt;x += value;\n      this-&gt;y += value;\n      this-&gt;z += value;\n   }</Source>
                  </Method>
                  <Method name="Add">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&lt;T&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Add(const SPoint3Tpl&lt;T&gt;&amp; value){\n      this-&gt;x += value.x;\n      this-&gt;y += value.y;\n      this-&gt;z += value.z;\n   }</Source>
                  </Method>
                  <Method name="Sub">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Sub(T value){\n      this-&gt;x -= value;\n      this-&gt;y -= value;\n      this-&gt;z -= value;\n   }</Source>
                  </Method>
                  <Method name="Sub">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&lt;T&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Sub(const SPoint3Tpl&lt;T&gt;&amp; value){\n      this-&gt;x -= value.x;\n      this-&gt;y -= value.y;\n      this-&gt;z -= value.z;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T value){\n      this-&gt;x = value;\n      this-&gt;y = value;\n      this-&gt;z = value;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="x"/>
                        <Parameter type="T" name="y"/>
                        <Parameter type="T" name="z"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T x, T y, T z){\n      this-&gt;x = x;\n      this-&gt;y = y;\n      this-&gt;z = z;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&lt;T&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(const SPoint3Tpl&lt;T&gt;&amp; value){\n      this-&gt;x = value.x;\n      this-&gt;y = value.y;\n      this-&gt;z = value.z;\n   }</Source>
                  </Method>
                  <Method name="MergeMin">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&amp;" name="a"/>
                        <Parameter type="SPoint3Tpl&amp;" name="b"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid MergeMin(const SPoint3Tpl&amp; a, const SPoint3Tpl&amp; b){\n		this-&gt;x = MO_MIN(a.x, b.x);\n		this-&gt;y = MO_MIN(a.y, b.y);\n		this-&gt;z = MO_MIN(a.z, b.z);\n	}</Source>
                  </Method>
                  <Method name="MergeMax">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&amp;" name="a"/>
                        <Parameter type="SPoint3Tpl&amp;" name="b"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid MergeMax(const SPoint3Tpl&amp; a, const SPoint3Tpl&amp; b){\n		this-&gt;x = MO_MAX(a.x, b.x);\n		this-&gt;y = MO_MAX(a.y, b.y);\n		this-&gt;z = MO_MAX(a.z, b.z);\n	}</Source>
                  </Method>
                  <Method name="Reset">
                     <Return type="void"/>
                     <Source>\nvoid Reset(){\n      this-&gt;x = 0;\n      this-&gt;y = 0;\n      this-&gt;z = 0;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T" name="x"/>
                  <Attribute type="T" name="y"/>
                  <Attribute type="T" name="z"/>
               </Attributes>
            </Class>
            <Class name="SPoint4Tpl">
               <Methods>
                  <Method name="=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator =(TFloat value){\n		x = y = w = z;\n	}</Source>
                  </Method>
                  <Method name="=">
                     <Parameters>
                        <Parameter type="SPoint4Tpl&amp;" name="point4"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator =(const SPoint4Tpl&amp; point4){\n		x = point4.x;\n		y = point4.y;\n		z = point4.z;\n		w = point4.w;\n	}</Source>
                  </Method>
                  <Method name="+=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator +=(const TFloat value){\n		x += value;\n		y += value;\n		z += value;\n		w += value;\n	}</Source>
                  </Method>
                  <Method name="+=">
                     <Parameters>
                        <Parameter type="SPoint4Tpl&lt;T&gt;&amp;" name="point4"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator +=(const SPoint4Tpl&lt;T&gt;&amp; point4){\n		x += point4.x;\n		y += point4.y;\n		z += point4.z;\n		w += point4.w;\n	}</Source>
                  </Method>
                  <Method name="-=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator -=(const TFloat value){\n		x -= value;\n		y -= value;\n		z -= value;\n		w -= value;\n	}</Source>
                  </Method>
                  <Method name="-=">
                     <Parameters>
                        <Parameter type="SPoint4Tpl&lt;T&gt;&amp;" name="point4"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator -=(const SPoint4Tpl&lt;T&gt;&amp; point4){\n		x -= point4.x;\n		y -= point4.y;\n		z -= point4.z;\n		w -= point4.w;\n	}</Source>
                  </Method>
                  <Method name="*=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator *=(const TFloat value){\n		x *= value;\n		y *= value;\n		z *= value;\n		w *= value;\n	}</Source>
                  </Method>
                  <Method name="/=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator /=(const TFloat value){\n		x /= value;\n		y /= value;\n		z /= value;\n		w /= value;\n	}</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T value){\n      this-&gt;x = value;\n      this-&gt;y = value;\n      this-&gt;z = value;\n      this-&gt;w = value;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="x"/>
                        <Parameter type="T" name="y"/>
                        <Parameter type="T" name="z"/>
                        <Parameter type="T" name="w"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T x, T y, T z, T w){\n      this-&gt;x = x;\n      this-&gt;y = y;\n      this-&gt;z = z;\n      this-&gt;w = w;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="SPoint4Tpl&lt;T&gt;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(SPoint4Tpl&lt;T&gt; value){\n      this-&gt;x = value.x;\n      this-&gt;y = value.y;\n      this-&gt;z = value.z;\n      this-&gt;w = value.w;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T" name="x"/>
                  <Attribute type="T" name="y"/>
                  <Attribute type="T" name="z"/>
                  <Attribute type="T" name="w"/>
               </Attributes>
            </Class>
            <Class name="SQuaternionTpl">
               <Methods>
                  <Constructor name="SQuaternionTpl"/>
                  <Constructor name="SQuaternionTpl">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="SQuaternionTpl">
                     <Parameters>
                        <Parameter type="SQuaternionTpl&amp;" name="quaternion"/>
                     </Parameters>
                  </Constructor>
                  <Method name="=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator =(const TFloat value){\n		x = value;\n		y = value;\n		z = value;\n		w = value;\n	}</Source>
                  </Method>
                  <Method name="=">
                     <Parameters>
                        <Parameter type="SQuaternionTpl&amp;" name="quaternion"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator =(const SQuaternionTpl&amp; quaternion){\n		x = quaternion.x;\n		y = quaternion.y;\n		z = quaternion.z;\n		w = quaternion.w;\n	}</Source>
                  </Method>
                  <Method name="+=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator +=(const TFloat value){\n		x += value;\n		y += value;\n		z += value;\n		w += value;\n	}</Source>
                  </Method>
                  <Method name="+=">
                     <Parameters>
                        <Parameter type="SQuaternionTpl&amp;" name="quaternion"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator +=(const SQuaternionTpl&amp; quaternion){\n		x += quaternion.x;\n		y += quaternion.y;\n		z += quaternion.z;\n		w += quaternion.w;\n	}</Source>
                  </Method>
                  <Method name="-=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator -=(const TFloat value){\n		x -= value;\n		y -= value;\n		z -= value;\n		w -= value;\n	}</Source>
                  </Method>
                  <Method name="-=">
                     <Parameters>
                        <Parameter type="SQuaternionTpl&amp;" name="quaternion"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator -=(const SQuaternionTpl&amp; quaternion){\n		x -= quaternion.x;\n		y -= quaternion.y;\n		z -= quaternion.z;\n		w -= quaternion.w;\n	}</Source>
                  </Method>
                  <Method name="*=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator *=(const TFloat value){\n		x *= value;\n		y *= value;\n		z *= value;\n		w *= value;\n	}</Source>
                  </Method>
                  <Method name="/=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator /=(const TFloat value){\n		x /= value;\n		y /= value;\n		z /= value;\n		w /= value;\n	}</Source>
                  </Method>
                  <Method name="==">
                     <Parameters>
                        <Parameter type="SQuaternionTpl&amp;" name="quaternion"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nTBool operator ==(const SQuaternionTpl&amp; quaternion){\n		return (x==quaternion.x)&amp;&amp;(y==quaternion.y)&amp;&amp;(z==quaternion.z)&amp;&amp;(w==quaternion.w);\n	}</Source>
                  </Method>
                  <Method name="!=">
                     <Parameters>
                        <Parameter type="SQuaternionTpl&amp;" name="quaternion"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nTBool operator !=(const SQuaternionTpl&amp; quaternion){\n		return (x!=quaternion.x)||(y!=quaternion.y)||(z!=quaternion.z)||(w!=quaternion.w);\n	}</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T value){\n      this-&gt;x = value;\n      this-&gt;y = value;\n      this-&gt;z = value;\n      this-&gt;w = value;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="x"/>
                        <Parameter type="T" name="y"/>
                        <Parameter type="T" name="z"/>
                        <Parameter type="T" name="w"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T x, T y, T z, T w){\n      this-&gt;x = x;\n      this-&gt;y = y;\n      this-&gt;z = z;\n      this-&gt;w = w;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="SQuaternionTpl&amp;" name="quaternion"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(const SQuaternionTpl&amp; quaternion){\n      this-&gt;x = quaternion.x;\n      this-&gt;y = quaternion.y;\n      this-&gt;z = quaternion.z;\n      this-&gt;w = quaternion.w;\n   }</Source>
                  </Method>
                  <Method name="Absolute">
                     <Return type="T"/>
                     <Source>\nT Absolute(){\n      return sqrt((x * x) + (y * y) + (z * z) + (w * w));\n   }</Source>
                  </Method>
                  <Method name="Normalize">
                     <Return type="void"/>
                     <Source>\nvoid Normalize(){\n      T v = Absolute();\n      x /= v;\n      y /= v;\n      z /= v;\n      w /= v;\n   }</Source>
                  </Method>
                  <Method name="Increase">
                     <Parameters>
                        <Parameter type="SQuaternionTpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Increase(SQuaternionTpl&amp; v){\n      x += v.x;\n      y += v.y;\n      z += v.z;\n      w += v.w;\n   }</Source>
                  </Method>
                  <Method name="Subtract">
                     <Parameters>
                        <Parameter type="SQuaternionTpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Subtract(SQuaternionTpl&amp; v){\n      x -= v.x;\n      y -= v.y;\n      z -= v.z;\n      w -= v.w;\n   }</Source>
                  </Method>
                  <Method name="Multiply">
                     <Parameters>
                        <Parameter type="SQuaternionTpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="SQuaternionTpl"/>
                     <Source>\nSQuaternionTpl Multiply(SQuaternionTpl&amp; v){\n      SQuaternionTpl r;\n      r.x = (w * v.x) + (x * v.w) + (y * v.z) - (z * v.y);\n      r.y = (w * v.y) + (y * v.w) + (z * v.x) - (x * v.z);\n      r.z = (w * v.z) + (z * v.w) + (x * v.y) - (y * v.x);\n      r.w = (w * v.w) - (x * v.x) - (y * v.y) - (z * v.z);\n      return r;\n   }</Source>
                  </Method>
                  <Method name="ToVector3">
                     <Parameters>
                        <Parameter type="SVector3Tpl&lt;T&gt;*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid ToVector3(SVector3Tpl&lt;T&gt;* pValue){\n      pValue-&gt;x = x / w;\n      pValue-&gt;y = y / w;\n      pValue-&gt;z = z / w;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T" name="x"/>
                  <Attribute type="T" name="y"/>
                  <Attribute type="T" name="z"/>
                  <Attribute type="T" name="w"/>
               </Attributes>
            </Class>
            <Class name="SRectTpl">
               <Methods>
                  <Constructor name="SRectTpl"/>
                  <Constructor name="SRectTpl">
                     <Parameters>
                        <Parameter type="T" name="left"/>
                        <Parameter type="T" name="top"/>
                        <Parameter type="T" name="right"/>
                        <Parameter type="T" name="bottom"/>
                     </Parameters>
                  </Constructor>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="left"/>
                        <Parameter type="T" name="top"/>
                        <Parameter type="T" name="right"/>
                        <Parameter type="T" name="bottom"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T left, T top, T right, T bottom){\n      this-&gt;left = left;\n      this-&gt;top = top;\n      this-&gt;right = right;\n      this-&gt;bottom = bottom;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T" name="left"/>
                  <Attribute type="T" name="top"/>
                  <Attribute type="T" name="right"/>
                  <Attribute type="T" name="bottom"/>
               </Attributes>
            </Class>
            <Class name="SResource">
               <Attributes>
                  <Attribute type="TUint" name="Type"/>
                  <Attribute type="TUint" name="Index"/>
                  <Attribute type="TUint" name="Flag"/>
               </Attributes>
            </Class>
            <Class name="SSetEntry">
               <Attributes>
                  <Attribute type="SSetEntry*" name="pLink"/>
                  <Attribute type="SSetEntry*" name="pPrior"/>
                  <Attribute type="SSetEntry*" name="pNext"/>
                  <Attribute type="N" name="code"/>
                  <Attribute type="V" name="value"/>
               </Attributes>
            </Class>
            <Class name="SShareMemoryInfo">
               <Attributes>
                  <Attribute type="TInt" name="size"/>
                  <Attribute type="TDateTime" name="createDate"/>
                  <Attribute type="TDateTime" name="updateDate"/>
               </Attributes>
            </Class>
            <Class name="SSharedEntryAllocatorHead">
               <Attributes>
                  <Attribute type="TInt" name="count"/>
                  <Attribute type="TInt" name="unused"/>
               </Attributes>
            </Class>
            <Class name="SSharedListEntry">
               <Attributes>
                  <Attribute type="TInt32" name="list"/>
                  <Attribute type="TInt32" name="index"/>
                  <Attribute type="TInt32" name="prior"/>
                  <Attribute type="TInt32" name="next"/>
                  <Attribute type="TInt32" name="code"/>
               </Attributes>
            </Class>
            <Class name="SSharedListHead">
               <Attributes>
                  <Attribute type="TInt32" name="count"/>
                  <Attribute type="TInt32" name="index"/>
                  <Attribute type="TInt32" name="first"/>
                  <Attribute type="TInt32" name="last"/>
                  <Attribute type="TInt32" name="prior"/>
                  <Attribute type="TInt32" name="next"/>
               </Attributes>
            </Class>
            <Class name="SSharedSetEntry">
               <Attributes>
                  <Attribute type="I" name="link"/>
                  <Attribute type="I" name="prior"/>
                  <Attribute type="I" name="next"/>
                  <Attribute type="T" name="code"/>
               </Attributes>
            </Class>
            <Class name="SSharedSetHead">
               <Attributes>
                  <Attribute type="TInt" name="count"/>
                  <Attribute type="TInt" name="first"/>
                  <Attribute type="TInt" name="last"/>
               </Attributes>
            </Class>
            <Class name="SSize3Tpl">
               <Methods>
                  <Constructor name="SSize3Tpl"/>
                  <Constructor name="SSize3Tpl">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="SSize3Tpl">
                     <Parameters>
                        <Parameter type="T" name="width"/>
                        <Parameter type="T" name="height"/>
                        <Parameter type="T" name="deep"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="SSize3Tpl">
                     <Parameters>
                        <Parameter type="SSize3Tpl&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(T value){\n      width = value;\n      height = value;\n      deep = value;\n   }</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="SSize3Tpl&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const SSize3Tpl&amp; value){\n      width = value.width;\n      height = value.height;\n      deep = value.deep;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T value){\n      width = value;\n      height = value;\n      deep = value;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="width"/>
                        <Parameter type="T" name="height"/>
                        <Parameter type="T" name="deep"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T width, T height, T deep){\n      this-&gt;width = width;\n      this-&gt;height = height;\n      this-&gt;deep = deep;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="SSize3Tpl&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(const SSize3Tpl&amp; value){\n      width = value.width;\n      height = value.height;\n      deep = value.deep;\n   }</Source>
                  </Method>
                  <Method name="Square">
                     <Return type="T"/>
                     <Source>\nT Square(){\n      return width * height * deep;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T" name="width"/>
                  <Attribute type="T" name="height"/>
                  <Attribute type="T" name="deep"/>
               </Attributes>
            </Class>
            <Class name="SSizeTpl">
               <Methods>
                  <Constructor name="SSizeTpl"/>
                  <Constructor name="SSizeTpl">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="SSizeTpl">
                     <Parameters>
                        <Parameter type="T" name="width"/>
                        <Parameter type="T" name="height"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="SSizeTpl">
                     <Parameters>
                        <Parameter type="SSizeTpl&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(T value){\n      width = value;\n      height = value;\n   }</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="SSizeTpl&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const SSizeTpl&amp; value){\n      width = value.width;\n      height = value.height;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T value){\n      width = value;\n      height = value;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="width"/>
                        <Parameter type="T" name="height"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T width, T height){\n      this-&gt;width = width;\n      this-&gt;height = height;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="SSizeTpl&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(const SSizeTpl&amp; value){\n      width = value.width;\n      height = value.height;\n   }</Source>
                  </Method>
                  <Method name="Square">
                     <Return type="T"/>
                     <Source>\nT Square(){\n      return width * height;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T" name="width"/>
                  <Attribute type="T" name="height"/>
               </Attributes>
            </Class>
            <Class name="STreeEntry">
               <Attributes>
                  <Attribute type="STreeEntry*" name="pPrior"/>
                  <Attribute type="STreeEntry*" name="pNext"/>
                  <Attribute type="STreeEntry**" name="ppNodes"/>
                  <Attribute type="TBool" name="exists"/>
                  <Attribute type="N" name="code"/>
                  <Attribute type="V" name="value"/>
               </Attributes>
            </Class>
            <Class name="SValue">
               <Methods>
                  <Constructor name="SValue"/>
                  <Constructor name="SValue">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Method name="T">
                     <Return type="const"/>
                     <Source>\noperator const T() const{\n      return _value;\n   }</Source>
                  </Method>
                  <Method name="IsNull">
                     <Return type="TBool"/>
                     <Source>\nTBool IsNull() const{\n      return _null;\n   }</Source>
                  </Method>
                  <Method name="Get">
                     <Return type="T"/>
                     <Source>\nT Get() const{\n      return _value;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T value) {\n      _null = EFalse;\n      _value = value;\n   }</Source>
                  </Method>
                  <Method name="Clear">
                     <Return type="void"/>
                     <Source>\nvoid Clear() {\n      _null = ETrue;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TBool" name="_null"/>
                  <Attribute type="T" name="_value"/>
               </Attributes>
            </Class>
            <Class name="SVector2Tpl">
               <Methods>
                  <Constructor name="SVector2Tpl"/>
                  <Constructor name="SVector2Tpl">
                     <Parameters>
                        <Parameter type="T" name="v"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="SVector2Tpl">
                     <Parameters>
                        <Parameter type="T" name="x"/>
                        <Parameter type="T" name="y"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="SVector2Tpl">
                     <Parameters>
                        <Parameter type="SVector2Tpl&amp;" name="vector2"/>
                     </Parameters>
                  </Constructor>
                  <Method name="=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator =(TFloat value){\n		x = y = value;\n	}</Source>
                  </Method>
                  <Method name="=">
                     <Parameters>
                        <Parameter type="SVector2Tpl&amp;" name="vector2"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator =(const SVector2Tpl&amp; vector2){\n		x = vector2.x;\n		y = vector2.y;\n	}</Source>
                  </Method>
                  <Method name="*=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator *=(const TFloat value){\n		x *= value;\n		y *= value;\n	}</Source>
                  </Method>
                  <Method name="/=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator /=(const TFloat value){\n		x /= value;\n		y /= value;\n	}</Source>
                  </Method>
                  <Method name="+=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator +=(const TFloat value){\n		x += value;\n		y += value;\n	}</Source>
                  </Method>
                  <Method name="+=">
                     <Parameters>
                        <Parameter type="SVector2Tpl&amp;" name="vector2"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator +=(const SVector2Tpl&amp; vector2){\n		x += vector2.x;\n		y += vector2.y;\n	}</Source>
                  </Method>
                  <Method name="-=">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator -=(const TFloat value){\n		x -= value;\n		y -= value;\n	}</Source>
                  </Method>
                  <Method name="-=">
                     <Parameters>
                        <Parameter type="SVector2Tpl&amp;" name="vector2"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nvoid operator -=(const SVector2Tpl&amp; vector2){\n		x -= vector2.x;\n		y -= vector2.y;\n	}</Source>
                  </Method>
                  <Method name="==">
                     <Parameters>
                        <Parameter type="SVector2Tpl&amp;" name="vector2"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nTBool operator ==(const SVector2Tpl&amp; vector2){\n		return ((this-&gt;x == vector2.x) &amp;&amp; (this-&gt;y == vector2.y));\n	}</Source>
                  </Method>
                  <Method name="!=">
                     <Parameters>
                        <Parameter type="SVector2Tpl&amp;" name="vector2"/>
                     </Parameters>
                     <Return type="operator"/>
                     <Source>\nTBool operator !=(const SVector2Tpl&amp; vector2){\n		return ((this-&gt;x != vector2.x) || (this-&gt;y != vector2.y));\n	}</Source>
                  </Method>
                  <Method name="Absolute">
                     <Return type="T"/>
                     <Source>\nT Absolute(){\n      return sqrt((x * x) + (y * y));\n   }</Source>
                  </Method>
                  <Method name="Increase">
                     <Parameters>
                        <Parameter type="SVector2Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Increase(SVector2Tpl&amp; v){\n      x += v.x;\n      y += v.y;\n   }</Source>
                  </Method>
                  <Method name="Subtract">
                     <Parameters>
                        <Parameter type="SVector2Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Subtract(SVector2Tpl&amp; v){\n      x -= v.x;\n      y -= v.y;\n   }</Source>
                  </Method>
                  <Method name="Normalize">
                     <Return type="void"/>
                     <Source>\nvoid Normalize(){\n      T v = Absolute();\n      x /= v;\n      y /= v;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T" name="x"/>
                  <Attribute type="T" name="y"/>
               </Attributes>
            </Class>
            <Class name="SVector3Tpl">
               <Methods>
                  <Constructor name="SVector3Tpl"/>
                  <Constructor name="SVector3Tpl">
                     <Parameters>
                        <Parameter type="T" name="v"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="SVector3Tpl">
                     <Parameters>
                        <Parameter type="T" name="x"/>
                        <Parameter type="T" name="y"/>
                        <Parameter type="T" name="z"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="SVector3Tpl">
                     <Parameters>
                        <Parameter type="SPoint3Tpl&lt;T&gt;" name="a"/>
                        <Parameter type="SPoint3Tpl&lt;T&gt;" name="b"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(T value){\n		this-&gt;x = value;\n		this-&gt;y = value;\n		this-&gt;z = value;\n	}</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="SVector3Tpl&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const SVector3Tpl&amp; value){\n		this-&gt;x = value.x;\n		this-&gt;y = value.y;\n		this-&gt;z = value.z;\n	}</Source>
                  </Method>
                  <Method name="operator+=">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(T value){\n		this-&gt;x += value;\n		this-&gt;y += value;\n		this-&gt;z += value;\n	}</Source>
                  </Method>
                  <Method name="operator+=">
                     <Parameters>
                        <Parameter type="SVector3Tpl&lt;T&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(const SVector3Tpl&lt;T&gt;&amp; value){\n		this-&gt;x += value.x;\n		this-&gt;y += value.y;\n		this-&gt;z += value.z;\n	}</Source>
                  </Method>
                  <Method name="operator-=">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator-=(T value){\n		this-&gt;x -= value;\n		this-&gt;y -= value;\n		this-&gt;z -= value;\n	}</Source>
                  </Method>
                  <Method name="operator-=">
                     <Parameters>
                        <Parameter type="SVector3Tpl&lt;T&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator-=(const SVector3Tpl&lt;T&gt;&amp; value){\n		this-&gt;x -= value.x;\n		this-&gt;y -= value.y;\n		this-&gt;z -= value.z;\n	}</Source>
                  </Method>
                  <Method name="operator*=">
                     <Parameters>
                        <Parameter type="TFloat" name="factor"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator*=(TFloat factor){\n		this-&gt;x *= factor;\n		this-&gt;y *= factor;\n		this-&gt;z *= factor;\n	}</Source>
                  </Method>
                  <Method name="operator/=">
                     <Parameters>
                        <Parameter type="TFloat" name="factor"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator/=(TFloat factor){\n		this-&gt;x /= factor;\n		this-&gt;y /= factor;\n		this-&gt;z /= factor;\n	}</Source>
                  </Method>
                  <Method name="operator==">
                     <Parameters>
                        <Parameter type="SVector3Tpl&lt;T&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator==(const SVector3Tpl&lt;T&gt;&amp; value){\n		return (this-&gt;x == value.x &amp;&amp; this-&gt;y == value.y &amp;&amp; this-&gt;z == value.z);\n	}</Source>
                  </Method>
                  <Method name="operator!=">
                     <Parameters>
                        <Parameter type="SVector3Tpl&lt;T&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator!=(const SVector3Tpl&lt;T&gt;&amp; value){\n		return (this-&gt;x != value.x || this-&gt;y != value.y || this-&gt;z != value.z);\n	}</Source>
                  </Method>
                  <Method name="Reset">
                     <Return type="void"/>
                     <Source>\nvoid Reset(){\n      x = 0;\n      y = 0;\n      z = 0;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="v"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T v){\n      this-&gt;x = v;\n      this-&gt;y = v;\n      this-&gt;z = v;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="T" name="x"/>
                        <Parameter type="T" name="y"/>
                        <Parameter type="T" name="z"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(T x, T y, T z){\n      this-&gt;x = x;\n      this-&gt;y = y;\n      this-&gt;z = z;\n   }</Source>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="SVector3Tpl&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(const SVector3Tpl&amp; value){\n      this-&gt;x = value.x;\n      this-&gt;y = value.y;\n      this-&gt;z = value.z;\n   }</Source>
                  </Method>
                  <Method name="Absolute">
                     <Return type="T"/>
                     <Source>\nT Absolute(){\n      return sqrt((x * x) + (y * y) + (z * z));\n   }</Source>
                  </Method>
                  <Method name="MergeMin">
                     <Parameters>
                        <Parameter type="SVector3Tpl&amp;" name="a"/>
                        <Parameter type="SVector3Tpl&amp;" name="b"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid MergeMin(const SVector3Tpl&amp; a, const SVector3Tpl&amp; b){\n		this-&gt;x = MO_MIN(a.x, b.x);\n		this-&gt;y = MO_MIN(a.y, b.y);\n		this-&gt;z = MO_MIN(a.z, b.z);\n	}</Source>
                  </Method>
                  <Method name="MergeMax">
                     <Parameters>
                        <Parameter type="SVector3Tpl&amp;" name="a"/>
                        <Parameter type="SVector3Tpl&amp;" name="b"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid MergeMax(const SVector3Tpl&amp; a, const SVector3Tpl&amp; b){\n		this-&gt;x = MO_MAX(a.x, b.x);\n		this-&gt;y = MO_MAX(a.y, b.y);\n		this-&gt;z = MO_MAX(a.z, b.z);\n	}</Source>
                  </Method>
                  <Method name="Cross" description="点乘(内积)。">
                     <Parameters>
                        <Parameter type="SVector3Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="SVector3Tpl"/>
                     <Source>\nSVector3Tpl Cross(SVector3Tpl&amp; v){\n      SVector3Tpl r;\n      return r;\n   }</Source>
                  </Method>
                  <Method name="Multiply">
                     <Parameters>
                        <Parameter type="SVector3Tpl&amp;" name="v"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Multiply(SVector3Tpl&amp; v){\n   }</Source>
                  </Method>
                  <Method name="Normalize">
                     <Return type="void"/>
                     <Source>\nvoid Normalize(){\n      T v = Absolute();\n      x /= v;\n      y /= v;\n      z /= v;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T" name="x"/>
                  <Attribute type="T" name="y"/>
                  <Attribute type="T" name="z"/>
               </Attributes>
            </Class>
            <Class name="TArray">
               <Inherits>
                  <Inherit name="MArray" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TArray" description="构造变长数组。"/>
                  <Constructor name="TArray" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TArray" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TArray" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TArray" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="MArrayC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TArray" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="TArray&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TArray" description="析构变长数组。"/>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      // 当第一次使用的时候，收集不小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n      this-&gt;_length = 0;\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_pMemory = RTypeMemory&lt;T&gt;::Alloc(this-&gt;_size, NULL);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MPtrC&lt;T&gt;&amp; ptr){\n      Assign(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="MArrayC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MArrayC&lt;T&gt;&amp; values){\n      Assign(values.MemoryC(), values.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="TArray&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TArray&amp; values){\n      Assign(values.MemoryC(), values.Length());\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if(size &gt; this-&gt;_size){\n         // 当内存不足时，扩大1.5倍内存，但收集量不得小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n         this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n         this-&gt;_size += this-&gt;_size &gt;&gt; 1;\n         T* pMemory = RTypeMemory&lt;T&gt;::Alloc(this-&gt;_size, 0);\n         if(this-&gt;_length &gt; 0){\n            RTypes&lt;T&gt;::Copy(pMemory, this-&gt;_pMemory, this-&gt;_length);\n         }\n         RTypeMemory&lt;T&gt;::Free(this-&gt;_pMemory);\n         this-&gt;_pMemory = pMemory;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TArrayIteratorC">
               <Methods>
                  <Constructor name="TArrayIteratorC" description="构造只读迭代器。"/>
                  <Constructor name="TArrayIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="TArrayIteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TArrayIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                  </Constructor>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(T* pMemory, TInt length){\n      _pMemory = pMemory;\n      _length = length;\n      _index = -1;\n   }</Source>
                  </Method>
                  <Method name="*" type="inline" description="获得当前位置的数据内容。">
                     <Return type="operator"/>
                     <Source>\ninline const T&amp; operator *() const{\n      MO_ASSERT(_pMemory);\n      MO_ASSERT_RANGE(_index, 0, _length);\n      return _pMemory[_index];\n   }</Source>
                  </Method>
                  <Method name="operator-&gt;" type="inline" description="获得当前位置的数据内容。">
                     <Return type="T"/>
                     <Source>\ninline const T operator-&gt;() const{\n      MO_ASSERT(_pMemory);\n      MO_ASSERT_RANGE(_index, 0, _length);\n      return _pMemory[_index];\n   }</Source>
                  </Method>
                  <Method name="IsEmpty" type="inline" description="当前节点是否含有数据。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsEmpty(){\n      return (0 == _length);\n   }</Source>
                  </Method>
                  <Method name="Equals" type="inline" description="判断数据内容是否相等。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool Equals(T value){\n      MO_ASSERT(_pMemory);\n      MO_ASSERT_RANGE(_index, 0, _length);\n      return _pMemory[_index] == value;\n   }</Source>
                  </Method>
                  <Method name="HasNext" type="inline" description="判断是否存在下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool HasNext(){\n      return (_length &gt; 0) ? _index + 1 &lt; _length : EFalse;\n   }</Source>
                  </Method>
                  <Method name="Next" type="inline" description=" 移动到下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Next(){\n      if(_length &gt; 0 &amp;&amp; (_index + 1 &lt; _length)){\n         _index++;\n         return ETrue;\n      }\n      return EFalse;\n   }</Source>
                  </Method>
                  <Method name="HasPrior" type="inline" description="判断是否存在下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool HasPrior(){\n      return (_length &gt; 0) ? _index - 1 &gt;= 0 : EFalse;\n   }</Source>
                  </Method>
                  <Method name="Prior" type="inline" description="移动到上一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Prior(){\n      if(_length &gt; 0 &amp;&amp; (_index + 1 &lt; _length)){\n         _index--;\n         return ETrue;\n      }\n      return EFalse;\n   }</Source>
                  </Method>
                  <Method name="Get" type="inline" description="获得当前位置的数据内容。">
                     <Return type="T"/>
                     <Source>\ninline T Get(){\n      MO_ASSERT(_pMemory);\n      MO_ASSERT_RANGE(_index, 0, _length);\n      return _pMemory[_index];\n   }</Source>
                  </Method>
                  <Method name="Reset" type="inline" description="重置位置。">
                     <Return type="void"/>
                     <Source>\ninline void Reset(){\n      _index = -1;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T*" name="_pMemory"/>
                  <Attribute type="TInt" name="_length"/>
                  <Attribute type="TInt" name="_index"/>
               </Attributes>
            </Class>
            <Class name="TAttributes">
               <Inherits>
                  <Inherit name="MAttributes" scope="public"/>
               </Inherits>
            </Class>
            <Class name="TAttributesIterator">
               <Inherits>
                  <Inherit name="TAttributesIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TAttributesIterator"/>
                  <Constructor name="TAttributesIterator">
                     <Parameters>
                        <Parameter type="TAttributesIteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TAttributesIterator">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                  </Constructor>
                  <Method name="SetValue" type="inline">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void SetValue(TCharC* pValue) const{\n      MO_ASSERT(this-&gt;_pEntry);\n      this-&gt;_pEntry-&gt;pValue-&gt;Assign(pValue);\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TAttributesIteratorC">
               <Inherits>
                  <Inherit name="MEntryIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TAttributesIteratorC"/>
                  <Constructor name="TAttributesIteratorC">
                     <Parameters>
                        <Parameter type="TAttributesIteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TAttributesIteratorC">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                  </Constructor>
                  <Method name="*" type="inline" description="获得当前位置的数据内容。">
                     <Return type="operator"/>
                     <Source>\ninline const FString&amp; operator *() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return *(this-&gt;_pEntry-&gt;pValue);\n   }</Source>
                  </Method>
                  <Method name="operator-&gt;" type="inline" description="获得当前位置的数据内容。">
                     <Return type="FString*"/>
                     <Source>\ninline const FString* operator-&gt;() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;pValue;\n   }</Source>
                  </Method>
                  <Method name="IsName" type="inline" description="判断名称是否相同。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsName(TCharC* pName) const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;pName-&gt;Equals(pName);\n   }</Source>
                  </Method>
                  <Method name="IsValue" type="inline" description="判断内容是否相同。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsValue(TCharC* pValue) const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;pValue-&gt;Equals(pValue);\n   }</Source>
                  </Method>
                  <Method name="Name" type="inline" description="获得当前位置的数据名称。">
                     <Return type="TCharC*"/>
                     <Source>\ninline TCharC* Name() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;pName-&gt;MemoryC();\n   }</Source>
                  </Method>
                  <Method name="Value" type="inline" description="获得当前位置的数据内容。">
                     <Return type="TCharC*"/>
                     <Source>\ninline TCharC* Value() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;pValue-&gt;MemoryC();\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TAutoPtr">
               <Methods>
                  <Constructor name="TAutoPtr" description="构造指针。"/>
                  <Constructor name="TAutoPtr" description="构造指针。">
                     <Parameters>
                        <Parameter type="T*" name="pObject"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TAutoPtr" description="析构构造指针。"/>
                  <Method name="*" type="inline" description="获取对象指针。">
                     <Return type="operator"/>
                     <Source>\ninline T&amp; operator *(){\n      return _pObject;\n   }</Source>
                  </Method>
                  <Method name="operator-&gt;" type="inline" description="获取对象指针。">
                     <Return type="T"/>
                     <Source>\ninline T operator-&gt;(){\n      MO_ASSERT(_pObject);\n      return _pObject;\n   }</Source>
                  </Method>
                  <Method name="operator=" type="inline" description="获取对象指针。">
                     <Parameters>
                        <Parameter type="TAutoPtr&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void operator=(TAutoPtr&amp; ptr){\n      _pObject = *ptr;\n      _refer = ptr.Refer();\n      ptr.Reset();\n   }</Source>
                  </Method>
                  <Method name="Refer" description="获得引用次数。">
                     <Return type="TInt"/>
                     <Source>\nTInt Refer(){\n      return _refer;\n   }</Source>
                  </Method>
                  <Method name="Increase" description="增加引用次数。">
                     <Return type="void"/>
                     <Source>\nvoid Increase(){\n      _refer++;\n   }</Source>
                  </Method>
                  <Method name="Decrease" description="减少引用次数。">
                     <Return type="void"/>
                     <Source>\nvoid Decrease(){\n      _refer--;\n      if(_refer &lt;= 0){\n         //MO_DELETE(_pObject);\n      }\n   }</Source>
                  </Method>
                  <Method name="Reset" description="重置对象。">
                     <Return type="void"/>
                     <Source>\nvoid Reset(){\n      _pObject = NULL;\n      _refer++;\n   }</Source>
                  </Method>
                  <Method name="Release" description="强制释放对象。">
                     <Return type="void"/>
                     <Source>\nvoid Release(){\n      if(NULL != _pObject){\n         //MO_DELETE(_pObject);\n      }\n      _pObject = NULL;\n      _refer++;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T*" name="_pObject"/>
                  <Attribute type="TInt" name="_refer"/>
               </Attributes>
            </Class>
            <Class name="TClassInfo">
               <Methods>
                  <Constructor name="TClassInfo"/>
                  <Constructor name="TClassInfo">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TClassInfo"/>
                  <Method name="Space">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* TClassInfo::Space(){\n	return _space.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Name">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* TClassInfo::Name(){\n	return _name.MemoryC();\n}</Source>
                  </Method>
                  <Method name="FullName">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* TClassInfo::FullName(){\n	return _fullName.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Parse">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool TClassInfo::Parse(TCharC* pValue){\n	TFsName fullName = pValue;\n	TInt length = fullName.Length();\n#ifndef _WINDOWS\n	TInt spaceLenStart = fullName.IndexOf('N') + 1;\n	TInt spaceLenEnd = spaceLenStart;\n	for(TInt i = spaceLenStart; i &lt; length; i++){\n		if(!RChar::IsDigit(fullName[i])){\n			break;\n		}\n		spaceLenEnd++;\n	}\n	TFsName spaceLenStr = fullName.SubPtrC(spaceLenStart, spaceLenEnd);\n	TInt spaceLen = RInt::Parse(spaceLenStr.MemoryC());\n	MO_ASSERT(spaceLen &lt; length);\n	_space = fullName.SubPtrC(spaceLenEnd, spaceLenEnd + spaceLen);\n	TInt nameLenStart = spaceLenEnd + spaceLen;\n	TInt nameLenEnd = nameLenStart;\n	for(TInt i = nameLenStart; i &lt; length; i++){\n		if(!RChar::IsDigit(fullName[i])){\n			break;\n		}\n		nameLenEnd++;\n	}\n	TFsName nameLenStr = fullName.SubPtrC(nameLenStart, nameLenEnd);\n	TInt nameLen = RInt::Parse(nameLenStr.MemoryC());\n	MO_ASSERT(nameLen &lt; length);\n	_name = fullName.SubPtrC(nameLenEnd, nameLenEnd + nameLen);\n	_fullName.AppendFormat(&quot;%s::%s&quot;, _space.MemoryC(), _name.MemoryC());\n#else\n	// class MO::FList\n	TInt spaceStart = fullName.IndexOf(' ') + 1;\n	TInt spaceEnd = fullName.IndexOf(':');\n	_space = fullName.SubPtrC(spaceStart, spaceEnd);\n	_name = fullName.SubPtrC(spaceEnd + 2, length);\n	_fullName = fullName.SubPtrC(spaceStart, length);\n#endif\n	return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsName" name="_space"/>
                  <Attribute type="TFsName" name="_name"/>
                  <Attribute type="TFsName" name="_fullName"/>
               </Attributes>
            </Class>
            <Class name="TDataInput">
               <Inherits>
                  <Inherit name="IDataInput" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TDataInput" description="构造输入数据流的实例。"/>
                  <Constructor name="TDataInput" description="构造输入数据流的实例。">
                     <Parameters>
                        <Parameter type="IInput*" name="pInput" description="输入接口"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TDataInput" description="析构输入数据流的实例。"/>
                  <Method name="Input" description="获得输入接口。">
                     <Return type="IInput*" description="输入接口"/>
                     <Source>//============================================================\n// &lt;T&gt;获得输入接口。&lt;/T&gt;\n//\n// @return 输入接口\n//============================================================\n\nIInput* TDataInput::Input(){\n   return _pInput;\n}</Source>
                  </Method>
                  <Method name="SetInput" description="设置输入接口。">
                     <Parameters>
                        <Parameter type="IInput*" name="pInput" description="输入接口"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置输入接口。&lt;/T&gt;\n//\n// @param pInput 输入接口\n//============================================================\n\nvoid TDataInput::SetInput(IInput* pInput){\n   _pInput = pInput;\n}</Source>
                  </Method>
                  <Method name="Read" flag="override" description="读取数据">
                     <Parameters>
                        <Parameter type="TAny*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt" description="返回读取长度"/>
                     <Source>//============================================================\n// &lt;T&gt;读取数据&lt;/T&gt;\n//\n// @return 返回读取长度\n//============================================================\n\nTInt TDataInput::Read(TAny* pData, TSize size){\n   return _pInput-&gt;Read(pData, size);\n}</Source>
                  </Method>
                  <Method name="ReadBoolean" flag="override" description="读取TBool类型数据">
                     <Return type="TBool" description="返回TBool类型数据"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TBool类型数据&lt;/T&gt;\n//\n// @return 返回TBool类型数据\n//============================================================\n\nTBool TDataInput::ReadBoolean(){\n   TBool value;\n   _pInput-&gt;Read(&amp;value, sizeof(TBool));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadInt" flag="override" description="读取TInt类型数据">
                     <Return type="TInt" description="返回TInt类型类型数据"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TInt类型数据&lt;/T&gt;\n//\n// @return 返回TInt类型类型数据\n//============================================================\n\nTInt TDataInput::ReadInt(){\n   TInt value;\n   _pInput-&gt;Read(&amp;value, sizeof(TInt));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadInt8" flag="override" description="读取TInt8类型数据">
                     <Return type="TInt8" description="返回TInt类型类型数据"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TInt8类型数据&lt;/T&gt;\n//\n// @return 返回TInt类型类型数据\n//============================================================\n\nTInt8 TDataInput::ReadInt8(){\n   TInt8 value;\n   _pInput-&gt;Read(&amp;value, sizeof(TInt8));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadInt16" flag="override" description="读取TInt16类型数据">
                     <Return type="TInt16" description="返回TInt类型类型数据"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TInt16类型数据&lt;/T&gt;\n//\n// @return 返回TInt类型类型数据\n//============================================================\n\nTInt16 TDataInput::ReadInt16(){\n   TInt16 value;\n   _pInput-&gt;Read(&amp;value, sizeof(TInt16));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadInt32" flag="override" description="读取TInt32类型数据">
                     <Return type="TInt32" description="返回TInt类型类型数据"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TInt32类型数据&lt;/T&gt;\n//\n// @return 返回TInt类型类型数据\n//============================================================\n\nTInt32 TDataInput::ReadInt32(){\n    TInt32 value;\n    _pInput-&gt;Read(&amp;value, sizeof(TInt32));\n    return value;\n}</Source>
                  </Method>
                  <Method name="ReadInt64" flag="override" description="读取TInt64类型数据">
                     <Return type="TInt64" description="返回TInt类型类型数据"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TInt64类型数据&lt;/T&gt;\n//\n// @return 返回TInt类型类型数据\n//============================================================\n\nTInt64 TDataInput::ReadInt64(){\n   TInt64 value;\n   _pInput-&gt;Read(&amp;value, sizeof(TInt64));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadUint" flag="override">
                     <Return type="TUint"/>
                     <Source>//============================================================\n\nTUint TDataInput::ReadUint(){\n   TUint value;\n   _pInput-&gt;Read(&amp;value, sizeof(TUint));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadUint8" flag="override">
                     <Return type="TUint8"/>
                     <Source>//============================================================\n\nTUint8 TDataInput::ReadUint8(){\n   TUint8 value;\n   _pInput-&gt;Read(&amp;value, sizeof(TUint8));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadUint16" flag="override">
                     <Return type="TUint16"/>
                     <Source>//============================================================\n\nTUint16 TDataInput::ReadUint16(){\n   TUint16 value;\n   _pInput-&gt;Read(&amp;value, sizeof(TUint16));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadUint32" flag="override">
                     <Return type="TUint32"/>
                     <Source>//============================================================\n\nTUint32 TDataInput::ReadUint32(){\n   TUint32 value;\n   _pInput-&gt;Read(&amp;value, sizeof(TUint32));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadUint64" flag="override">
                     <Return type="TUint64"/>
                     <Source>//============================================================\n\nTUint64 TDataInput::ReadUint64(){\n   TUint64 value;\n   _pInput-&gt;Read(&amp;value, sizeof(TUint64));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadFloat" flag="override" description="读取TFloat类型数据">
                     <Return type="TFloat" description="返回TFoalt类型类型数据"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TFloat类型数据&lt;/T&gt;\n//\n// @return 返回TFoalt类型类型数据\n//============================================================\n\nTFloat TDataInput::ReadFloat(){\n   TFloat value;\n   _pInput-&gt;Read(&amp;value, sizeof(TFloat));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadDouble" flag="override" description="读取TDouble类型数据">
                     <Return type="TDouble" description="返回TDouble类型类型数据"/>
                     <Source>//============================================================\n// &lt;T&gt;读取TDouble类型数据&lt;/T&gt;\n//\n// @return 返回TDouble类型类型数据\n//============================================================\n\nTDouble TDataInput::ReadDouble(){\n   TDouble value;\n   _pInput-&gt;Read(&amp;value, sizeof(TDouble));\n   return value;\n}</Source>
                  </Method>
                  <Method name="ReadString" flag="override" description="读取字符串类型数据，先读长度，后读数据。">
                     <Parameters>
                        <Parameter type="TChar8*" name="pMemory"/>
                        <Parameter type="TSize" name="length" description="内存块的长度。"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;读取字符串类型数据，先读长度，后读数据。&lt;/T&gt;\n// \n// @param pBuffer 存放读取到的数据的内存块指针。\n// @param length 内存块的长度。\n//============================================================\n\nTInt TDataInput::ReadString(TChar8* pMemory, TSize length){\n   TUint32 readed;\n   _pInput-&gt;Read(&amp;readed, sizeof(TUint32));\n   if(readed &gt; 0){\n      MO_ASSERT(readed &lt;= length);\n      _pInput-&gt;Read(pMemory, sizeof(TChar8C) * readed);\n   }\n   return readed;\n}</Source>
                  </Method>
                  <Method name="ReadString" flag="override" description="读取字符串类型数据，先读长度，后读数据,宽字符版本。">
                     <Parameters>
                        <Parameter type="TChar16*" name="pMemory"/>
                        <Parameter type="TSize" name="length" description="内存块的长度。"/>
                     </Parameters>
                     <Return type="TInt"/>
                     <Source>//============================================================\n// &lt;T&gt;读取字符串类型数据，先读长度，后读数据,宽字符版本。&lt;/T&gt;\n// \n// @param pBuffer 存放读取到的数据的内存块指针。\n// @param length 内存块的长度。\n//============================================================\n\nTInt TDataInput::ReadString(TChar16* pMemory, TSize length){\n   TUint32 readed;\n   _pInput-&gt;Read(&amp;readed, sizeof(TUint32));\n   if(readed &gt; 0){\n      MO_ASSERT(readed &lt;= length);\n      _pInput-&gt;Read(pMemory, sizeof(TChar16C) * readed);\n   }\n   return readed;\n}</Source>
                  </Method>
                  <Method name="ReadString" flag="override">
                     <Return type="TString"/>
                     <Source>//============================================================\n\nTString TDataInput::ReadString(){\n   TUint32 readed;\n   _pInput-&gt;Read(&amp;readed, sizeof(TUint32));\n   TString value;\n   if(readed &gt; 0){\n      value.EnsureSize(readed);\n      _pInput-&gt;Read(value.Memory(), sizeof(TCharC) * readed);\n      value.SetLength(readed);\n   }\n   return value;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="IInput*" name="_pInput"/>
               </Attributes>
            </Class>
            <Class name="TDataOutput">
               <Inherits>
                  <Inherit name="IDataOutput" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TDataOutput" description="构造输出数据流的实例。"/>
                  <Constructor name="TDataOutput" description="构造输出数据流的实例。">
                     <Parameters>
                        <Parameter type="IOutput*" name="pOutput" description="输出接口"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TDataOutput" description="析构输出数据流的实例。"/>
                  <Method name="Output" description="获得输出接口。">
                     <Return type="IOutput*" description="输出接口"/>
                     <Source>//============================================================\n// &lt;T&gt;获得输出接口。&lt;/T&gt;\n//\n// @return 输出接口\n//============================================================\n\nIOutput* TDataOutput::Output(){\n   return _pOutput;\n}</Source>
                  </Method>
                  <Method name="SetOutput" description="设置输出接口。">
                     <Parameters>
                        <Parameter type="IOutput*" name="pOutput" description="输出接口"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置输出接口。&lt;/T&gt;\n//\n// @param pOutput 输出接口\n//============================================================\n\nvoid TDataOutput::SetOutput(IOutput* pOutput){\n   _pOutput = pOutput;\n}</Source>
                  </Method>
                  <Method name="Write" flag="override" description="写入数据">
                     <Parameters>
                        <Parameter type="TAnyC*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt" description="返回写入长度"/>
                     <Source>//============================================================\n// &lt;T&gt;写入数据&lt;/T&gt;\n//\n// @return 返回写入长度\n//============================================================\n\nTInt TDataOutput::Write(TAnyC* pData, TSize size){\n   return _pOutput-&gt;Write(pData, size);\n}</Source>
                  </Method>
                  <Method name="WriteBoolean" flag="override" description="写入Tbool类型数据">
                     <Parameters>
                        <Parameter type="TBool" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入Tbool类型数据&lt;/T&gt;\n//============================================================\n\nvoid TDataOutput::WriteBoolean(TBool value){\n   _pOutput-&gt;Write(&amp;value, sizeof(TBool));\n}</Source>
                  </Method>
                  <Method name="WriteInt" flag="override" description="写入TInt类型数据">
                     <Parameters>
                        <Parameter type="TInt" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TInt类型数据&lt;/T&gt;\n//============================================================\n\nvoid TDataOutput::WriteInt(TInt value){\n   _pOutput-&gt;Write(&amp;value, sizeof(TInt));\n}</Source>
                  </Method>
                  <Method name="WriteInt8" flag="override" description="写入TInt8类型数据">
                     <Parameters>
                        <Parameter type="TInt8" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TInt8类型数据&lt;/T&gt;\n//============================================================\n\nvoid TDataOutput::WriteInt8(TInt8 value){\n    _pOutput-&gt;Write(&amp;value, sizeof(TInt8));\n}</Source>
                  </Method>
                  <Method name="WriteInt16" flag="override" description="写入TInt16类型数据">
                     <Parameters>
                        <Parameter type="TInt16" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TInt16类型数据&lt;/T&gt;\n//============================================================\n\nvoid TDataOutput::WriteInt16(TInt16 value){\n   _pOutput-&gt;Write(&amp;value, sizeof(TInt16));\n}</Source>
                  </Method>
                  <Method name="WriteInt32" flag="override" description="写入TInt32类型数据">
                     <Parameters>
                        <Parameter type="TInt32" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TInt32类型数据&lt;/T&gt;\n//============================================================\n\nvoid TDataOutput::WriteInt32(TInt32 value){\n   _pOutput-&gt;Write(&amp;value, sizeof(TInt32));\n}</Source>
                  </Method>
                  <Method name="WriteInt64" flag="override" description="写入TInt64类型数据">
                     <Parameters>
                        <Parameter type="TInt64" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n//&lt;T&gt;写入TInt64类型数据&lt;/T&gt;\n//============================================================\n\nvoid TDataOutput::WriteInt64(TInt64 value){\n   _pOutput-&gt;Write(&amp;value, sizeof(TInt64));\n}</Source>
                  </Method>
                  <Method name="WriteUint" flag="override">
                     <Parameters>
                        <Parameter type="TUint" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TDataOutput::WriteUint(TUint value){\n   _pOutput-&gt;Write(&amp;value, sizeof(TUint));\n}</Source>
                  </Method>
                  <Method name="WriteUint8" flag="override">
                     <Parameters>
                        <Parameter type="TUint8" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TDataOutput::WriteUint8(TUint8 value){\n   _pOutput-&gt;Write(&amp;value, sizeof(TUint8));\n}</Source>
                  </Method>
                  <Method name="WriteUint16" flag="override">
                     <Parameters>
                        <Parameter type="TUint16" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TDataOutput::WriteUint16(TUint16 value){\n   _pOutput-&gt;Write(&amp;value, sizeof(TUint16));\n}</Source>
                  </Method>
                  <Method name="WriteUint32" flag="override">
                     <Parameters>
                        <Parameter type="TUint32" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TDataOutput::WriteUint32(TUint32 value){\n   _pOutput-&gt;Write(&amp;value, sizeof(TUint32));\n}</Source>
                  </Method>
                  <Method name="WriteUint64" flag="override">
                     <Parameters>
                        <Parameter type="TUint64" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TDataOutput::WriteUint64(TUint64 value){\n   _pOutput-&gt;Write(&amp;value, sizeof(TUint64));\n}</Source>
                  </Method>
                  <Method name="WriteFloat" flag="override" description="写入TFloat类型数据">
                     <Parameters>
                        <Parameter type="TFloat" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n//&lt;T&gt;写入TFloat类型数据&lt;/T&gt;\n//============================================================\n\nvoid TDataOutput::WriteFloat(TFloat value){\n   _pOutput-&gt;Write(&amp;value , sizeof(TFloat));\n}</Source>
                  </Method>
                  <Method name="WriteDouble" flag="override" description="写入TDouble类型数据">
                     <Parameters>
                        <Parameter type="TDouble" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入TDouble类型数据&lt;/T&gt;\n//============================================================\n\nvoid TDataOutput::WriteDouble(TDouble value){\n   _pOutput-&gt;Write(&amp;value, sizeof(TDouble));\n}</Source>
                  </Method>
                  <Method name="WriteString" flag="override" description="写入字符串类型数据，先写长度，后跟数据。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pMemory"/>
                        <Parameter type="TSize" name="length" description="写入数据长度"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入字符串类型数据，先写长度，后跟数据。&lt;/T&gt;\n//\n// @param pBuffer  写入数据的指针\n// @param length 写入数据长度\n//============================================================\n\nvoid TDataOutput::WriteString(TChar8C* pMemory, TSize length){\n   _pOutput-&gt;Write(&amp;length, sizeof(TUint32));\n   if(length &gt; 0){\n      _pOutput-&gt;Write(pMemory, sizeof(TChar8C) * length);\n   }\n}</Source>
                  </Method>
                  <Method name="WriteString" flag="override" description="写入字符串类型数据，先写长度，后跟数据,宽字符版本。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pMemory"/>
                        <Parameter type="TSize" name="length" description="写入数据长度"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;写入字符串类型数据，先写长度，后跟数据,宽字符版本。&lt;/T&gt;\n//\n// @param pBuffer  写入数据的指针\n// @param length 写入数据长度\n//============================================================\n\nvoid TDataOutput::WriteString(TChar16C* pMemory, TSize length){\n   _pOutput-&gt;Write(&amp;length, sizeof(TUint32));\n   if(length &gt; 0){\n      _pOutput-&gt;Write(pMemory, sizeof(TChar16C) * length);\n   }\n}</Source>
                  </Method>
                  <Method name="WriteString" flag="override">
                     <Parameters>
                        <Parameter type="MStringC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TDataOutput::WriteString(const MStringC&amp; value){\n   WriteString(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="IOutput*" name="_pOutput"/>
               </Attributes>
            </Class>
            <Class name="TDataReader">
               <Inherits>
                  <Inherit name="IDataReader" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TDataReader" description="构造输入数据流的实例。"/>
                  <Constructor name="TDataReader" description="构造输入数据流的实例。">
                     <Parameters>
                        <Parameter type="IReader*" name="pReader"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TDataReader" description="析构输入数据流的实例。"/>
                  <Method name="Reader" description="获得输入接口。">
                     <Return type="IReader*" description="输入接口"/>
                     <Source>//============================================================\n// &lt;T&gt;获得输入接口。&lt;/T&gt;\n//\n// @return 输入接口\n//============================================================\n\nIReader* TDataReader::Reader(){\n   return _pReader;\n}</Source>
                  </Method>
                  <Method name="SetReader" description="设置输入接口。">
                     <Parameters>
                        <Parameter type="IReader*" name="pReader"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置输入接口。&lt;/T&gt;\n//\n// @param pInput 输入接口\n//============================================================\n\nvoid TDataReader::SetReader(IReader* pReader){\n   _pReader = pReader;\n}</Source>
                  </Method>
                  <Method name="Read" flag="override" description="读取数据">
                     <Parameters>
                        <Parameter type="TChar*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt" description="返回读取长度"/>
                     <Source>//============================================================\n// &lt;T&gt;读取数据&lt;/T&gt;\n//\n// @return 返回读取长度\n//============================================================\n\nTInt TDataReader::Read(TChar* pData, TSize size){\n   return _pReader-&gt;Read(pData, size);\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="IReader*" name="_pReader"/>
               </Attributes>
            </Class>
            <Class name="TDataWriter">
               <Inherits>
                  <Inherit name="IDataWriter" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TDataWriter" description="构造输出数据流的实例。"/>
                  <Constructor name="TDataWriter" description="构造输出数据流的实例。">
                     <Parameters>
                        <Parameter type="IWriter*" name="pWriter" description="输出接口"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TDataWriter" description="析构输出数据流的实例。"/>
                  <Method name="Writer" description="获得输出接口。">
                     <Return type="IWriter*" description="输出接口"/>
                     <Source>//============================================================\n// &lt;T&gt;获得输出接口。&lt;/T&gt;\n//\n// @return 输出接口\n//============================================================\n\nIWriter* TDataWriter::Writer(){\n   return _pWriter;\n}</Source>
                  </Method>
                  <Method name="SetWriter" description="设置输出接口。">
                     <Parameters>
                        <Parameter type="IWriter*" name="pWriter" description="输出接口"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;设置输出接口。&lt;/T&gt;\n//\n// @param pWriter 输出接口\n//============================================================\n\nvoid TDataWriter::SetWriter(IWriter* pWriter){\n   _pWriter = pWriter;\n}</Source>
                  </Method>
                  <Method name="Write" flag="override" description="写入数据">
                     <Parameters>
                        <Parameter type="TCharC*" name="pData"/>
                        <Parameter type="TSize" name="size"/>
                     </Parameters>
                     <Return type="TInt" description="返回写入长度"/>
                     <Source>//============================================================\n// &lt;T&gt;写入数据&lt;/T&gt;\n//\n// @return 返回写入长度\n//============================================================\n\nTInt TDataWriter::Write(TCharC* pData, TSize size){\n   return _pWriter-&gt;Write(pData, size);\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="IWriter*" name="_pWriter"/>
               </Attributes>
            </Class>
            <Class name="TDictionary">
               <Inherits>
                  <Inherit name="MDictionary" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TDictionary" description="创建字典对象。"/>
                  <Constructor name="TDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="MDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="TDictionary&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TDictionary" description="创建字典对象。"/>
                  <Method name="operator=" description="接收另一个字典对象的全部数据。">
                     <Parameters>
                        <Parameter type="MDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MDictionaryC&lt;T&gt;&amp; dictionary){\n      this-&gt;Assign(dictionary);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="接收另一个字典对象的全部数据。">
                     <Parameters>
                        <Parameter type="TDictionary&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TDictionary&lt;T&gt;&amp; dictionary){\n      this-&gt;Assign(dictionary);\n   }</Source>
                  </Method>
                  <Method name="EntryCreate" type="inline" description="新建一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      EnsureSize(this-&gt;_count + 1);\n      return MO_CREATE(SEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryRelease" type="inline" description="释放一个指定的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRelease(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      MO_DELETE(pEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatCreate" type="inline" description="收集节点列表内存。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="SEntry**"/>
                     <Source>\ninline SEntry** EntryFlatCreate(TInt size){\n      return RTypeMemory&lt;SEntry*&gt;::Alloc(size, NULL);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatRelease" type="inline" description="释放节点列表内存。">
                     <Parameters>
                        <Parameter type="SEntry**" name="pEntries"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFlatRelease(SEntry** pEntries){\n      MO_ASSERT(pEntries);\n      RTypeMemory&lt;SEntry*&gt;::Free(pEntries);\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保当前对象可以容纳指定大小的数据。" note="当哈希表是旧表的8倍时开始扩充，扩大2倍。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if(NULL == this-&gt;_ppEntries) {\n         this-&gt;_entryCount = MO_MAX(size, MO_OBJECT_CAPACITY);\n         // 第一次新建时，生成哈希表\n         this-&gt;_ppEntries = EntryFlatCreate(this-&gt;_entryCount);\n      } else if (size &gt; (this-&gt;_entryCount &lt;&lt; 3)) {\n         // 扩充内存时处理\n         size = this-&gt;_entryCount + (MO_MAX(this-&gt;_entryCount, size) &gt;&gt; 1);\n         // 当总数大于节点列表长度8倍时，重新扩充节点列表\n         SEntry** ppEntries = EntryFlatCreate(size);\n         EntriesResize(ppEntries, size);\n         // 释放旧节点内存\n         EntryFlatRelease(this-&gt;_ppEntries);\n         // 保存新的节点列表\n         this-&gt;_ppEntries = ppEntries;\n         this-&gt;_entryCount = size;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TDictionaryIterator">
               <Inherits>
                  <Inherit name="TDictionaryIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TDictionaryIterator"/>
                  <Constructor name="TDictionaryIterator">
                     <Parameters>
                        <Parameter type="TDictionaryIteratorC&lt;T&gt;&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TDictionaryIterator">
                     <Parameters>
                        <Parameter type="SEntry**" name="ppEntries"/>
                        <Parameter type="entryCount)" name=":TDictionaryIteratorC&lt;T&gt;(ppEntries"/>
                        <Parameter type="ppEntries," name="entryCount"/>
                     </Parameters>
                  </Constructor>
                  <Method name="SetValue" type="inline">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void SetValue(T value) const{\n      MO_ASSERT(this-&gt;_pEntry);\n      this-&gt;_pEntry-&gt;value = value;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TDictionaryIteratorC">
               <Inherits>
                  <Inherit name="MEntryIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TDictionaryIteratorC" description="构造只读迭代器。"/>
                  <Constructor name="TDictionaryIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="TDictionaryIteratorC&lt;T&gt;&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TDictionaryIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                  </Constructor>
                  <Method name="*" type="inline" description="获得当前位置的数据内容。">
                     <Return type="operator"/>
                     <Source>\ninline const T&amp; operator *() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="operator-&gt;" type="inline" description="获得当前位置的数据内容。">
                     <Return type="T"/>
                     <Source>\ninline const T operator-&gt;() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="IsName">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool IsName(TCharC* pName){\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;IsName(pName);\n   }</Source>
                  </Method>
                  <Method name="IsValue">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool IsValue(T value){\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value == value;\n   }</Source>
                  </Method>
                  <Method name="Name" type="inline">
                     <Return type="TCharC*"/>
                     <Source>\ninline TCharC* Name() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;Name();\n   }</Source>
                  </Method>
                  <Method name="Value" type="inline">
                     <Return type="T"/>
                     <Source>\ninline T Value() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TEntryFlatStorage">
               <Inherits>
                  <Inherit name="TEntryStorage" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TEntryFlatStorage"/>
                  <Destructor name="~TEntryFlatStorage"/>
                  <Method name="Initialize">
                     <Return type="void"/>
                     <Source>\nvoid Initialize(){\n      TEntryStorage&lt;E&gt;::Initialize();\n      _pMemory = NULL;\n   }</Source>
                  </Method>
                  <Method name="Release">
                     <Return type="void"/>
                     <Source>\nvoid Release(){\n      TEntryStorage&lt;E&gt;::Release();\n      MO_MEM_FREE(_pMemory);\n   }</Source>
                  </Method>
                  <Method name="FlatAlloc">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="E**"/>
                     <Source>\nE** FlatAlloc(TInt size){\n      return RTypeMemory&lt;E*&gt;::Alloc(size, NULL);\n   }</Source>
                  </Method>
                  <Method name="FlatFree">
                     <Parameters>
                        <Parameter type="E**" name="pPtr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid FlatFree(E** pPtr){\n      MO_MEM_FREE(pPtr);\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="E**" name="_pMemory"/>
               </Attributes>
            </Class>
            <Class name="TEntryIteratorC">
               <Inherits>
                  <Inherit name="MEntryIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TEntryIteratorC"/>
                  <Constructor name="TEntryIteratorC">
                     <Parameters>
                        <Parameter type="TEntryIteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TEntryIteratorC">
                     <Parameters>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator==" type="inline">
                     <Parameters>
                        <Parameter type="TEntryIteratorC&amp;" name="iterator"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool operator==(const TEntryIteratorC&amp; iterator) const{\n      return this-&gt;_pEntry == iterator._pEntry;\n   }</Source>
                  </Method>
                  <Method name="operator!=" type="inline">
                     <Parameters>
                        <Parameter type="TEntryIteratorC&amp;" name="iterator"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool operator!=(const TEntryIteratorC&amp; iterator) const{\n      return this-&gt;_pEntry != iterator._pEntry;\n   }</Source>
                  </Method>
                  <Method name="*" type="inline">
                     <Return type="operator"/>
                     <Source>\ninline E&amp; operator *() const{\n      return this-&gt;_pEntry;\n   }</Source>
                  </Method>
                  <Method name="-&gt;" type="inline">
                     <Return type="operator"/>
                     <Source>\ninline E operator -&gt;() const{\n      return this-&gt;_pEntry;\n   }</Source>
                  </Method>
                  <Method name="Equals" type="inline">
                     <Parameters>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool Equals(E pEntry){\n      return this-&gt;_pEntry == pEntry;\n   }</Source>
                  </Method>
                  <Method name="Get" type="inline">
                     <Return type="E"/>
                     <Source>\ninline E Get(){\n      return this-&gt;_pEntry;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TEntryStorage">
               <Methods>
                  <Constructor name="TEntryStorage"/>
                  <Destructor name="~TEntryStorage"/>
                  <Method name="Initialize">
                     <Return type="void"/>
                     <Source>\nvoid Initialize(){\n      _pUnused = NULL;\n   }</Source>
                  </Method>
                  <Method name="Release">
                     <Return type="void"/>
                     <Source>\nvoid Release(){\n      while(NULL != _pUnused){\n         E* pEntry = _pUnused;\n         MO_MEM_DELETE(pEntry);\n         _pUnused = pEntry;\n      }\n   }</Source>
                  </Method>
                  <Method name="Alloc">
                     <Return type="E*"/>
                     <Source>\nE* Alloc(){\n      E* pEntry = NULL;\n      // 查看未使用节点中是否有自由节点\n      if(NULL != _pUnused){\n         // 收集未使用的节点\n         pEntry = _pUnused;\n         _pUnused = _pUnused-&gt;pNext;\n      }else{\n         // 收集新节点\n         pEntry = MO_MEM_CREATE(E);\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="Free">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Free(E* pEntry){\n      MO_ASSERT(pEntry);\n      pEntry-&gt;pNext = _pUnused;\n      _pUnused = pEntry;\n   }</Source>
                  </Method>
                  <Method name="Free">
                     <Parameters>
                        <Parameter type="E*" name="pFirst"/>
                        <Parameter type="E*" name="pLast"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Free(E* pFirst, E* pLast){\n      MO_ASSERT(pFirst);\n      MO_ASSERT(pLast);\n      pLast-&gt;pNext = _pUnused;\n      _pUnused = pFirst;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="E*" name="_pUnused"/>
               </Attributes>
            </Class>
            <Class name="TFileInfo">
               <Methods>
                  <Constructor name="TFileInfo"/>
                  <Constructor name="TFileInfo">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TFileInfo"/>
                  <Method name="InnerInitialize">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TFileInfo::InnerInitialize(){\n\n#ifdef _WINDOWS\n   _filename.Replace('\\', '/');\n#endif\n   // 取盘符\n   TInt driverEnd = _filename.IndexOf(':');\n   if(ENotFound != driverEnd){\n      _driver = _filename.LeftPtrC(driverEnd);\n   }\n   // 取路径和文件名\n   TInt nameStartIndex = _filename.LastIndexOf('/');\n   if(ENotFound == nameStartIndex){\n      _path.Assign(&quot;.&quot;);\n      _name = _filename;\n   }else{\n      _path = _filename.LeftPtrC(nameStartIndex);\n      _name = _filename.RightPtrC(_filename.Length() - nameStartIndex - 1);\n   }\n   // 取扩展名\n   TInt extensionStart = _name.LastIndexOf('.');\n   if(ENotFound != extensionStart){\n      _extension = _name.RightPtrC(_name.Length() - extensionStart - 1);\n   }\n}</Source>
                  </Method>
                  <Method name="FileName">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* TFileInfo::FileName(){\n   return _filename.MemoryC();\n}</Source>
                  </Method>
                  <Method name="SetFileName">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TFileInfo::SetFileName(TCharC* pFileName){\n   _filename.Assign(pFileName);\n   InnerInitialize();\n}</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFileName"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TFileInfo::operator=(TCharC* pFileName){\n   _filename.Assign(pFileName);\n   InnerInitialize();\n}</Source>
                  </Method>
                  <Method name="Driver">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* TFileInfo::Driver(){\n   return _driver.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Path">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* TFileInfo::Path(){\n   return _path.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Name">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* TFileInfo::Name(){\n   return _name.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Extension">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* TFileInfo::Extension(){\n   return _extension.MemoryC();\n}</Source>
                  </Method>
                  <Method name="Size">
                     <Return type="TUint"/>
                     <Source>//============================================================\n\nTUint TFileInfo::Size(){\n   return RFile::FileSize(_filename.MemoryC());\n}</Source>
                  </Method>
                  <Method name="LargeSize">
                     <Return type="TUint64"/>
                     <Source>//============================================================\n\nTUint64 TFileInfo::LargeSize(){\n   return (TUint64)RFile::FileSize(_filename.MemoryC());\n}</Source>
                  </Method>
                  <Method name="CreateDate">
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\nTDateTime TFileInfo::CreateDate(){\n   return 0;\n}</Source>
                  </Method>
                  <Method name="UpdateDate">
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\nTDateTime TFileInfo::UpdateDate(){\n   return 0;\n}</Source>
                  </Method>
                  <Method name="IsFile">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool TFileInfo::IsFile(){\n   return RFile::ExistFile(_filename.MemoryC());\n}</Source>
                  </Method>
                  <Method name="IsDirectory">
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool TFileInfo::IsDirectory(){\n   return RFile::ExistPath(_filename.MemoryC());\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TFsFileName" name="_filename"/>
                  <Attribute type="TFsName" name="_driver"/>
                  <Attribute type="TFsName" name="_extension"/>
                  <Attribute type="TFsPath" name="_path"/>
                  <Attribute type="TFsName" name="_name"/>
               </Attributes>
            </Class>
            <Class name="TFixArray">
               <Inherits>
                  <Inherit name="MArray" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFixArray" description="构造定长数组。"/>
                  <Constructor name="TFixArray" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixArray" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="MArrayC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixArray" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="TFixArray&lt;T, S&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Method name="InnerInitialize" type="inline" description="初始化内存。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      this-&gt;_pMemory = _memory;\n      this-&gt;_length = 0;\n      this-&gt;_size = S;\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" type="inline" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt capacity){\n      MO_ASSERT(capacity &lt;= S);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="设定当前数据和指定数据指针相等。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MPtrC&lt;T&gt;&amp; ptr){\n      Assign(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="设定当前数据和指定数据指针相等。">
                     <Parameters>
                        <Parameter type="TFixArray&lt;T, S&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TFixArray&lt;T, S&gt;&amp; values){\n      Assign(values.MemoryC(), values.Length());\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TFixEntryFlatStorage">
               <Inherits>
                  <Inherit name="TFixEntryStorage" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFixEntryFlatStorage"/>
                  <Method name="Initialize">
                     <Return type="void"/>
                     <Source>\nvoid Initialize(){\n      TFixEntryStorage&lt;E, C&gt;::Initialize();\n      RTypes&lt;E*&gt;::Clear(_pEntries, C);\n   }</Source>
                  </Method>
                  <Method name="FlatAlloc">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="E**"/>
                     <Source>\nE** FlatAlloc(TInt size){\n      MO_ASSERT(size &lt; C);\n      return _pEntries;\n   }</Source>
                  </Method>
                  <Method name="FlatFree">
                     <Parameters>
                        <Parameter type="E**" name="pPtr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid FlatFree(E** pPtr){\n      MO_MEM_FREE(pPtr);\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TFixEntryStorage">
               <Methods>
                  <Constructor name="TFixEntryStorage"/>
                  <Method name="Initialize">
                     <Return type="void"/>
                     <Source>\nvoid Initialize(){\n      _pUnused = NULL;\n      _alloc = 0;\n   }</Source>
                  </Method>
                  <Method name="Alloc">
                     <Return type="E*"/>
                     <Source>\nE* Alloc(){\n      E* pEntry = NULL;\n      // 查看未使用节点中是否有自由节点\n      if(NULL != _pUnused){\n         // 收集未使用的节点\n         pEntry = _pUnused;\n         _pUnused = _pUnused-&gt;pNext;\n      }else{\n         // 收集新节点\n         MO_ASSERT(_alloc &lt; C);\n         pEntry = &amp;_entries[_alloc++];\n      }\n      return pEntry;\n   }</Source>
                  </Method>
                  <Method name="Free">
                     <Parameters>
                        <Parameter type="E*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Free(E* pEntry){\n      MO_ASSERT(pEntry);\n      pEntry-&gt;pNext = _pUnused;\n      _pUnused = pEntry;\n   }</Source>
                  </Method>
                  <Method name="Free">
                     <Parameters>
                        <Parameter type="E*" name="pFirst"/>
                        <Parameter type="E*" name="pLast"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Free(E* pFirst, E* pLast){\n      MO_ASSERT(pFirst);\n      MO_ASSERT(pLast);\n      pLast-&gt;pNext = _pUnused;\n      _pUnused = pFirst;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="E*" name="_pUnused"/>
                  <Attribute type="TInt" name="_alloc"/>
               </Attributes>
            </Class>
            <Class name="TFixList">
               <Inherits>
                  <Inherit name="MList" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFixList" description="构造定长读写链表。"/>
                  <Constructor name="TFixList" description="构造定长读写链表。">
                     <Parameters>
                        <Parameter type="MListC&lt;T&gt;&amp;" name="list"/>
                     </Parameters>
                  </Constructor>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      MList&lt;TFixList&lt;T, S&gt;, T&gt;::InnerInitialize();\n      _alloc = 0;\n   }</Source>
                  </Method>
                  <Method name="EntryCreate" type="inline" description="新建一个节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      MO_ASSERT(_alloc &lt; S);\n      return &amp;_entries[_alloc++];\n   }</Source>
                  </Method>
                  <Method name="EntryRelease" type="inline" description="释放一个被使用的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRelease(SEntry* pEntry){\n   }</Source>
                  </Method>
                  <Method name="operator=" description="追加一个链表到当前链表中。">
                     <Parameters>
                        <Parameter type="MListC&lt;T&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MListC&lt;T&gt;&amp; list){\n      this-&gt;Assign(&amp;list);\n	}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_alloc"/>
               </Attributes>
            </Class>
            <Class name="TFixMap">
               <Inherits>
                  <Inherit name="MMap" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFixMap"/>
                  <Constructor name="TFixMap">
                     <Parameters>
                        <Parameter type="MMapC&lt;N, V&gt;&amp;" name="map"/>
                     </Parameters>
                  </Constructor>
                  <Method name="Initialize" description="初始化。">
                     <Return type="void"/>
                     <Source>\nvoid Initialize(){\n      this-&gt;InnerInitialize(S);\n   }</Source>
                  </Method>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      MMap&lt;TFixMap&lt;N ,V, S&gt;, N, V&gt;::InnerInitialize(size);\n      this-&gt;_alloc = 0;\n   }</Source>
                  </Method>
                  <Method name="EntryCreate" type="inline" description="新建一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      MO_ASSERT(this-&gt;_alloc &lt; S);\n      return &amp;this-&gt;_entries[this-&gt;_alloc++];\n   }</Source>
                  </Method>
                  <Method name="EntryRelease" type="inline" description="释放一个指定的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRelease(SEntry* pEntry){\n   }</Source>
                  </Method>
                  <Method name="EntryFlatCreate" type="inline" description="收集节点列表内存。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="SEntry**"/>
                     <Source>\ninline SEntry** EntryFlatCreate(TInt size){\n      MO_ASSERT(size &lt;= S);\n      return this-&gt;_pEntries;\n   }</Source>
                  </Method>
                  <Method name="EntryFlatRelease" type="inline" description="释放节点列表内存。">
                     <Parameters>
                        <Parameter type="SEntry**" name="pEntries"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFlatRelease(SEntry** pEntries){\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" type="inline" description="确保当前对象可以容纳指定大小的数据。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt size){\n      MO_ASSERT(size &lt;= S);\n      if(NULL == this-&gt;_pMemory){\n         this-&gt;_entryCount = S;\n         this-&gt;_ppEntries = _entries;\n      }\n   }</Source>
                  </Method>
                  <Method name="operator=" description="复制一个哈希表到当前哈希表中。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="map"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MSetC&lt;N, V&gt;&amp; map){\n		Assign(&amp;map);\n	}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_alloc"/>
               </Attributes>
            </Class>
            <Class name="TFixPtrArray">
               <Inherits>
                  <Inherit name="MArray" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFixPtrArray" description="构造定长数组。"/>
                  <Constructor name="TFixPtrArray" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixPtrArray" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="MArrayC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixPtrArray" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="TFixArray&lt;T, S&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Method name="InnerInitialize" type="inline" description="初始化内存。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      this-&gt;_pMemory = _memory;\n      this-&gt;_length = 0;\n      this-&gt;_size = S;\n      // 关联指针\n      for(TInt n=0; n&lt;S; n++){\n         _pPtrs[n] = &amp;_memory[n];\n      }\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" type="inline" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt capacity){\n      MO_ASSERT(capacity &lt;= S);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="设定当前数据和指定数据指针相等。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MPtrC&lt;T&gt;&amp; ptr){\n      Assign(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="设定当前数据和指定数据指针相等。">
                     <Parameters>
                        <Parameter type="TFixPtrArray&lt;T, S&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TFixPtrArray&lt;T, S&gt;&amp; values){\n      Assign(values.MemoryC(), values.Length());\n   }</Source>
                  </Method>
                  <Method name="Ptrs" description="设定当前数据和指定数据指针相等。">
                     <Return type="T**"/>
                     <Source>\nT** Ptrs(){\n      return _pPtrs;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TFixPtrVector">
               <Inherits>
                  <Inherit name="MVector" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFixPtrVector" description="构造定长数组。"/>
                  <Constructor name="TFixPtrVector" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixPtrVector" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="MArrayC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixPtrVector" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="TFixArray&lt;T, S&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Method name="InnerInitialize" type="inline" description="初始化内存。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      this-&gt;_pMemory = _memory;\n      this-&gt;_count = 0;\n      this-&gt;_size = S;\n      // 关联指针\n      for(TInt n=0; n&lt;S; n++){\n         _pPtrs[n] = &amp;_memory[n];\n      }\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" type="inline" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt capacity){\n      MO_ASSERT(capacity &lt;= S);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="设定当前数据和指定数据指针相等。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MPtrC&lt;T&gt;&amp; ptr){\n      Assign(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="设定当前数据和指定数据指针相等。">
                     <Parameters>
                        <Parameter type="TFixPtrVector&lt;T, S&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TFixPtrVector&lt;T, S&gt;&amp; values){\n      Assign(values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="Ptrs" description="设定当前数据和指定数据指针相等。">
                     <Return type="T**"/>
                     <Source>\nT** Ptrs(){\n      return _pPtrs;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TFixSet">
               <Inherits>
                  <Inherit name="MSet" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFixSet"/>
                  <Constructor name="TFixSet">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="set"/>
                     </Parameters>
                  </Constructor>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      MSet&lt;TFixSet&lt;N ,V, S&gt;, N, V&gt;::InnerInitialize();\n      this-&gt;_entryCount = S;\n      this-&gt;_ppEntries = _memoryEntries;\n      this-&gt;_alloc = 0;\n   }</Source>
                  </Method>
                  <Method name="EntryCreate" type="inline" description="新建一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      MO_ASSERT(_alloc &lt; S);\n      return &amp;_allocEntries[_alloc++];\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" type="inline" description="确保当前对象可以容纳指定大小的数据。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt size){\n      MO_ASSERT(size &lt;= S);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="复制一个集合到当前集合中。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="set"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MSetC&lt;N, V&gt;&amp; set){\n		Assign(&amp;set);\n	}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_alloc"/>
               </Attributes>
            </Class>
            <Class name="TFixString16">
               <Inherits>
                  <Inherit name="MString16" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFixString16" description="构造一个定长字符串类。"/>
                  <Constructor name="TFixString16" description="构造一个定长字符串类。">
                     <Parameters>
                        <Parameter type="TFixString16&lt;S&gt;&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixString16" description="构造一个定长字符串类。">
                     <Parameters>
                        <Parameter type="TInt" name="length" default="-1"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixString16" description="构造一个定长字符串类。">
                     <Parameters>
                        <Parameter type="MString16PtrC&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Method name="InnerInitialize" type="inline" description="初始化一个定长字符串。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      // 设置内容\n      this-&gt;_pMemory = _memory;\n      this-&gt;_length = 0;\n      this-&gt;_size = S;\n      // 首次为空字符串。\n      _memory[0] = 0;\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" type="inline" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt size){\n      MO_ASSERT(size &lt;= S);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定字符串的内容。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(TChar16C* pValue){\n      this-&gt;Assign(pValue);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定字符串对象的内容。">
                     <Parameters>
                        <Parameter type="MString16PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString16PtrC&amp; value){\n      this-&gt;Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定字符串对象的内容。">
                     <Parameters>
                        <Parameter type="TFixString16&lt;S&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TFixString16&lt;S&gt;&amp; value){\n      this-&gt;Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="Size" type="static" description="获得容纳长度。">
                     <Return type="TInt"/>
                     <Source>\nstatic TInt Size(){\n      return S;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TFixString32">
               <Inherits>
                  <Inherit name="MString32" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFixString32" description="构造一个定长字符串类。"/>
                  <Constructor name="TFixString32" description="构造一个定长字符串类。">
                     <Parameters>
                        <Parameter type="TFixString32&lt;S&gt;&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixString32" description="构造一个定长字符串类。">
                     <Parameters>
                        <Parameter type="TInt" name="length" default="-1"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixString32" description="构造一个定长字符串类。">
                     <Parameters>
                        <Parameter type="MString32PtrC&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Method name="InnerInitialize" type="inline" description="初始化一个定长字符串。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      // 设置内容\n      this-&gt;_pMemory = _memory;\n      this-&gt;_length = 0;\n      this-&gt;_size = S;\n      // 首次为空字符串。\n      _memory[0] = 0;\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" type="inline" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt size){\n      MO_ASSERT(size &lt;= S);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定字符串的内容。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(TChar32C* pValue){\n      this-&gt;Assign(pValue);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定字符串对象的内容。">
                     <Parameters>
                        <Parameter type="MString32PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString32PtrC&amp; value){\n      this-&gt;Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定字符串对象的内容。">
                     <Parameters>
                        <Parameter type="TFixString32&lt;S&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TFixString32&lt;S&gt;&amp; value){\n      this-&gt;Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="Size" type="static" description="获得容纳长度。">
                     <Return type="TInt"/>
                     <Source>\nstatic TInt Size(){\n      return S;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TFixString8">
               <Inherits>
                  <Inherit name="MString8" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFixString8" description="构造一个定长字符串类。"/>
                  <Constructor name="TFixString8" description="构造一个定长字符串类。">
                     <Parameters>
                        <Parameter type="TFixString8&lt;S&gt;&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixString8" description="构造一个定长字符串类。">
                     <Parameters>
                        <Parameter type="TInt" name="length" default="-1"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixString8" description="构造一个定长字符串类。">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Method name="InnerInitialize" type="inline" description="初始化一个定长字符串。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      // 设置内容\n      this-&gt;_pMemory = _memory;\n      this-&gt;_length = 0;\n      this-&gt;_size = S;\n      // 首次为空字符串。\n      _memory[0] = 0;\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" type="inline" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt size){\n      MO_ASSERT(size &lt;= S);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定字符串的内容。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(TChar8C* pValue){\n      this-&gt;Assign(pValue);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定字符串对象的内容。">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString8PtrC&amp; value){\n      this-&gt;Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定字符串对象的内容。">
                     <Parameters>
                        <Parameter type="TFixString8&lt;S&gt;&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TFixString8&lt;S&gt;&amp; value){\n      this-&gt;Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="Size" type="static" description="获得容纳长度。">
                     <Return type="TInt"/>
                     <Source>\nstatic TInt Size(){\n      return S;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TFixVector">
               <Inherits>
                  <Inherit name="MVector" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFixVector" description="构造定长数组。"/>
                  <Constructor name="TFixVector" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixVector" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFixVector" description="构造定长数组。">
                     <Parameters>
                        <Parameter type="TFixVector&lt;T, S&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Method name="InnerInitialize" type="inline" description="初始化内存。">
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(){\n      this-&gt;_pMemory = _memory;\n      this-&gt;_count = 0;\n      this-&gt;_size = S;\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" type="inline" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt capacity){\n      MO_ASSERT(capacity &lt;= S);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="设定当前数据和指定数据指针相等。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MPtrC&lt;T&gt;&amp; ptr){\n      Assign(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="设定当前数据和指定数据指针相等。">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MVectorC&lt;T&gt;&amp; values){\n      Assign(values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="设定当前数据和指定数据指针相等。">
                     <Parameters>
                        <Parameter type="TFixVector&lt;T, S&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TFixVector&lt;T, S&gt;&amp; values){\n      Assign(values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TFsDateTime">
               <Inherits>
                  <Inherit name="TFixString" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TFsDateTime"/>
                  <Constructor name="TFsDateTime">
                     <Parameters>
                        <Parameter type="TDateTime" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFsDateTime">
                     <Parameters>
                        <Parameter type="TFsDateTime&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFsDateTime">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                        <Parameter type="length)" name=":TFixString&lt;MO_FS_DATETIME_LENGTH&gt;(pValue"/>
                        <Parameter type="pValue," name="length"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TFsDateTime">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TDateTime" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TFsDateTime::operator=(TDateTime value){\n   _value = value;\n}</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TFsDateTime::operator=(TCharC* pValue){\n   this-&gt;Assign(pValue);\n}</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TFsDateTime&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TFsDateTime::operator=(const TFsDateTime&amp; value){\n   this-&gt;Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="MStringPtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TFsDateTime::operator=(const MStringPtrC&amp; value){\n   this-&gt;Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="Value">
                     <Return type="TDateTime"/>
                     <Source>//============================================================\n\nTDateTime TFsDateTime::Value(){\n   return _value;\n}</Source>
                  </Method>
                  <Method name="SetValue">
                     <Parameters>
                        <Parameter type="TDateTime" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TFsDateTime::SetValue(TDateTime value){\n   _value = value;\n}</Source>
                  </Method>
                  <Method name="Foramt">
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* TFsDateTime::Foramt(){\n   return RDateTime::ToString(_pMemory, MO_FS_DATETIME_LENGTH, _value, RDateTime::DefaultFormat);\n}</Source>
                  </Method>
                  <Method name="Foramt">
                     <Parameters>
                        <Parameter type="TCharC*" name="pFormat"/>
                     </Parameters>
                     <Return type="TCharC*"/>
                     <Source>//============================================================\n\nTCharC* TFsDateTime::Foramt(TCharC* pFormat){\n   return RDateTime::ToString(_pMemory, MO_FS_DATETIME_LENGTH, _value, pFormat);\n}</Source>
                  </Method>
                  <Method name="Parse">
                     <Parameters>
                        <Parameter type="TCharC*" name="pValue"/>
                        <Parameter type="TCharC*" name="pFormat"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n\nTBool TFsDateTime::Parse(TCharC* pValue, TCharC* pFormat){\n   _value = RDateTime::Parse(pValue, pFormat);\n   return ETrue;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TDateTime" name="_value"/>
               </Attributes>
            </Class>
            <Class name="TIntrusivePtr"/>
            <Class name="TLinkedIteratorC">
               <Inherits>
                  <Inherit name="MLinkedIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TLinkedIteratorC"/>
                  <Constructor name="TLinkedIteratorC">
                     <Parameters>
                        <Parameter type="MLinkedIteratorC&lt;E&gt;&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TLinkedIteratorC">
                     <Parameters>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator==" type="inline">
                     <Parameters>
                        <Parameter type="MLinkedIteratorC&lt;E&gt;&amp;" name="iterator"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool operator==(const MLinkedIteratorC&lt;E&gt;&amp; iterator) const{\n      return this-&gt;_pEntry == iterator._pEntry;\n   }</Source>
                  </Method>
                  <Method name="operator!=" type="inline">
                     <Parameters>
                        <Parameter type="MLinkedIteratorC&lt;E&gt;&amp;" name="iterator"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool operator!=(const MLinkedIteratorC&lt;E&gt;&amp; iterator) const{\n      return this-&gt;_pEntry != iterator._pEntry;\n   }</Source>
                  </Method>
                  <Method name="E" type="inline">
                     <Return type="const"/>
                     <Source>\ninline operator const E() const{\n      return this-&gt;_pEntry;\n   }</Source>
                  </Method>
                  <Method name="Equals" type="inline">
                     <Parameters>
                        <Parameter type="E" name="pEntry"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool Equals(E pEntry){\n      return this-&gt;_pEntry == pEntry;\n   }</Source>
                  </Method>
                  <Method name="Get" type="inline">
                     <Return type="E"/>
                     <Source>\ninline E Get(){\n      return this-&gt;_pEntry;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TList">
               <Inherits>
                  <Inherit name="MList" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TList" description="构造变长读写链表。"/>
                  <Constructor name="TList" description="构造变长读写链表。">
                     <Parameters>
                        <Parameter type="TList&lt;T&gt;&amp;" name="list"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TList" description="析构变长读写链表。"/>
                  <Method name="EntryCreate" type="inline" description="新建一个节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      return MO_MEM_CREATE(SEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryRelease" type="inline" description="释放一个被使用的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRelease(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      MO_MEM_DELETE(pEntry);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="追加一个链表到当前链表中。">
                     <Parameters>
                        <Parameter type="TList&lt;T&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TList&lt;T&gt;&amp; list){\n      this-&gt;Assign(&amp;list);\n	}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TListIndexIteratorC">
               <Inherits>
                  <Inherit name="TListIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TListIndexIteratorC" description="构造只读计数迭代器。"/>
                  <Constructor name="TListIndexIteratorC" description="构造只读计数迭代器。">
                     <Parameters>
                        <Parameter type="TListIteratorC&lt;T&gt;&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TListIndexIteratorC" description="构造只读计数迭代器。">
                     <Parameters>
                        <Parameter type="TListIndexIteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TListIndexIteratorC" description="构造只读计数迭代器。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                  </Constructor>
                  <Method name="Index" type="inline" description="获得计数器。">
                     <Return type="TInt"/>
                     <Source>\ninline TInt Index(){\n      return _index++;\n   }</Source>
                  </Method>
                  <Method name="Next" type="inline" description="移动到下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Next(){\n      this-&gt;_pEntry = (NULL == this-&gt;_pEntry) ? this-&gt;_pStart : this-&gt;_pEntry-&gt;pNext;\n      if(NULL != this-&gt;_pEntry){\n         _index++;\n         return ETrue;\n      }\n      return EFalse;\n   }</Source>
                  </Method>
                  <Method name="Prior" type="inline" description="移动到上一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Prior(){\n      this-&gt;_pEntry = (NULL == this-&gt;_pEntry) ? this-&gt;_pStart : this-&gt;_pEntry-&gt;pPrior;\n      if(NULL != this-&gt;_pEntry){\n         _index--;\n         return ETrue;\n      }\n      return EFalse;\n   }</Source>
                  </Method>
                  <Method name="Reset" type="inline" description="重置位置。">
                     <Return type="void"/>
                     <Source>\ninline void Reset(){\n      _index = -1;\n      this-&gt;_pEntry = NULL;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_index"/>
               </Attributes>
            </Class>
            <Class name="TListIterator">
               <Inherits>
                  <Inherit name="TListIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TListIterator" description="构造链表迭代器。"/>
                  <Constructor name="TListIterator" description="构造链表迭代器。">
                     <Parameters>
                        <Parameter type="TListIteratorC&lt;T&gt;&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TListIterator" description="构造链表迭代器。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                  </Constructor>
                  <Method name="Set" type="inline" description="设置当前位置的数据名称。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void Set(T value) const{\n      MO_ASSERT(this-&gt;_pEntry);\n      this-&gt;_pEntry-&gt;value = value;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TListIteratorC">
               <Inherits>
                  <Inherit name="MEntryIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TListIteratorC" description="构造只读迭代器。"/>
                  <Constructor name="TListIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="TListIteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TListIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                  </Constructor>
                  <Method name="*" type="inline" description="获得当前位置的数据内容。">
                     <Return type="operator"/>
                     <Source>\ninline const T&amp; operator *() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="operator-&gt;" type="inline" description="获得当前位置的数据内容。">
                     <Return type="T"/>
                     <Source>\ninline const T operator-&gt;() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="Equals" type="inline" description="判断数据内容是否相等。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool Equals(T value){\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value == value;\n   }</Source>
                  </Method>
                  <Method name="Get" type="inline" description="获得当前位置的数据内容。">
                     <Return type="T"/>
                     <Source>\ninline T Get(){\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TMap">
               <Inherits>
                  <Inherit name="MMap" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TMap" description="创建哈希表对象。"/>
                  <Constructor name="TMap" description="创建哈希表对象。">
                     <Parameters>
                        <Parameter type="MMapC&lt;N, V&gt;&amp;" name="map"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TMap" description="创建哈希表对象。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TMap" description="析构哈希表对象。"/>
                  <Method name="EntryCreate" type="inline" description="新建一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      EnsureSize(this-&gt;_count + 1);\n      return MO_MEM_CREATE(SEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryRelease" type="inline" description="释放一个指定的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRelease(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      MO_MEM_DELETE(pEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatCreate" type="inline" description="收集节点列表内存。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="SEntry**"/>
                     <Source>\ninline SEntry** EntryFlatCreate(TInt size){\n      return RTypeMemory&lt;SEntry*&gt;::Alloc(size, NULL);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatRelease" type="inline" description="释放节点列表内存。">
                     <Parameters>
                        <Parameter type="SEntry**" name="pEntries"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFlatRelease(SEntry** pEntries){\n      MO_ASSERT(pEntries);\n      RTypeMemory&lt;SEntry*&gt;::Free(pEntries);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="复制内容到对象内部。">
                     <Parameters>
                        <Parameter type="MMapC&lt;N, V&gt;&amp;" name="map"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MMapC&lt;N, V&gt;&amp; map){\n      this-&gt;Assign(&amp;map);\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保当前对象可以容纳指定大小的数据。" note="当哈希表是旧表的8倍时开始扩充，扩大2倍。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if(NULL == this-&gt;_ppEntries) {\n         this-&gt;_entryCount = MO_MAX(size, MO_OBJECT_CAPACITY);\n         // 第一次新建时，生成哈希表\n         this-&gt;_ppEntries = EntryFlatCreate(this-&gt;_entryCount);\n      } else if (size &gt; (this-&gt;_entryCount &lt;&lt; 3)) {\n         // 扩充内存时处理\n         size = this-&gt;_entryCount + (MO_MAX(this-&gt;_entryCount, size) &gt;&gt; 1);\n         // 当总数大于节点列表长度8倍时，重新扩充节点列表\n         SEntry** ppEntries = EntryFlatCreate(size);\n         EntriesResize(ppEntries, size);\n         // 释放旧节点内存\n         EntryFlatRelease(this-&gt;_ppEntries);\n         // 保存新的节点列表\n         this-&gt;_ppEntries = ppEntries;\n         this-&gt;_entryCount = size;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TMapIterator">
               <Inherits>
                  <Inherit name="TMapIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TMapIterator" description="构造可写迭代器。"/>
                  <Constructor name="TMapIterator" description="构造可写迭代器。"/>
                  <Constructor name="TMapIterator" description="构造可写迭代器。"/>
                  <Method name="SetValue" type="inline" description="设置当前位置的数据内容。">
                     <Parameters>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void SetValue(V value){\n      MO_ASSERT(this-&gt;_pEntry);\n      this-&gt;_pEntry-&gt;value = value;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TMapIteratorC">
               <Inherits>
                  <Inherit name="MEntryIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TMapIteratorC" description="构造只读迭代器。"/>
                  <Constructor name="TMapIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="TMapIteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TMapIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                  </Constructor>
                  <Method name="*" type="inline" description="获得当前位置的数据内容。">
                     <Return type="operator"/>
                     <Source>\ninline const V&amp; operator *() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="operator-&gt;" type="inline" description="获得当前位置的数据内容。">
                     <Return type="V*"/>
                     <Source>\ninline const V* operator-&gt;() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return &amp;(this-&gt;_pEntry-&gt;value);\n   }</Source>
                  </Method>
                  <Method name="IsName" type="inline" description="判断名称是否相同。">
                     <Parameters>
                        <Parameter type="N" name="name"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsName(N name) const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return (name == this-&gt;_pEntry-&gt;name);\n   }</Source>
                  </Method>
                  <Method name="IsValue" type="inline" description="判断内容是否相同。">
                     <Parameters>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsValue(V value) const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return (value == this-&gt;_pEntry-&gt;value);\n   }</Source>
                  </Method>
                  <Method name="Name" type="inline" description="获得当前位置的数据名称。">
                     <Return type="N"/>
                     <Source>\ninline N Name() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;name;\n   }</Source>
                  </Method>
                  <Method name="Value" type="inline" description="获得当前位置的数据内容。">
                     <Return type="V"/>
                     <Source>\ninline V Value() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TNcAttributes">
               <Inherits>
                  <Inherit name="MNcAttributes" scope="public"/>
               </Inherits>
            </Class>
            <Class name="TNcDictionary">
               <Inherits>
                  <Inherit name="MNcDictionary" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TNcDictionary" description="创建字典对象。"/>
                  <Constructor name="TNcDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TNcDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="MNcDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TNcDictionary" description="创建字典对象。">
                     <Parameters>
                        <Parameter type="TNcDictionary&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TNcDictionary" description="创建字典对象。"/>
                  <Method name="operator=" description="接收另一个字典对象的全部数据。">
                     <Parameters>
                        <Parameter type="MNcDictionaryC&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MNcDictionaryC&lt;T&gt;&amp; dictionary){\n      this-&gt;Assign(dictionary);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="接收另一个字典对象的全部数据。">
                     <Parameters>
                        <Parameter type="TNcDictionary&lt;T&gt;&amp;" name="dictionary"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TNcDictionary&lt;T&gt;&amp; dictionary){\n      this-&gt;Assign(dictionary);\n   }</Source>
                  </Method>
                  <Method name="EntryCreate" type="inline" description="新建一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      EnsureSize(this-&gt;_count + 1);\n      return MO_CREATE(SEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryRelease" type="inline" description="释放一个指定的节点。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryRelease(SEntry* pEntry){\n      MO_ASSERT(pEntry);\n      MO_DELETE(pEntry);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatCreate" type="inline" description="收集节点列表内存。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="SEntry**"/>
                     <Source>\ninline SEntry** EntryFlatCreate(TInt size){\n      return RTypeMemory&lt;SEntry*&gt;::Alloc(size, NULL);\n   }</Source>
                  </Method>
                  <Method name="EntryFlatRelease" type="inline" description="释放节点列表内存。">
                     <Parameters>
                        <Parameter type="SEntry**" name="pEntries"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EntryFlatRelease(SEntry** pEntries){\n      MO_ASSERT(pEntries);\n      RTypeMemory&lt;SEntry*&gt;::Free(pEntries);\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保当前对象可以容纳指定大小的数据。" note="当哈希表是旧表的8倍时开始扩充，扩大2倍。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if(NULL == this-&gt;_ppEntries) {\n         this-&gt;_entryCount = MO_MAX(size, MO_OBJECT_CAPACITY);\n         // 第一次新建时，生成哈希表\n         this-&gt;_ppEntries = EntryFlatCreate(this-&gt;_entryCount);\n      } else if (size &gt; (this-&gt;_entryCount &lt;&lt; 3)) {\n         // 扩充内存时处理\n         size = this-&gt;_entryCount + (MO_MAX(this-&gt;_entryCount, size) &gt;&gt; 1);\n         // 当总数大于节点列表长度8倍时，重新扩充节点列表\n         SEntry** ppEntries = EntryFlatCreate(size);\n         EntriesResize(ppEntries, size);\n         // 释放旧节点内存\n         EntryFlatRelease(this-&gt;_ppEntries);\n         // 保存新的节点列表\n         this-&gt;_ppEntries = ppEntries;\n         this-&gt;_entryCount = size;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TProperties16">
               <Inherits>
                  <Inherit name="MProperties16" scope="public"/>
               </Inherits>
            </Class>
            <Class name="TProperties32">
               <Inherits>
                  <Inherit name="MProperties32" scope="public"/>
               </Inherits>
            </Class>
            <Class name="TProperties8">
               <Inherits>
                  <Inherit name="MProperties8" scope="public"/>
               </Inherits>
            </Class>
            <Class name="TPtr">
               <Inherits>
                  <Inherit name="TPtrC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TPtr" description="构造指针对象。"/>
                  <Constructor name="TPtr" description="构造指针对象。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TPtr" description="构造指针对象。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TPtr" description="构造指针对象。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TPtr" description="构造指针对象。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TPtr" description="构造指针对象。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Method name="Memory" description="获得数据指针。">
                     <Return type="T*"/>
                     <Source>\nT* Memory() const{\n      return this-&gt;_pMemory;\n   }</Source>
                  </Method>
                  <Method name="operator=" description="重载指针复制操作。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MPtrC&lt;T&gt;&amp; ptr) {\n      Set(ptr);\n   }</Source>
                  </Method>
                  <Method name="Set" description="设置指针内容。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(const T* pMemory, TInt length){\n      this-&gt;_pMemory = MO_CAST_CONST(pMemory, T*);\n      this-&gt;_length = length;\n      this-&gt;_size = length;\n   }</Source>
                  </Method>
                  <Method name="Set" description="设置指针内容。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(const T* pMemory, TInt length, TInt size){\n      this-&gt;_pMemory = MO_CAST_CONST(pMemory, T*);\n      this-&gt;_length = length;\n      this-&gt;_size = size;\n   }</Source>
                  </Method>
                  <Method name="Set" description="设置指针内容。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Set(const MPtrC&lt;T&gt;&amp; ptr){\n      this-&gt;_pMemory = MO_CAST_CONST(ptr.MemoryC(), T*);\n      this-&gt;_length = ptr.Length();\n      this-&gt;_size = ptr.Size();\n   }</Source>
                  </Method>
                  <Method name="Clear" description="清除指针内容。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      this-&gt;_pMemory = NULL;\n      this-&gt;_length = 0;\n      this-&gt;_size = 0;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TPtrC">
               <Inherits>
                  <Inherit name="MPtrC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TPtrC" description="构造只读指针对象。"/>
                  <Constructor name="TPtrC" description="构造只读指针对象。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TPtrC" description="构造只读指针对象。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TPtrC" description="构造只读指针对象。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator=" description="重载指针复制操作。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MPtrC&lt;T&gt;&amp; ptr){\n      InnerInitialize(ptr.MemoryC(), ptr.Length(), ptr.Size());\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TSet">
               <Inherits>
                  <Inherit name="MSet" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TSet" description="构造哈希集合对象。"/>
                  <Constructor name="TSet" description="构造哈希集合对象。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="set"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TSet" description="构造哈希集合对象。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TSet" description="析构哈希集合对象。"/>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      MSet&lt;TSet&lt;N, V&gt;, N, V&gt;::InnerInitialize();\n      // 第一次新建时，生成哈希表\n      this-&gt;_entryCount = MO_MAX(size, MO_OBJECT_CAPACITY);\n      this-&gt;_ppEntries = RTypeMemory&lt;SEntry*&gt;::Alloc(this-&gt;_entryCount, NULL);\n      this-&gt;_pUnused = NULL;\n   }</Source>
                  </Method>
                  <Method name="EntryCreate" type="inline" description="新建一个未使用的节点。">
                     <Return type="SEntry*"/>
                     <Source>\ninline SEntry* EntryCreate(){\n      EnsureSize(this-&gt;_count + 1);\n      return MO_MEM_CREATE(SEntry);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="复制内容到对象内部。">
                     <Parameters>
                        <Parameter type="MSetC&lt;N, V&gt;&amp;" name="set"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MSetC&lt;N, V&gt;&amp; set){\n      this-&gt;Assign(&amp;set);\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保当前对象可以容纳指定大小的数据。" note="当哈希表是旧表的8倍时开始扩充，扩大2倍。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if (size &gt; (this-&gt;_entryCount &lt;&lt; 3)) {\n         // 扩充内存时处理\n         size = this-&gt;_entryCount + (MO_MAX(this-&gt;_entryCount, size) &gt;&gt; 1);\n         // 当总数大于节点列表长度8倍时，重新扩充节点列表\n         SEntry** ppEntries = RTypeMemory&lt;SEntry*&gt;::Alloc(size, NULL);\n         EntriesResize(ppEntries, size);\n         // 释放旧节点内存\n         RTypeMemory&lt;SEntry*&gt;::Free(this-&gt;_ppEntries);\n         // 保存新的节点列表\n         this-&gt;_ppEntries = ppEntries;\n         this-&gt;_entryCount = size;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TSetIterator">
               <Inherits>
                  <Inherit name="TSetIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TSetIterator" description="构造可写迭代器。"/>
                  <Constructor name="TSetIterator" description="构造可写迭代器。"/>
                  <Constructor name="TSetIterator" description="构造可写迭代器。"/>
                  <Method name="SetValue" type="inline" description="设置当前位置的数据内容。">
                     <Parameters>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void SetValue(V value) const{\n      MO_ASSERT(this-&gt;_pEntry);\n      this-&gt;_pEntry-&gt;value = value;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TSetIteratorC">
               <Inherits>
                  <Inherit name="MEntryIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TSetIteratorC" description="构造只读迭代器。"/>
                  <Constructor name="TSetIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="TSetIteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TSetIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                  </Constructor>
                  <Method name="*" type="inline" description="获得当前位置的数据内容。">
                     <Return type="operator"/>
                     <Source>\ninline const V&amp; operator *() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="operator-&gt;" type="inline" description="获得当前位置的数据内容。">
                     <Return type="V"/>
                     <Source>\ninline const V operator-&gt;() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="IsCode" type="inline" description="判断代码是否相同。">
                     <Parameters>
                        <Parameter type="N" name="code"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsCode(N code) const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return (code == this-&gt;_pEntry-&gt;code);\n   }</Source>
                  </Method>
                  <Method name="IsValue" type="inline" description="判断内容是否相同。">
                     <Parameters>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsValue(V value) const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return (value == this-&gt;_pEntry-&gt;value);\n   }</Source>
                  </Method>
                  <Method name="Code" type="inline" description="获得当前位置的数据名称。">
                     <Return type="N"/>
                     <Source>\ninline N Code() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;code;\n   }</Source>
                  </Method>
                  <Method name="Value" type="inline" description="获得当前位置的数据内容。">
                     <Return type="V"/>
                     <Source>\ninline V Value() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TShareSegment">
               <Methods>
                  <Constructor name="TShareSegment"/>
                  <Constructor name="TShareSegment">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory"/>
                        <Parameter type="TInt" name="length"/>
                        <Parameter type="TBool" name="created"/>
                     </Parameters>
                  </Constructor>
                  <Method name="TypeAlloc" description="从共享内存中收集一块指定类型的内存。">
                     <Return type="T*"/>
                     <Source>\ntemplate &lt;typename T&gt; T* TypeAlloc(){\n      TByte* pMemory = _pMemory + _position;\n      _position += sizeof(T);\n      MO_ASSERT(_length &gt;= _position);\n      return (T*)pMemory;\n   }</Source>
                  </Method>
                  <Method name="TypeAlloc" description="从共享内存中收集指定个数的指定类型的内存。">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="T*"/>
                     <Source>\ntemplate &lt;typename T&gt; T* TypeAlloc(TInt count){\n      TByte* pMemory = NULL;\n      if(count &gt; 0){\n         pMemory = _pMemory + _position;\n         _position += sizeof(T) * count;\n         MO_ASSERT(_length &gt;= _position);\n      }\n      return (T*)pMemory;\n   }</Source>
                  </Method>
                  <Method name="CreateTypeSegment">
                     <Return type="TShareSegment"/>
                     <Source>\ntemplate &lt;typename T&gt; TShareSegment CreateTypeSegment(){\n      TShareSegment segment;\n      segment.Initialize(_pMemory + _position, sizeof(T), _created);\n      _position += sizeof(T);\n      MO_ASSERT(_length &gt;= _position);\n      return segment;\n   }</Source>
                  </Method>
                  <Method name="CreateTypeSegment">
                     <Parameters>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="TShareSegment"/>
                     <Source>\ntemplate &lt;typename T&gt; TShareSegment CreateTypeSegment(TInt count){\n      TShareSegment segment;\n      TInt capacity = sizeof(T) * count;\n      segment.Initialize(_pMemory + _position, capacity, _created);\n      _position += capacity;\n      MO_ASSERT(_length &gt;= _position);\n      return segment;\n   }</Source>
                  </Method>
                  <Method name="Initialize" description="初始化共享内存段。">
                     <Parameters>
                        <Parameter type="TAny*" name="pMemory" description="内存指针"/>
                        <Parameter type="TInt" name="length" description="数据长度"/>
                        <Parameter type="TBool" name="created"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;初始化共享内存段。&lt;/T&gt;\n//\n// @param pMemory 内存指针\n// @param length 数据长度\n//============================================================\n\nvoid TShareSegment::Initialize(TAny* pMemory, TInt length, TBool created){\n   _pMemory = (TByte*)pMemory;\n   _position = 0;\n   _length = length;\n   _created = created;\n}</Source>
                  </Method>
                  <Method name="IsCreated" description="是否被创建。如果内存是被关联后直接使用的，返回非。">
                     <Return type="TBool">
                        <L value="value=&quot;ETrue&quot;&gt;共享内存是新建的"/>
                        <L value="value=&quot;EFalse&quot;&gt;共享内存是关联后使用的"/>
                     </Return>
                     <Source>//============================================================\n// &lt;T&gt;是否被创建。&lt;/T&gt;\n// &lt;T&gt;如果内存是被关联后直接使用的，返回非。&lt;/T&gt;\n//\n// @return\n//    &lt;L value=&quot;ETrue&quot;&gt;共享内存是新建的&lt;/L&gt;\n//    &lt;L value=&quot;EFalse&quot;&gt;共享内存是关联后使用的&lt;/L&gt;\n//============================================================\n\nTBool TShareSegment::IsCreated(){\n   return _created;\n}</Source>
                  </Method>
                  <Method name="MemoryC" description="获得关联的内存指针。">
                     <Return type="TAny*" description="内存指针"/>
                     <Source>//============================================================\n// &lt;T&gt;获得关联的内存指针。&lt;/T&gt;\n//\n// @return 内存指针\n//============================================================\n\nTAny* TShareSegment::MemoryC(){\n   return _pMemory;\n}</Source>
                  </Method>
                  <Method name="Position" description="获得当前内存位置。">
                     <Return type="TInt" description="内存位置"/>
                     <Source>//============================================================\n// &lt;T&gt;获得当前内存位置。&lt;/T&gt;\n//\n// @return 内存位置\n//============================================================\n\nTInt TShareSegment::Position(){\n   return _position;\n}</Source>
                  </Method>
                  <Method name="Length" description="获得内存长度。">
                     <Return type="TInt" description="内存长度"/>
                     <Source>//============================================================\n// &lt;T&gt;获得内存长度。&lt;/T&gt;\n//\n// @return 内存长度\n//============================================================\n\nTInt TShareSegment::Length(){\n   return _length;\n}</Source>
                  </Method>
                  <Method name="Remain" description="获得剩余的内存指针。">
                     <Return type="TInt" description="剩余的内存指针"/>
                     <Source>//============================================================\n// &lt;T&gt;获得剩余的内存指针。&lt;/T&gt;\n//\n// @return 剩余的内存指针\n//============================================================\n\nTInt TShareSegment::Remain(){\n   return _length - _position;\n}</Source>
                  </Method>
                  <Method name="RemainMemoryC" description="获得当前位置的内存指针。">
                     <Return type="TAny*" description="内存指针"/>
                     <Source>//============================================================\n// &lt;T&gt;获得当前位置的内存指针。&lt;/T&gt;\n//\n// @return 内存指针\n//============================================================\n\nTAny* TShareSegment::RemainMemoryC(){\n   return _pMemory + _position;\n}</Source>
                  </Method>
                  <Method name="Alloc" description="从共享内存中收集一块指定大小的内存。">
                     <Parameters>
                        <Parameter type="TSize" name="size" description="内存大小"/>
                     </Parameters>
                     <Return type="TAny*" description="共享内存"/>
                     <Source>//============================================================\n// &lt;T&gt;从共享内存中收集一块指定大小的内存。&lt;/T&gt;\n//\n// @param size 内存大小\n// @return 共享内存\n//============================================================\n\nTAny* TShareSegment::Alloc(TSize size){\n   TByte* pMemory = NULL;\n   if(size &gt; 0){\n      pMemory = _pMemory + _position;\n      _position += size;\n   }\n   return pMemory;\n}</Source>
                  </Method>
                  <Method name="CreateSegment" description="在当前共享内存段内，分配新的共享内存段。">
                     <Parameters>
                        <Parameter type="TSize" name="size" description="大小"/>
                     </Parameters>
                     <Return type="TShareSegment" description="共享内存段"/>
                     <Source>//============================================================\n// &lt;T&gt;在当前共享内存段内，分配新的共享内存段。&lt;/T&gt;\n//\n// @param size 大小\n// @return 共享内存段\n//============================================================\n\nTShareSegment TShareSegment::CreateSegment(TSize size){\n   TShareSegment segment;\n   segment.Initialize(_pMemory + _position, size, _created);\n   _position += size;\n   return segment;\n}</Source>
                  </Method>
                  <Method name="SharedLink" description="分配共享对象大小的内存块，和共享对象关联。">
                     <Parameters>
                        <Parameter type="FShared*" name="pShared" description="共享对象"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;分配共享对象大小的内存块，和共享对象关联。&lt;/T&gt;\n//\n// @param pShared 共享对象\n//============================================================\n\nvoid TShareSegment::SharedLink(FShared* pShared){\n   MO_ASSERT(pShared);\n   TSize capacity = pShared-&gt;SharedCapacity();\n   TShareSegment segment = CreateSegment(capacity);\n   pShared-&gt;SharedLink(segment);\n}</Source>
                  </Method>
                  <Method name="Check" description="检测共享内存是否分配完整。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;检测共享内存是否分配完整。&lt;/T&gt;\n//============================================================\n\nvoid TShareSegment::Check(){\n   if(_position != _length){\n      TChar lengthBuffer[MO_MEMORY_FORMATLENGTH];\n      TChar positionBuffer[MO_MEMORY_FORMATLENGTH];\n      MO_ERROR(&quot;Share memory segment is invalid. (length=%s, position=%s)&quot;,\n            RInt::FormatCapacity(_length, lengthBuffer, MO_MEMORY_FORMATLENGTH),\n            RInt::FormatCapacity(_position, positionBuffer, MO_MEMORY_FORMATLENGTH));\n   }\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TByte*" name="_pMemory"/>
                  <Attribute type="TInt" name="_position"/>
                  <Attribute type="TInt" name="_length"/>
                  <Attribute type="TBool" name="_created"/>
               </Attributes>
            </Class>
            <Class name="TSharedEntryIteratorC">
               <Methods>
                  <Constructor name="TSharedEntryIteratorC"/>
                  <Constructor name="TSharedEntryIteratorC">
                     <Parameters>
                        <Parameter type="TSharedEntryIteratorC&lt;E&gt;&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TSharedEntryIteratorC">
                     <Parameters>
                        <Parameter type="E*" name="pEntries"/>
                        <Parameter type="TInt" name="start"/>
                     </Parameters>
                  </Constructor>
                  <Method name="*" type="inline">
                     <Return type="operator"/>
                     <Source>\ninline E operator *() const{\n      return _pEntries[_current];\n   }</Source>
                  </Method>
                  <Method name="-&gt;" type="inline">
                     <Return type="operator"/>
                     <Source>\ninline E operator -&gt;() const{\n      return _pEntries[_current];\n   }</Source>
                  </Method>
                  <Method name="Reset" type="inline">
                     <Return type="void"/>
                     <Source>\ninline void Reset(){\n      _current = -1;\n   }</Source>
                  </Method>
                  <Method name="Next" type="inline">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Next(){\n      _current = (_current &lt; 0) ? _start : _pEntries[_current].next;\n      return (_current &gt;= 0);\n   }</Source>
                  </Method>
                  <Method name="Prior" type="inline">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Prior(){\n      _current = (_current &lt; 0) ? _start : _pEntries[_current].prior;\n      return (_current &gt;= 0);\n   }</Source>
                  </Method>
                  <Method name="Get" type="inline">
                     <Return type="E&amp;"/>
                     <Source>\ninline E&amp; Get(){\n      return _pEntries[_current];\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="E*" name="_pEntries"/>
                  <Attribute type="TInt" name="_start"/>
                  <Attribute type="TInt" name="_current"/>
               </Attributes>
            </Class>
            <Class name="TSharedList">
               <Methods>
                  <Method name="Initialize">
                     <Parameters>
                        <Parameter type="FSharedListAllocator*" name="pAllocator"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TSharedList::Initialize(FSharedListAllocator* pAllocator){\n   _pAllocator = pAllocator;\n   _gHead = pAllocator-&gt;AllocList();\n   _gEntries = pAllocator-&gt;Entries();\n}</Source>
                  </Method>
                  <Method name="Release">
                     <Return type="void"/>
                     <Source>//============================================================\n\nvoid TSharedList::Release(){\n   _pAllocator-&gt;FreeList(_gHead);\n}</Source>
                  </Method>
                  <Method name="operator==">
                     <Parameters>
                        <Parameter type="TSharedList&amp;" name="list"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// 判断当前链表和指定链表中所有数据内容是否相等。\n//============================================================\n\nTBool TSharedList::operator==(const TSharedList&amp; list) const{\n   return Equals(list);\n}</Source>
                  </Method>
                  <Method name="operator!=">
                     <Parameters>
                        <Parameter type="TSharedList&amp;" name="list"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// 判断当前链表和指定链表中所有数据内容是否不相等。\n//============================================================\n\nTBool TSharedList::operator!=(const TSharedList&amp; list) const{\n   return !Equals(list);\n}</Source>
                  </Method>
                  <Method name="operator+=">
                     <Parameters>
                        <Parameter type="TSharedList&amp;" name="list"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// 追加一个链表到当前链表中。\n//============================================================\n\nvoid TSharedList::operator+=(const TSharedList&amp; list){\n   Append(list);\n}</Source>
                  </Method>
                  <Method name="IsEmpty">
                     <Return type="TBool"/>
                     <Source>//============================================================\n// 获得是否为空\n//============================================================\n\nTBool TSharedList::IsEmpty() const{\n   return (0 == _gHead-&gt;count);\n}</Source>
                  </Method>
                  <Method name="Count">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// 获得总数\n//============================================================\n\nTInt TSharedList::Count() const{\n   return _gHead-&gt;count;\n}</Source>
                  </Method>
                  <Method name="Equals">
                     <Parameters>
                        <Parameter type="TSharedList&amp;" name="list"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>//============================================================\n// 判断当前链表和指定链表是否相等\n//============================================================\n\nTBool TSharedList::Equals(const TSharedList&amp; list) const{\n   // 比较数量\n   if(_gHead-&gt;count != list._gHead-&gt;count){\n      return EFalse;\n   }\n   // 比较所有项目\n   TInt current = _gHead-&gt;first;\n   TIteratorC iterator = list.IteratorC();\n   while(current &gt;= 0 &amp;&amp; iterator.Next()){\n      SSharedListEntry&amp; entry = _gEntries[current];\n      if(entry.code != *iterator){\n         return EFalse;\n      }\n      current = entry.next;\n   }\n   return ETrue;\n}</Source>
                  </Method>
                  <Method name="IteratorC">
                     <Return type="TSharedListIteratorC"/>
                     <Source>//============================================================\n// 获得首位置的只读数据迭代器\n//============================================================\n\nTSharedListIteratorC TSharedList::IteratorC() const{\n   return TIteratorC(_pAllocator-&gt;Entries(), _gHead-&gt;first);\n}</Source>
                  </Method>
                  <Method name="LastIteratorC">
                     <Return type="TSharedListIteratorC"/>
                     <Source>//============================================================\n// 获得尾位置的只读数据迭代器\n//============================================================\n\nTSharedListIteratorC TSharedList::LastIteratorC() const{\n   return TIteratorC(_pAllocator-&gt;Entries(), _gHead-&gt;last);\n}</Source>
                  </Method>
                  <Method name="Assign">
                     <Parameters>
                        <Parameter type="TSharedList&amp;" name="list"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// 接收一个链表到当前链表中。\n//============================================================\n\nvoid TSharedList::Assign(const TSharedList&amp; list){\n   Clear();\n   Append(list);\n}</Source>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="TSharedList&amp;" name="list"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// 追加一个链表到当前链表中。\n//============================================================\n\nvoid TSharedList::Append(const TSharedList&amp; list){\n   TIteratorC iterator = list.IteratorC();\n   while(iterator.Next()){\n      Push(*iterator);\n   }\n}</Source>
                  </Method>
                  <Method name="Unshift">
                     <Parameters>
                        <Parameter type="TInt32" name="code"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// 将数据压入首位置\n//============================================================\n\nvoid TSharedList::Unshift(TInt32 code){\n   // 收集一个未使用的节点\n   SSharedListEntry&amp; entry = _pAllocator-&gt;AllocEntry();\n   // 将当前节点压入首节点\n   if(_gHead-&gt;first &lt; 0){\n      _gHead-&gt;last = entry.index;\n   }else{\n      _gEntries[_gHead-&gt;first].prior = entry.index;\n   }\n   // 设置内容\n   entry.prior = -1;\n   entry.next = _gHead-&gt;first;\n   entry.code = code;\n   _gHead-&gt;first = entry.index;\n   _gHead-&gt;count++;\n}</Source>
                  </Method>
                  <Method name="Shift">
                     <Return type="TInt32"/>
                     <Source>//============================================================\n// 弹出链表的首数据\n//============================================================\n\nTInt32 TSharedList::Shift(){\n   MO_ASSERT(_gHead-&gt;first &gt;= 0);\n   // 弹出首节点\n   TInt index = _gHead-&gt;first;\n   SSharedListEntry&amp; entry = _gEntries[index];\n   _gHead-&gt;first = entry.next;\n   if(_gHead-&gt;first &lt; 0){\n      _gHead-&gt;last = -1;\n   }else{\n      _gEntries[_gHead-&gt;first].prior = -1;\n   }\n   // 设置内容\n   _gHead-&gt;count--;\n   // 回收空闲节点\n   TInt32 code = entry.code;\n   _pAllocator-&gt;FreeEntry(entry);\n   // 返回节点\n   return code;\n}</Source>
                  </Method>
                  <Method name="Push">
                     <Parameters>
                        <Parameter type="TInt32" name="code"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// 将数据压入尾位置\n//============================================================\n\nvoid TSharedList::Push(TInt32 code){\n   // 收集一个未使用的节点\n   SSharedListEntry&amp; entry = _pAllocator-&gt;AllocEntry();\n   // 将当前节点插入尾节点\n   if(_gHead-&gt;last &lt; 0){\n      _gHead-&gt;first = entry.index;\n   }else{\n      _gEntries[_gHead-&gt;last].next = entry.index;\n   }\n   // 设置内容\n   entry.prior = _gHead-&gt;last;\n   entry.next = -1;\n   entry.code = code;\n   _gHead-&gt;last = entry.index;\n   _gHead-&gt;count++;\n}</Source>
                  </Method>
                  <Method name="Pop">
                     <Return type="TInt"/>
                     <Source>//============================================================\n// 弹出链表的尾数据\n//============================================================\n\nTInt TSharedList::Pop(){\n   MO_ASSERT(_gHead-&gt;last &gt;= 0);\n   // 弹出尾节点\n   TInt index = _gHead-&gt;last;\n   SSharedListEntry&amp; entry = _gEntries[index];\n   _gHead-&gt;last = entry.prior;\n   if(_gHead-&gt;last &lt; 0){\n      _gHead-&gt;first = 0;\n   }else{\n      _gEntries[_gHead-&gt;last].next = 0;\n   }\n   // 设置内容\n   _gHead-&gt;count--;\n   // 回收空闲节点\n   TInt32 code = entry.code;\n   _pAllocator-&gt;FreeEntry(entry);\n   // 返回节点\n   return code;\n}</Source>
                  </Method>
                  <Method name="Delete">
                     <Parameters>
                        <Parameter type="TInt" name="index"/>
                     </Parameters>
                     <Return type="TInt32"/>
                     <Source>//============================================================\n// 从链表上删除链表节点\n//============================================================\n\nTInt32 TSharedList::Delete(TInt index){\n   SSharedListEntry&amp; entry = _gEntries[index];\n   TInt prior = entry.prior;\n   TInt next = entry.next;\n   // 处理前节点\n   if(prior &lt; 0){\n      _gHead-&gt;first = next;\n   }else{\n      _gEntries[prior].next = next;\n   }\n   // 处理后节点\n   if(next &lt; 0){\n      _gHead-&gt;last = prior;\n   }else{\n      _gEntries[next].prior = prior;\n   }\n   // 设置内容\n   _gHead-&gt;count--;\n   // 回收空闲节点\n   TInt32 code = entry.code;\n   _pAllocator-&gt;FreeEntry(entry);\n   // 返回节点\n   return code;\n}</Source>
                  </Method>
                  <Method name="Remove">
                     <Parameters>
                        <Parameter type="TInt32" name="code"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// 从链表上删除链表节点\n//============================================================\n\nvoid TSharedList::Remove(TInt32 code){\n   TInt32 current = _gHead-&gt;first;\n   while(current &gt;= 0){\n      SSharedListEntry&amp; entry = _gEntries[current];\n      TInt next = entry.next;\n      if(entry.code == code){\n         Delete(entry.index);\n      }\n      current = next;\n   }\n}</Source>
                  </Method>
                  <Method name="Clear">
                     <Return type="void"/>
                     <Source>//============================================================\n// 清空所有数据\n//============================================================\n\nvoid TSharedList::Clear(){\n   // 释放全部列表\n   _pAllocator-&gt;FreeEntries(_gHead);\n   // 设置清空内容\n   _gHead-&gt;count = 0;\n   _gHead-&gt;first = -1;\n   _gHead-&gt;last = -1;\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="FSharedListAllocator*" name="_pAllocator"/>
                  <Attribute type="SSharedListHead*" name="_gHead"/>
                  <Attribute type="SSharedListEntry*" name="_gEntries"/>
               </Attributes>
            </Class>
            <Class name="TSharedListIteratorC">
               <Methods>
                  <Constructor name="TSharedListIteratorC"/>
                  <Constructor name="TSharedListIteratorC">
                     <Parameters>
                        <Parameter type="TSharedListIteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TSharedListIteratorC">
                     <Parameters>
                        <Parameter type="SSharedListEntry*" name="pEntries"/>
                        <Parameter type="TInt" name="start"/>
                     </Parameters>
                  </Constructor>
                  <Method name="*" type="inline">
                     <Return type="operator"/>
                     <Source>\ninline TInt32 operator *() const{\n      MO_ASSERT(_current &gt;= 0);\n      return _pEntries[_current].code;\n   }</Source>
                  </Method>
                  <Method name="-&gt;" type="inline">
                     <Return type="operator"/>
                     <Source>\ninline TInt32 operator -&gt;() const{\n      MO_ASSERT(_current &gt;= 0);\n      return _pEntries[_current].code;\n   }</Source>
                  </Method>
                  <Method name="Reset" type="inline">
                     <Return type="void"/>
                     <Source>\ninline void Reset(){\n      _current = -1;\n   }</Source>
                  </Method>
                  <Method name="Next" type="inline">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Next(){\n      _current = (_current &lt; 0) ? _start : _pEntries[_current].next;\n      return (_current &gt;= 0);\n   }</Source>
                  </Method>
                  <Method name="Prior" type="inline">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Prior(){\n      _current = (_current &lt; 0) ? _start : _pEntries[_current].prior;\n      return (_current &gt;= 0);\n   }</Source>
                  </Method>
                  <Method name="Get" type="inline">
                     <Return type="TInt"/>
                     <Source>\ninline TInt Get(){\n      MO_ASSERT(_current &gt;= 0);\n      return _pEntries[_current].code;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="SSharedListEntry*" name="_pEntries"/>
                  <Attribute type="TInt" name="_start"/>
                  <Attribute type="TInt" name="_current"/>
               </Attributes>
            </Class>
            <Class name="TSharedPtr">
               <Methods>
                  <Constructor name="TSharedPtr" description="构造指针。"/>
                  <Constructor name="TSharedPtr" description="构造指针。">
                     <Parameters>
                        <Parameter type="T*" name="pObject"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TSharedPtr" description="析构构造指针。"/>
                  <Method name="*" type="inline" description="获取对象指针。">
                     <Return type="operator"/>
                     <Source>\ninline T&amp; operator *(){\n      return _pObject;\n   }</Source>
                  </Method>
                  <Method name="operator-&gt;" type="inline" description="获取对象指针。">
                     <Return type="T"/>
                     <Source>\ninline T operator-&gt;(){\n      MO_ASSERT(_pObject);\n      return _pObject;\n   }</Source>
                  </Method>
                  <Method name="operator=" type="inline" description="获取对象指针。">
                     <Parameters>
                        <Parameter type="TSharedPtr&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void operator=(TSharedPtr&amp; ptr){\n      _pObject = *ptr;\n      _refer = ptr.Refer();\n      ptr.Reset();\n   }</Source>
                  </Method>
                  <Method name="Refer" description="获得引用次数。">
                     <Return type="TInt"/>
                     <Source>\nTInt Refer(){\n      return _refer;\n   }</Source>
                  </Method>
                  <Method name="Increase" description="增加引用次数。">
                     <Return type="void"/>
                     <Source>\nvoid Increase(){\n      _refer++;\n   }</Source>
                  </Method>
                  <Method name="Decrease" description="减少引用次数。">
                     <Return type="void"/>
                     <Source>\nvoid Decrease(){\n      _refer--;\n      if(_refer &lt;= 0){\n         //MO_DELETE(_pObject);\n      }\n   }</Source>
                  </Method>
                  <Method name="Reset" description="重置对象。">
                     <Return type="void"/>
                     <Source>\nvoid Reset(){\n      _pObject = NULL;\n      _refer++;\n   }</Source>
                  </Method>
                  <Method name="Release" description="强制释放对象。">
                     <Return type="void"/>
                     <Source>\nvoid Release(){\n      if(NULL != _pObject){\n         //MO_DELETE(_pObject);\n      }\n      _pObject = NULL;\n      _refer++;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T*" name="_pObject"/>
                  <Attribute type="TInt" name="_refer"/>
               </Attributes>
            </Class>
            <Class name="TSharedSet">
               <Inherits name="FShared" scope="public"/>
               <Methods>
                  <Method name="Initialize">
                     <Return type="void"/>
                     <Source>\nvoid Initialize(){\n      _gHead = NULL;\n      _pAllocator = NULL;\n   }</Source>
                  </Method>
                  <Method name="Release">
                     <Return type="void"/>
                     <Source>\nvoid Release(){\n   }</Source>
                  </Method>
                  <Method name="SetCapacity">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid SetCapacity(TInt capacity){\n      _capacity = capacity;\n   }</Source>
                  </Method>
                  <Method name="SharedCapacity">
                     <Return type="TSize"/>
                     <Source>\nTSize SharedCapacity(){\n      TSize size = sizeof(SSharedSetHead);\n      size += sizeof(I) * _capacity;\n      return size;\n   }</Source>
                  </Method>
                  <Method name="SharedLink">
                     <Parameters>
                        <Parameter type="TShareSegment" name="segment"/>
                     </Parameters>
                     <Return type="TSize"/>
                     <Source>\nTSize SharedLink(TShareSegment segment){\n      _gHead = segment.TypeAlloc&lt;SSharedListHead&gt;();\n      _gEntries = segment.TypeAlloc&lt;I&gt;(_capacity);\n      SharedCheck(segment);\n   }</Source>
                  </Method>
                  <Method name="SharedInitialize">
                     <Return type="void"/>
                     <Source>\nvoid SharedInitialize(){\n      _gHead-&gt;count = 0;\n      _gHead-&gt;first = -1;\n      _gHead-&gt;last = -1;\n      RTypes&lt;I&gt;::Fill(_gEntries, _capacity, -1);\n   }</Source>
                  </Method>
                  <Method name="operator==">
                     <Parameters>
                        <Parameter type="TSharedList&lt;E&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator==(const TSharedList&lt;E&gt;&amp; list) const{\n		return Equals(list);\n	}</Source>
                  </Method>
                  <Method name="operator!=">
                     <Parameters>
                        <Parameter type="TSharedList&lt;E&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool operator!=(const TSharedList&lt;E&gt;&amp; list) const{\n		return !Equals(list);\n	}</Source>
                  </Method>
                  <Method name="operator+=">
                     <Parameters>
                        <Parameter type="TSharedList&lt;E&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator+=(const TSharedList&lt;E&gt;&amp; list){\n		Append(list);\n	}</Source>
                  </Method>
                  <Method name="IsEmpty">
                     <Return type="TBool"/>
                     <Source>\nTBool IsEmpty() const{\n      return (0 == _gHead-&gt;count);\n   }</Source>
                  </Method>
                  <Method name="Count">
                     <Return type="TInt"/>
                     <Source>\nTInt Count() const{\n      return _gHead-&gt;count;\n   }</Source>
                  </Method>
                  <Method name="Equals">
                     <Parameters>
                        <Parameter type="TSharedList&lt;E&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Equals(const TSharedList&lt;E&gt;&amp; list) const{\n      return ETrue;\n	}</Source>
                  </Method>
                  <Method name="Assign">
                     <Parameters>
                        <Parameter type="TSharedList&lt;E&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Assign(const TSharedList&lt;E&gt;&amp; list){\n		Clear();\n      Append(list);\n	}</Source>
                  </Method>
                  <Method name="Append">
                     <Parameters>
                        <Parameter type="TSharedList&lt;E&gt;&amp;" name="list"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid Append(const TSharedList&lt;E&gt;&amp; list){\n	}</Source>
                  </Method>
                  <Method name="Set" description="根据名称设置数据。">
                     <Parameters>
                        <Parameter type="T" name="code"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\nTBool Set(T code){\n      TInt position = code % _capacity;\n      E* pEntries = _pAllocator-&gt;Entries();\n      // 查找数据出现的位置\n      I current = _gEntries[position];\n      while(current &gt;= 0){\n         if(pEntries[current].code == code){\n            return EFalse;\n         }\n         current = pEntries[current].link;\n      }\n      // 如果名称不存在，为新建节点检查内存\n      TInt index;\n      E&amp; entry = _pAllocator-&gt;Alloc(index);\n      entry.link = current;\n      entry.code = code;\n      _gEntries[position] = index;\n      // 追加到链表尾部\n      if(_gHead-&gt;last &lt; 0){\n         _gHead-&gt;first = index;\n      }else{\n         pEntries[_gHead-&gt;last].next = index;\n      }\n      // 设置内容\n      entry.prior = _gHead-&gt;last;\n      entry.next = -1;\n      _gHead-&gt;count++;\n      _gHead-&gt;last = index;\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="Clear" description="移除指定名称的数据。">
                     <Return type="void"/>
                     <Source>\nvoid Clear(){\n      // 释放全部列表\n      _pAllocator-&gt;Free(_gHead-&gt;count, _gHead-&gt;first, _gHead-&gt;last);\n      // 设置清空内容\n      _gHead-&gt;count = 0;\n      _gHead-&gt;first = -1;\n      _gHead-&gt;last = -1;\n      RTypes&lt;I&gt;::Fill(_gEntries, _capacity, -1);\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_capacity"/>
                  <Attribute type="SSharedSetHead*" name="_gHead"/>
                  <Attribute type="I*" name="_gEntries"/>
               </Attributes>
            </Class>
            <Class name="TString16">
               <Inherits>
                  <Inherit name="MString16" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TString16" description="构造一个ANSI字符串类。"/>
                  <Constructor name="TString16" description="构造一个ANSI字符串类。">
                     <Parameters>
                        <Parameter type="TString16&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString16" description="构造一个ANSI字符串类。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString16" description="构造一个ANSI字符串类。">
                     <Parameters>
                        <Parameter type="MString16PtrC&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TString16" description="析构一个ANSI字符串类。"/>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      this-&gt;_length = 0;\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_pMemory = RTypeMemory&lt;TChar16&gt;::Alloc(this-&gt;_size, 0);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="TString16&amp;" name="value"/>
                     </Parameters>
                     <Return type="void" description="结果字符串对象"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param source ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid TString16::operator=(const TString16&amp; value){\n   Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue"/>
                     </Parameters>
                     <Return type="void" description="结果字符串对象"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串的内容。&lt;/T&gt;\n//\n// @param source ANSI字符串\n// @return 结果字符串对象\n//============================================================\n\nvoid TString16::operator=(TChar16C* pValue){\n   Assign(pValue);\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="MString16PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void" description="结果字符串对象"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param source ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid TString16::operator=(const MString16PtrC&amp; value){\n   Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="AssignAnsi" description="将指定ANSI字符串指针对象赋值给当前字符串。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue" description="ANSI字符串指针"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将指定ANSI字符串指针对象赋值给当前字符串。&lt;/T&gt;\n//\n// @param pValue ANSI字符串指针\n//============================================================\n\nvoid TString16::AssignAnsi(TChar8C* pValue){\n   TSize length = RString8::ConvertToString16(pValue);\n   if(-1 == length){\n      MO_ERROR(&quot;Convert error!&quot;);\n   }else{\n      InnerInitialize(length);\n      Clear();\n      RString8::ConvertToString16(_pMemory, length, pValue);\n      _length = length;\n   }\n}</Source>
                  </Method>
                  <Method name="AppendAnsi" description="将指定ANSI字符串指针对象添加到当前字符串。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue" description="ANSI字符串指针"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将指定ANSI字符串指针对象添加到当前字符串。&lt;/T&gt;\n//\n// @param pValue ANSI字符串指针\n//============================================================\n\nvoid TString16::AppendAnsi(TChar8C* pValue){\n   MO_ASSERT(pValue);\n   TSize length = RString8::ConvertToString16(pValue);\n   if(-1 == length){\n      MO_ERROR(&quot;Convert error!&quot;);\n   }else{\n      InnerInitialize(length + _length);\n      RString8::ConvertToString16(_pMemory + length, length, pValue);\n      _length = _length + length;\n   }\n}</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size" description="大小"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;确保内存大小。&lt;/T&gt;\n// &lt;P&gt;当第一次使用是，会收集第一块内存。\n// 当前大小内存不足时，会重新收集指定大小1.5倍的内存存放数据，暂未使用的作为缓冲使用。\n// 当内存不再发生大小上改变的时候，可以使用压缩函数释放掉所有未使用的缓冲内存。&lt;/P&gt;\n//\n// @param size 大小\n//============================================================\n\nvoid TString16::EnsureSize(TInt size){\n   if(size &gt; this-&gt;_size){\n      // 当内存不足时，扩大1.5倍内存，但收集量不得小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_size += this-&gt;_size &gt;&gt; 1;\n      TChar16* pMemory = RTypeMemory&lt;TChar16&gt;::Alloc(this-&gt;_size, 0);\n      if(this-&gt;_length &gt; 0){\n         RTypes&lt;TChar16&gt;::Copy(pMemory, this-&gt;_pMemory, this-&gt;_length);\n      }\n      RTypeMemory&lt;TChar16&gt;::Free(this-&gt;_pMemory);\n      this-&gt;_pMemory = pMemory;\n   }\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TString16Ptr">
               <Inherits>
                  <Inherit name="TChar16Ptr" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TString16Ptr" description="构建空指针对象。"/>
                  <Constructor name="TString16Ptr" description="从数据指针构建对象。">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pMemory"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString16Ptr" description="从数据指针和长度构建对象。">
                     <Parameters>
                        <Parameter type="TInt" name="size" default="0"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString16Ptr" description="从其他指针对象构建对象。">
                     <Parameters>
                        <Parameter type="MString16PtrC&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator=" description="重载指针复制操作。">
                     <Parameters>
                        <Parameter type="MString16PtrC&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString16PtrC&amp; ptr) {\n      Set(ptr);\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TString16Refer">
               <Inherits>
                  <Inherit name="MString16" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TString16Refer">
                     <Parameters>
                        <Parameter type="TChar16*" name="pValue"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                  </Constructor>
                  <Method name="EnsureSize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt size){\n      MO_ASSERT(size &lt;= this-&gt;_size);\n   }</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TString16Refer&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TString16Refer&amp; value){\n      Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(TChar16C* pValue){\n      Assign(pValue);\n   }</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="MString16PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString16PtrC&amp; value){\n      Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TString16s">
               <Inherits>
                  <Inherit name="MString16s" scope="public"/>
               </Inherits>
            </Class>
            <Class name="TString32">
               <Inherits>
                  <Inherit name="MString32" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TString32" description="构造一个ANSI字符串类。"/>
                  <Constructor name="TString32" description="构造一个ANSI字符串类。">
                     <Parameters>
                        <Parameter type="TString32&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString32" description="构造一个ANSI字符串类。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString32" description="构造一个ANSI字符串类。">
                     <Parameters>
                        <Parameter type="MString32PtrC&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TString32" description="析构一个ANSI字符串类。"/>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      this-&gt;_length = 0;\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_pMemory = RTypeMemory&lt;TChar32&gt;::Alloc(this-&gt;_size, 0);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="TString32&amp;" name="value"/>
                     </Parameters>
                     <Return type="void" description="结果字符串对象"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param source ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid TString32::operator=(const TString32&amp; value){\n   Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="void" description="结果字符串对象"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串的内容。&lt;/T&gt;\n//\n// @param source ANSI字符串\n// @return 结果字符串对象\n//============================================================\n\nvoid TString32::operator=(TChar32C* pValue){\n   Assign(pValue);\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="MString32PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void" description="结果字符串对象"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param source ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid TString32::operator=(const MString32PtrC&amp; value){\n   Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="AssignAnsi" description="将指定ANSI字符串指针对象赋值给当前字符串。 ">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue" description="ANSI字符串指针对象"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将指定ANSI字符串指针对象赋值给当前字符串。 &lt;/T&gt;\n//\n// @param pValue ANSI字符串指针对象\n//============================================================\n\nvoid TString32::AssignAnsi(TChar8C* pValue){\n   TSize length = RString8::ConvertToString32(pValue);\n   if(-1 == length){\n      MO_ERROR(&quot;Convert error!&quot;);\n   }else{\n      InnerInitialize(length);\n      Clear();\n      RString8::ConvertToString32(_pMemory, length, pValue);\n      _length = length;\n   }\n}</Source>
                  </Method>
                  <Method name="AppendAnsi" description="将指定ANSI字符串指针对象添加到当前字符串。 ">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue" description="ANSI字符串指针对象"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将指定ANSI字符串指针对象添加到当前字符串。 &lt;/T&gt;\n//\n// @param pValue ANSI字符串指针对象\n//============================================================\n\nvoid TString32::AppendAnsi(TChar8C* pValue){\n   TSize length = RString8::ConvertToString32(pValue);\n   if(-1 == length){\n      MO_ERROR(&quot;Convert error!&quot;);\n   }else{\n      InnerInitialize(length + _length);\n      RString8::ConvertToString32(_pMemory + _length, length, pValue);\n      _length = _length + length;\n   }\n}</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size" description="大小"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;确保内存大小。&lt;/T&gt;\n// &lt;P&gt;当第一次使用是，会收集第一块内存。\n// 当前大小内存不足时，会重新收集指定大小1.5倍的内存存放数据，暂未使用的作为缓冲使用。\n// 当内存不再发生大小上改变的时候，可以使用压缩函数释放掉所有未使用的缓冲内存。&lt;/P&gt;\n//\n// @param size 大小\n//============================================================\n\nvoid TString32::EnsureSize(TInt size){\n   if(size &gt; this-&gt;_size){\n      // 当内存不足时，扩大1.5倍内存，但收集量不得小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_size += this-&gt;_size &gt;&gt; 1;\n      TChar32* pMemory = RTypeMemory&lt;TChar32&gt;::Alloc(this-&gt;_size, 0);\n      if(this-&gt;_length &gt; 0){\n         RTypes&lt;TChar32&gt;::Copy(pMemory, this-&gt;_pMemory, this-&gt;_length);\n      }\n      RTypeMemory&lt;TChar32&gt;::Free(this-&gt;_pMemory);\n      this-&gt;_pMemory = pMemory;\n   }\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TString32Ptr">
               <Inherits>
                  <Inherit name="TChar32Ptr" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TString32Ptr" description="构建空指针对象。"/>
                  <Constructor name="TString32Ptr" description="从数据指针构建对象。">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pMemory"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString32Ptr" description="从数据指针和长度构建对象。">
                     <Parameters>
                        <Parameter type="TInt" name="size" default="0"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString32Ptr" description="从其他指针对象构建对象。">
                     <Parameters>
                        <Parameter type="MString32PtrC&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator=" description="重载指针复制操作。">
                     <Parameters>
                        <Parameter type="MString32PtrC&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString32PtrC&amp; ptr) {\n      Set(ptr);\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TString32Refer">
               <Inherits>
                  <Inherit name="MString32" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TString32Refer">
                     <Parameters>
                        <Parameter type="TChar32*" name="pValue"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                  </Constructor>
                  <Method name="EnsureSize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt size){\n      MO_ASSERT(size &lt;= this-&gt;_size);\n   }</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TString32Refer&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TString32Refer&amp; value){\n      Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(TChar32C* pValue){\n      Assign(pValue);\n   }</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="MString32PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString32PtrC&amp; value){\n      Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TString32s">
               <Inherits>
                  <Inherit name="MString32s" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TString32s"/>
                  <Constructor name="TString32s">
                     <Parameters>
                        <Parameter type="MString32sC&amp;" name="strings"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString32s">
                     <Parameters>
                        <Parameter type="TString32s&amp;" name="strings"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TString32s"/>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="MString32sC&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString32sC&amp; strings){\n		Assign(strings);\n	}</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TString32s&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TString32s&amp; strings){\n		Assign(strings);\n	}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TString8">
               <Inherits>
                  <Inherit name="MString8" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TString8" description="构造一个ANSI字符串类。"/>
                  <Constructor name="TString8" description="构造一个ANSI字符串类。">
                     <Parameters>
                        <Parameter type="TString8&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString8" description="构造一个ANSI字符串类。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString8" description="构造一个ANSI字符串类。">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="value"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TString8" description="析构一个ANSI字符串类。"/>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      this-&gt;_length = 0;\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_pMemory = RTypeMemory&lt;TChar8&gt;::Alloc(this-&gt;_size, 0);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="TString8&amp;" name="value"/>
                     </Parameters>
                     <Return type="void" description="结果字符串对象"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param source ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid TString8::operator=(const TString8&amp; value){\n   Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="void" description="结果字符串对象"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串的内容。&lt;/T&gt;\n//\n// @param source ANSI字符串\n// @return 结果字符串对象\n//============================================================\n\nvoid TString8::operator=(TChar8C* pValue){\n   Assign(pValue);\n}</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串指针对象。">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void" description="结果字符串对象"/>
                     <Source>//============================================================\n// &lt;T&gt;将当前字符串的内容设置为指定ANSI字符串指针对象。&lt;/T&gt;\n//\n// @param source ANSI字符串指针对象\n// @return 结果字符串对象\n//============================================================\n\nvoid TString8::operator=(const MString8PtrC&amp; value){\n   Assign(value.MemoryC(), value.Length());\n}</Source>
                  </Method>
                  <Method name="AssignWide" description="将指定UNICODE字符串指针对象赋值给当前字符串。 ">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue" description="UNICODE 字符串指针对象"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将指定UNICODE字符串指针对象赋值给当前字符串。 &lt;/T&gt;\n//\n// @param pValue UNICODE 字符串指针对象\n//============================================================\n\nvoid TString8::AssignWide(TChar16C* pValue){\n   TSize length = RString16::ConvertToString8(pValue);\n   if(0 &gt;= length){\n      MO_ERROR(&quot;convert error!&quot;);\n   }else{\n      InnerInitialize(length);\n      Clear();\n      RString16::ConvertToString8(_pMemory, length, pValue);\n      _length = length;\n   }\n}</Source>
                  </Method>
                  <Method name="AppendWide" description="将指定UNICODE字符串指针对象添加到当前字符串。 ">
                     <Parameters>
                        <Parameter type="TChar16C*" name="pValue" description="UNICODE 字符串指针对象"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将指定UNICODE字符串指针对象添加到当前字符串。 &lt;/T&gt;\n//\n// @param pValue UNICODE 字符串指针对象\n//============================================================\n\nvoid TString8::AppendWide(TChar16C* pValue){\n   TSize length = RString16::ConvertToString8(pValue);\n   if(0 == length){\n      MO_ERROR(&quot;convert error!&quot;);\n   }else{\n      InnerInitialize(length + _length);\n      RString16::ConvertToString8(_pMemory + length, length, pValue);\n      _length = _length + length;\n   }\n}</Source>
                  </Method>
                  <Method name="AssignWide" description="将指定UNICODE字符串指针对象赋值给当前字符串。 ">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue" description="UNICODE 字符串指针对象"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将指定UNICODE字符串指针对象赋值给当前字符串。 &lt;/T&gt;\n//\n// @param pValue UNICODE 字符串指针对象\n//============================================================\n\nvoid TString8::AssignWide(TChar32C* pValue){\n   TSize length = RString32::ConvertToString8(pValue);\n   if(-1 == length){\n      MO_ERROR(&quot;convert error!&quot;);\n   }else{\n      InnerInitialize(length);\n      Clear();\n      RString32::ConvertToString8(_pMemory, length, pValue);\n      _length = length;\n   }\n}</Source>
                  </Method>
                  <Method name="AppendWide" description="将指定UNICODE字符串指针对象添加到当前字符串。 ">
                     <Parameters>
                        <Parameter type="TChar32C*" name="pValue" description="UNICODE 字符串指针对象"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;将指定UNICODE字符串指针对象添加到当前字符串。 &lt;/T&gt;\n//\n// @param pValue UNICODE 字符串指针对象\n//============================================================\n\nvoid TString8::AppendWide(TChar32C* pValue){\n   TSize length = RString32::ConvertToString8(pValue);\n   if(-1 == length){\n      MO_ERROR(&quot;convert error!&quot;);\n   }else{\n      InnerInitialize(length + _length);\n      RString32::ConvertToString8(_pMemory + length, length, pValue);\n      _length = _length + length;\n   }\n}</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size" description="大小"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;确保内存大小。&lt;/T&gt;\n// &lt;P&gt;当第一次使用是，会收集第一块内存。\n// 当前大小内存不足时，会重新收集指定大小1.5倍的内存存放数据，暂未使用的作为缓冲使用。\n// 当内存不再发生大小上改变的时候，可以使用压缩函数释放掉所有未使用的缓冲内存。&lt;/P&gt;\n//\n// @param size 大小\n//============================================================\n\nvoid TString8::EnsureSize(TInt size){\n   if(size &gt; this-&gt;_size){\n      // 当内存不足时，扩大1.5倍内存，但收集量不得小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_size += this-&gt;_size &gt;&gt; 1;\n      TChar8* pMemory = RTypeMemory&lt;TChar8&gt;::Alloc(this-&gt;_size, 0);\n      if(this-&gt;_length &gt; 0){\n         RTypes&lt;TChar8&gt;::Copy(pMemory, this-&gt;_pMemory, this-&gt;_length);\n      }\n      RTypeMemory&lt;TChar8&gt;::Free(this-&gt;_pMemory);\n      this-&gt;_pMemory = pMemory;\n   }\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TString8Ptr">
               <Inherits>
                  <Inherit name="TChar8Ptr" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TString8Ptr" description="构建空指针对象。"/>
                  <Constructor name="TString8Ptr" description="从数据指针构建对象。">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pMemory"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString8Ptr" description="从数据指针构建对象。">
                     <Parameters>
                        <Parameter type="TUchar8C*" name="pMemory"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString8Ptr" description="从数据指针和长度构建对象。">
                     <Parameters>
                        <Parameter type="TInt" name="size" default="0"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString8Ptr" description="从其他指针对象构建对象。">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator=" description="重载指针复制操作。">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString8PtrC&amp; ptr) {\n      Set(ptr);\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TString8Refer">
               <Inherits>
                  <Inherit name="MString8" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TString8Refer">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString8Refer">
                     <Parameters>
                        <Parameter type="TChar8*" name="pValue"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString8Refer">
                     <Parameters>
                        <Parameter type="TChar8*" name="pValue"/>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                  </Constructor>
                  <Method name="EnsureSize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void EnsureSize(TInt size){\n      MO_ASSERT(size &lt;= this-&gt;_size);\n   }</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TString8Refer&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TString8Refer&amp; value){\n      Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TChar8C*" name="pValue"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(TChar8C* pValue){\n      Assign(pValue);\n   }</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="MString8PtrC&amp;" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString8PtrC&amp; value){\n      Assign(value.MemoryC(), value.Length());\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TString8s">
               <Inherits>
                  <Inherit name="MString8s" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TString8s"/>
                  <Constructor name="TString8s">
                     <Parameters>
                        <Parameter type="MString8sC&amp;" name="strings"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TString8s">
                     <Parameters>
                        <Parameter type="TString8s&amp;" name="strings"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TString8s"/>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="MString8sC&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MString8sC&amp; strings){\n		Assign(strings);\n	}</Source>
                  </Method>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="TString8s&amp;" name="strings"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TString8s&amp; strings){\n		Assign(strings);\n	}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TThreadCondition">
               <Methods>
                  <Constructor name="TThreadCondition" description="创建线程事件。"/>
                  <Destructor name="~TThreadCondition" description="释放线程事件。"/>
                  <Method name="Lock" description="加锁。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;加锁。&lt;/T&gt;\n//============================================================\n\nvoid TThreadCondition::Lock(){\n#ifdef _WINDOWS\n#else\n   TInt result = pthread_mutex_lock(&amp;_mutex);\n   if(ESuccess != result){\n      MO_PFATAL(pthread_mutex_lock);\n   }\n#endif\n}</Source>
                  </Method>
                  <Method name="Unlock" description="解锁。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;解锁。&lt;/T&gt;\n//============================================================\n\nvoid TThreadCondition::Unlock(){\n#ifdef _WINDOWS\n#else\n   TInt result = pthread_mutex_unlock(&amp;_mutex);\n   if(ESuccess != result){\n      MO_PFATAL(pthread_mutex_unlock);\n   }\n#endif\n}</Source>
                  </Method>
                  <Method name="Wait" description="等待解锁。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;等待解锁。&lt;/T&gt;\n//============================================================\n\nvoid TThreadCondition::Wait(){\n#ifdef _WINDOWS\n#else\n   TInt result = pthread_cond_wait(&amp;_condition, &amp;_mutex);\n   if(ESuccess != result){\n      // EINVAL：cv 或 mp 指定的值无效。\n      MO_PFATAL(pthread_cond_wait);\n   }\n#endif\n}</Source>
                  </Method>
                  <Method name="Wait" description="等待解锁。">
                     <Parameters>
                        <Parameter type="TInt" name="msecond"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;等待解锁。&lt;/T&gt;\n//============================================================\n\nvoid TThreadCondition::Wait(TInt msecond){\n#ifdef _WINDOWS\n#else\n   time_t now = time(NULL);\n   timespec abstime;\n   abstime.tv_nsec = now + (msecond/1000);\n   abstime.tv_nsec = (msecond % 1000) * 1000 * 1000;\n   TInt result = pthread_cond_timedwait(&amp;_condition, &amp;_mutex, &amp;abstime);\n   if(ESuccess != result){\n      // EINVAL：cv 或 abstime 指向的地址非法。\n      // ETIMEDOUT：abstime 指定的时间已过。\n      MO_PFATAL(pthread_cond_timedwait);\n   }\n#endif\n}</Source>
                  </Method>
                  <Method name="Signal" description="发送解锁信号。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;发送解锁信号。&lt;/T&gt;\n//============================================================\n\nvoid TThreadCondition::Signal(){\n#ifdef _WINDOWS\n#else\n   TInt result = pthread_cond_signal(&amp;_condition);\n   if(ESuccess != result){\n      // EINVAL：cv 指向的地址非法。\n      MO_PFATAL(pthread_cond_signal);\n   }\n#endif\n}</Source>
                  </Method>
                  <Method name="Notify" description="通知解除锁。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;通知解除锁。&lt;/T&gt;\n//============================================================\n\nvoid TThreadCondition::Notify(){\n   // 锁定\n   Lock();\n   // 继续\n   Signal();\n   // 解除锁定\n   Unlock();\n}</Source>
                  </Method>
                  <Method name="Broadcast" description="广播解除所有锁。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;广播解除所有锁。&lt;/T&gt;\n//============================================================\n\nvoid TThreadCondition::Broadcast(){\n#ifdef _WINDOWS\n#else\n   TInt result = pthread_cond_broadcast(&amp;_condition);\n   if(ESuccess != result){\n      // EINVAL：cv 指示的地址非法。\n      MO_PFATAL(pthread_cond_broadcast);\n   }\n#endif\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="pthread_mutex_t" name="_mutex"/>
                  <Attribute type="pthread_cond_t" name="_condition"/>
                  <Attribute type="pthread_condattr_t" name="_attribute"/>
               </Attributes>
            </Class>
            <Class name="TThreadCounter">
               <Methods>
                  <Method name="Get">
                     <Return type="TInt"/>
                  </Method>
                  <Method name="Set">
                     <Parameters>
                        <Parameter type="TInt" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                  </Method>
                  <Method name="Increment">
                     <Return type="void"/>
                  </Method>
                  <Method name="Decrement">
                     <Return type="void"/>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TInt" name="_value"/>
               </Attributes>
            </Class>
            <Class name="TThreadMutex">
               <Methods>
                  <Constructor name="TThreadMutex" description="创建临界段。"/>
                  <Destructor name="~TThreadMutex" description="释放临界段。"/>
                  <Method name="Enter" description="进入临界段。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;进入临界段。&lt;/T&gt;\n//============================================================\n\nvoid TThreadMutex::Enter(){\n#ifdef _WINDOWS\n   EnterCriticalSection(&amp;_section);\n#else\n   TInt result = pthread_mutex_lock(&amp;_section);\n   if(ESuccess != result){\n      // EAGAIN：由于已超出了互斥锁递归锁定的最大次数，因此无法获取该互斥锁。\n      // EDEADLK：当前线程已经拥有互斥锁。\n      // EOWNERDEAD：该互斥锁的最后一个属主在持有该互斥锁时失败。\n      //    该互斥锁现在由调用方拥有。调用方必须尝试使该互斥锁所保护的状态一致。\n      // ENOTRECOVERABLE：尝试获取的互斥锁正在保护某个状态，\n      //    此状态由于该互斥锁以前的属主在持有该锁时失败而导致不可恢复。\n      //    尚未获取该互斥锁。\n      MO_PFATAL(pthread_mutex_lock);\n   }\n#endif\n}</Source>
                  </Method>
                  <Method name="TryEnter" description="进入临界段。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;进入临界段。&lt;/T&gt;\n//============================================================\n\nvoid TThreadMutex::TryEnter(){\n#ifdef _WINDOWS\n   EnterCriticalSection(&amp;_section);\n#else\n   TInt result = pthread_mutex_trylock(&amp;_section);\n   if(ESuccess != result){\n      // EBUSY：由于 mutex 所指向的互斥锁已锁定，因此无法获取该互斥锁。\n      // EAGAIN：由于已超出了 mutex 的递归锁定最大次数，因此无法获取该互斥锁。\n      // EOWNERDEAD：该互斥锁的最后一个属主在持有该互斥锁时失败。\n      //    该互斥锁现在由调用方拥有。调用方必须尝试使该互斥锁所保护的状态一致。\n      // ENOTRECOVERABLE：尝试获取的互斥锁正在保护某个状态，\n      //    此状态由于该互斥锁以前的属主在持有该锁时失败而导致不可恢复。\n      //    尚未获取该互斥锁。\n      // ENOMEM：已经超出了可同时持有的互斥锁数目的限制。\n      MO_PFATAL(pthread_mutex_trylock);\n   }\n#endif\n}</Source>
                  </Method>
                  <Method name="Leave" description="离开临界段。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;离开临界段。&lt;/T&gt;\n//============================================================\n\nvoid TThreadMutex::Leave(){\n#ifdef _WINDOWS\n   LeaveCriticalSection(&amp;_section);\n#else\n   TInt result = pthread_mutex_unlock(&amp;_section);\n   if(ESuccess != result){\n      // EPERM：当前线程不拥有互斥锁。\n      MO_PFATAL(pthread_mutex_unlock);\n   }\n#endif\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="TCharC*" name="_pName"/>
                  <Attribute type="CRITICAL_SECTION" name="_section"/>
                  <Attribute type="pthread_mutex_t" name="_section"/>
               </Attributes>
            </Class>
            <Class name="TThreadSection">
               <Methods>
                  <Constructor name="TThreadSection" description="创建临界段。"/>
                  <Destructor name="~TThreadSection" description="释放临界段。"/>
                  <Method name="Enter" description="进入临界段。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;进入临界段。&lt;/T&gt;\n//============================================================\n\nvoid TThreadSection::Enter(){\n#ifdef _WINDOWS\n   EnterCriticalSection(&amp;_section);\n#else\n   pthread_spin_lock(&amp;_section);\n#endif\n}</Source>
                  </Method>
                  <Method name="TryEnter" description="尝试进入临界段。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;尝试进入临界段。&lt;/T&gt;\n//============================================================\n\nvoid TThreadSection::TryEnter(){\n#ifndef _WINDOWS\n   pthread_spin_trylock(&amp;_section);\n#endif\n}</Source>
                  </Method>
                  <Method name="Leave" description="离开临界段。">
                     <Return type="void"/>
                     <Source>//============================================================\n// &lt;T&gt;离开临界段。&lt;/T&gt;\n//============================================================\n\nvoid TThreadSection::Leave(){\n#ifdef _WINDOWS\n   LeaveCriticalSection(&amp;_section);\n#else\n   pthread_spin_unlock(&amp;_section);\n#endif\n}</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="CRITICAL_SECTION" name="_section"/>
                  <Attribute type="pthread_spinlock_t" name="_section"/>
               </Attributes>
            </Class>
            <Class name="TThreadSemaphore">
               <Methods>
                  <Method name="Create">
                     <Return type="void"/>
                  </Method>
                  <Method name="Open">
                     <Return type="void"/>
                  </Method>
                  <Method name="WaitForObject">
                     <Return type="void"/>
                  </Method>
                  <Method name="WaitForObjects">
                     <Return type="void"/>
                  </Method>
                  <Method name="MessageWaitForObects">
                     <Return type="void"/>
                  </Method>
                  <Method name="Close">
                     <Return type="void"/>
                  </Method>
                  <Method name="Release">
                     <Return type="void"/>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="PPtr" name="_handle"/>
               </Attributes>
            </Class>
            <Class name="TTrapper">
               <Attributes>
                  <Attribute type="FThreadTrap*" name="_pThreadTrap"/>
                  <Attribute type="FTrap*" name="_pTrap"/>
               </Attributes>
            </Class>
            <Class name="TTree">
               <Inherits>
                  <Inherit name="MTree" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TTree">
                     <Parameters>
                        <Parameter type="TInt" name="level"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TTree">
                     <Parameters>
                        <Parameter type="MTreeC&lt;N, V&gt;&amp;" name="tree"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TTree"/>
                  <Method name="operator=">
                     <Parameters>
                        <Parameter type="MTreeC&lt;N, V&gt;&amp;" name="tree"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MTreeC&lt;N, V&gt;&amp; tree){\n      this-&gt;Assign(tree);\n	}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TTreeIterator">
               <Inherits>
                  <Inherit name="TTreeIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TTreeIterator"/>
                  <Constructor name="TTreeIterator"/>
                  <Constructor name="TTreeIterator"/>
                  <Method name="SetValue" type="inline">
                     <Parameters>
                        <Parameter type="V" name="value"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void SetValue(V value) const{\n      MO_ASSERT(this-&gt;_pEntry);\n      this-&gt;_pEntry-&gt;value = value;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TTreeIteratorC">
               <Inherits>
                  <Inherit name="MLinkedIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TTreeIteratorC"/>
                  <Constructor name="TTreeIteratorC">
                     <Parameters>
                        <Parameter type="TTreeIteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TTreeIteratorC">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry"/>
                     </Parameters>
                  </Constructor>
                  <Method name="operator==" type="inline">
                     <Parameters>
                        <Parameter type="TTreeIteratorC&amp;" name="iterator"/>
                     </Parameters>
                     <Return type="EBoolean"/>
                     <Source>\ninline EBoolean operator==(const TTreeIteratorC&amp; iterator) const{\n      if((NULL != this-&gt;_pEntry) &amp;&amp; (NULL != iterator._pEntry)){\n         return this-&gt;_pEntry-&gt;value == iterator._pEntry-&gt;value;\n      }\n      return EFalse;\n   }</Source>
                  </Method>
                  <Method name="operator!=" type="inline">
                     <Parameters>
                        <Parameter type="TTreeIteratorC&amp;" name="iterator"/>
                     </Parameters>
                     <Return type="EBoolean"/>
                     <Source>\ninline EBoolean operator!=(const TTreeIteratorC&amp; iterator) const{\n      if((NULL != this-&gt;_pEntry) &amp;&amp; (NULL != iterator._pEntry)){\n         return this-&gt;_pEntry-&gt;value != iterator._pEntry-&gt;value;\n      }\n      return ETrue;\n   }</Source>
                  </Method>
                  <Method name="*" type="inline">
                     <Return type="operator"/>
                     <Source>\ninline const V&amp; operator *() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
                  <Method name="operator-&gt;" type="inline">
                     <Return type="V*"/>
                     <Source>\ninline const V* operator-&gt;() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return &amp;(this-&gt;_pEntry-&gt;value);\n   }</Source>
                  </Method>
                  <Method name="Code" type="inline">
                     <Return type="N"/>
                     <Source>\ninline N Code() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;code;\n   }</Source>
                  </Method>
                  <Method name="Value" type="inline">
                     <Return type="V"/>
                     <Source>\ninline V Value() const{\n      MO_ASSERT(this-&gt;_pEntry);\n      return this-&gt;_pEntry-&gt;value;\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TVector">
               <Inherits>
                  <Inherit name="MVector" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TVector" description="构造变长数组。"/>
                  <Constructor name="TVector" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="TInt" name="capacity"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TVector" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="T*" name="pValues"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TVector" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TVector" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TVector" description="构造变长数组。">
                     <Parameters>
                        <Parameter type="TVector&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                  </Constructor>
                  <Destructor name="~TVector" description="析构变长数组。"/>
                  <Method name="InnerInitialize" type="inline">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(TInt size){\n      // 当第一次使用的时候，收集不小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n      this-&gt;_count = 0;\n      this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n      this-&gt;_pMemory = RTypeMemory&lt;T&gt;::Alloc(this-&gt;_size, NULL);\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="MPtrC&lt;T&gt;&amp;" name="ptr"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MPtrC&lt;T&gt;&amp; ptr){\n      Assign(ptr.MemoryC(), ptr.Length());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="MVectorC&lt;T&gt;&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const MVectorC&lt;T&gt;&amp; values){\n      Assign(values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="operator=" description="将当前字符串的内容设置为指定ANSI字符串的内容。">
                     <Parameters>
                        <Parameter type="TVector&amp;" name="values"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid operator=(const TVector&amp; values){\n      Assign(values.MemoryC(), values.Count());\n   }</Source>
                  </Method>
                  <Method name="EnsureSize" description="确保内存大小。">
                     <Parameters>
                        <Parameter type="TInt" name="size"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\nvoid EnsureSize(TInt size){\n      if(size &gt; this-&gt;_size){\n         // 当内存不足时，扩大1.5倍内存，但收集量不得小于默认值&lt;C&gt;MO_MEMORY_CAPACITY&lt;/C&gt;的内存。\n         this-&gt;_size = MO_MAX(MO_MEMORY_CAPACITY, size);\n         this-&gt;_size += this-&gt;_size &gt;&gt; 1;\n         T* pMemory = RTypeMemory&lt;T&gt;::Alloc(this-&gt;_size, NULL);\n         if(this-&gt;_count &gt; 0){\n            RTypes&lt;T&gt;::Copy(pMemory, this-&gt;_pMemory, this-&gt;_count);\n         }\n         RTypeMemory&lt;T&gt;::Free(this-&gt;_pMemory);\n         this-&gt;_pMemory = pMemory;\n      }\n   }</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="TVectorIteratorC">
               <Methods>
                  <Constructor name="TVectorIteratorC" description="构造只读迭代器。"/>
                  <Constructor name="TVectorIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="TVectorIteratorC&amp;" name="iterator"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TVectorIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                  </Constructor>
                  <Method name="InnerInitialize" type="inline" description="内部初始化。">
                     <Parameters>
                        <Parameter type="T*" name="pMemory"/>
                        <Parameter type="TInt" name="count"/>
                     </Parameters>
                     <Return type="void"/>
                     <Source>\ninline void InnerInitialize(T* pMemory, TInt count){\n      _pMemory = pMemory;\n      _count = count;\n      _index = -1;\n   }</Source>
                  </Method>
                  <Method name="*" type="inline" description="获得当前位置的数据内容。">
                     <Return type="operator"/>
                     <Source>\ninline const T&amp; operator *() const{\n      MO_ASSERT(_pMemory);\n      MO_ASSERT_RANGE(_index, 0, _count);\n      return _pMemory[_index];\n   }</Source>
                  </Method>
                  <Method name="operator-&gt;" type="inline" description="获得当前位置的数据内容。">
                     <Return type="T"/>
                     <Source>\ninline const T operator-&gt;() const{\n      MO_ASSERT(_pMemory);\n      MO_ASSERT_RANGE(_index, 0, _count);\n      return _pMemory[_index];\n   }</Source>
                  </Method>
                  <Method name="IsEmpty" type="inline" description="当前节点是否含有数据。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool IsEmpty(){\n      return (0 == _count);\n   }</Source>
                  </Method>
                  <Method name="Equals" type="inline" description="判断数据内容是否相等。">
                     <Parameters>
                        <Parameter type="T" name="value"/>
                     </Parameters>
                     <Return type="TBool"/>
                     <Source>\ninline TBool Equals(T value){\n      MO_ASSERT(_pMemory);\n      MO_ASSERT_RANGE(_index, 0, _count);\n      return _pMemory[_index] == value;\n   }</Source>
                  </Method>
                  <Method name="HasNext" type="inline" description="判断是否存在下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool HasNext(){\n      return (_count &gt; 0) ? _index + 1 &lt; _count : EFalse;\n   }</Source>
                  </Method>
                  <Method name="Next" type="inline" description=" 移动到下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Next(){\n      if(_count &gt; 0 &amp;&amp; (_index + 1 &lt; _count)){\n         _index++;\n         return ETrue;\n      }\n      return EFalse;\n   }</Source>
                  </Method>
                  <Method name="HasPrior" type="inline" description="判断是否存在下一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool HasPrior(){\n      return (_count &gt; 0) ? _index - 1 &gt;= 0 : EFalse;\n   }</Source>
                  </Method>
                  <Method name="Prior" type="inline" description="移动到上一个位置。">
                     <Return type="TBool"/>
                     <Source>\ninline TBool Prior(){\n      if(_count &gt; 0 &amp;&amp; (_index + 1 &lt; _count)){\n         _index--;\n         return ETrue;\n      }\n      return EFalse;\n   }</Source>
                  </Method>
                  <Method name="Get" type="inline" description="获得当前位置的数据内容。">
                     <Return type="T"/>
                     <Source>\ninline T Get(){\n      MO_ASSERT(_pMemory);\n      MO_ASSERT_RANGE(_index, 0, _count);\n      return _pMemory[_index];\n   }</Source>
                  </Method>
                  <Method name="Reset" type="inline" description="重置位置。">
                     <Return type="void"/>
                     <Source>\ninline void Reset(){\n      _index = -1;\n   }</Source>
                  </Method>
               </Methods>
               <Attributes>
                  <Attribute type="T*" name="_pMemory"/>
                  <Attribute type="TInt" name="_count"/>
                  <Attribute type="TInt" name="_index"/>
               </Attributes>
            </Class>
            <Class name="TWeekPtr"/>
            <Class name="TXmlNodeIteratorC">
               <Inherits>
                  <Inherit name="TListIteratorC" scope="public"/>
               </Inherits>
               <Methods>
                  <Constructor name="TXmlNodeIteratorC" description="构造只读迭代器。"/>
                  <Constructor name="TXmlNodeIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="TXmlNodeIteratorC&amp;" name="iterator" description="只读迭代器"/>
                     </Parameters>
                  </Constructor>
                  <Constructor name="TXmlNodeIteratorC" description="构造只读迭代器。">
                     <Parameters>
                        <Parameter type="SEntry*" name="pEntry" description="入口对象"/>
                     </Parameters>
                  </Constructor>
                  <Method name="Next" description="移动到下一个位置。">
                     <Return type="TBool" description="移动结果"/>
                     <Source>//============================================================\n// &lt;T&gt;移动到下一个位置。&lt;/T&gt;\n//\n// @return 移动结果\n//============================================================\n\nTBool TXmlNodeIteratorC::Next(){\n   return TListIteratorC&lt;FXmlNode*&gt;::Next();\n}</Source>
                  </Method>
                  <Method name="Next" description="移动到下一个位置。">
                     <Parameters>
                        <Parameter type="TCharC*" name="pName" description="名称"/>
                     </Parameters>
                     <Return type="TBool" description="移动结果"/>
                     <Source>//============================================================\n// &lt;T&gt;移动到下一个位置。&lt;/T&gt;\n//\n// @param pName 名称\n// @return 移动结果\n//============================================================\n\nTBool TXmlNodeIteratorC::Next(TCharC* pName){\n   while(ETrue){\n      // 获得下一个位置\n      _pEntry = (NULL == _pEntry) ? _pStart : _pEntry-&gt;pNext;\n      if(NULL == _pEntry){\n         break;\n      }\n      // 判断是否满足条件\n      if(_pEntry-&gt;value-&gt;IsName(pName)){\n         break;\n      }\n   }\n   return (NULL != _pEntry);\n}</Source>
                  </Method>
               </Methods>
            </Class>
            <Class name="_SPipeInfo">
               <Attributes>
                  <Attribute type="TUint32" name="capacity"/>
                  <Attribute type="TUint32" name="first"/>
                  <Attribute type="TUint32" name="last"/>
               </Attributes>
            </Class>
         </Classes>
      </Namespace>
   </Namespaces>
   <Typedefs/>
   <Variables/>
   <Methods/>
   <Classes/>
</Configuration>
